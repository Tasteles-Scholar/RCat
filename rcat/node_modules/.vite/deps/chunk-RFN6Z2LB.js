import {
  DrawWrapper,
  Viewport
} from "./chunk-NSQCR3LX.js";
import {
  VertexBuffer
} from "./chunk-MX32RALM.js";
import {
  Tools
} from "./chunk-J3DITW5F.js";
import {
  Clamp
} from "./chunk-537VGFRK.js";
import {
  Effect
} from "./chunk-ULQUZGBY.js";
import {
  EngineStore,
  Observable
} from "./chunk-TS7CPY6B.js";

// node_modules/@babylonjs/core/Materials/effectRenderer.js
var defaultOptions = {
  positions: [1, 1, -1, 1, -1, -1, 1, -1],
  indices: [0, 1, 2, 0, 2, 3]
};
var EffectRenderer = class {
  /**
   * Creates an effect renderer
   * @param engine the engine to use for rendering
   * @param options defines the options of the effect renderer
   */
  constructor(engine, options = defaultOptions) {
    this._fullscreenViewport = new Viewport(0, 0, 1, 1);
    const positions = options.positions ?? defaultOptions.positions;
    const indices = options.indices ?? defaultOptions.indices;
    this.engine = engine;
    this._vertexBuffers = {
      [VertexBuffer.PositionKind]: new VertexBuffer(engine, positions, VertexBuffer.PositionKind, false, false, 2)
    };
    this._indexBuffer = engine.createIndexBuffer(indices);
    this._onContextRestoredObserver = engine.onContextRestoredObservable.add(() => {
      this._indexBuffer = engine.createIndexBuffer(indices);
      for (const key in this._vertexBuffers) {
        const vertexBuffer = this._vertexBuffers[key];
        vertexBuffer._rebuild();
      }
    });
  }
  /**
   * Sets the current viewport in normalized coordinates 0-1
   * @param viewport Defines the viewport to set (defaults to 0 0 1 1)
   */
  setViewport(viewport = this._fullscreenViewport) {
    this.engine.setViewport(viewport);
  }
  /**
   * Binds the embedded attributes buffer to the effect.
   * @param effect Defines the effect to bind the attributes for
   */
  bindBuffers(effect) {
    this.engine.bindBuffers(this._vertexBuffers, this._indexBuffer, effect);
  }
  /**
   * Sets the current effect wrapper to use during draw.
   * The effect needs to be ready before calling this api.
   * This also sets the default full screen position attribute.
   * @param effectWrapper Defines the effect to draw with
   */
  applyEffectWrapper(effectWrapper) {
    this.engine.setState(true);
    this.engine.depthCullingState.depthTest = false;
    this.engine.stencilState.stencilTest = false;
    this.engine.enableEffect(effectWrapper._drawWrapper);
    this.bindBuffers(effectWrapper.effect);
    effectWrapper.onApplyObservable.notifyObservers({});
  }
  /**
   * Saves engine states
   */
  saveStates() {
    this._savedStateDepthTest = this.engine.depthCullingState.depthTest;
    this._savedStateStencilTest = this.engine.stencilState.stencilTest;
  }
  /**
   * Restores engine states
   */
  restoreStates() {
    this.engine.depthCullingState.depthTest = this._savedStateDepthTest;
    this.engine.stencilState.stencilTest = this._savedStateStencilTest;
  }
  /**
   * Draws a full screen quad.
   */
  draw() {
    this.engine.drawElementsType(0, 0, 6);
  }
  _isRenderTargetTexture(texture) {
    return texture.renderTarget !== void 0;
  }
  /**
   * renders one or more effects to a specified texture
   * @param effectWrapper the effect to renderer
   * @param outputTexture texture to draw to, if null it will render to the screen.
   */
  render(effectWrapper, outputTexture = null) {
    if (!effectWrapper.effect.isReady()) {
      return;
    }
    this.saveStates();
    this.setViewport();
    const out = outputTexture === null ? null : this._isRenderTargetTexture(outputTexture) ? outputTexture.renderTarget : outputTexture;
    if (out) {
      this.engine.bindFramebuffer(out);
    }
    this.applyEffectWrapper(effectWrapper);
    this.draw();
    if (out) {
      this.engine.unBindFramebuffer(out);
    }
    this.restoreStates();
  }
  /**
   * Disposes of the effect renderer
   */
  dispose() {
    const vertexBuffer = this._vertexBuffers[VertexBuffer.PositionKind];
    if (vertexBuffer) {
      vertexBuffer.dispose();
      delete this._vertexBuffers[VertexBuffer.PositionKind];
    }
    if (this._indexBuffer) {
      this.engine._releaseBuffer(this._indexBuffer);
    }
    if (this._onContextRestoredObserver) {
      this.engine.onContextRestoredObservable.remove(this._onContextRestoredObserver);
      this._onContextRestoredObserver = null;
    }
  }
};
var EffectWrapper = class {
  /**
   * The underlying effect
   */
  get effect() {
    return this._drawWrapper.effect;
  }
  set effect(effect) {
    this._drawWrapper.effect = effect;
  }
  /**
   * Creates an effect to be renderer
   * @param creationOptions options to create the effect
   */
  constructor(creationOptions) {
    this.onApplyObservable = new Observable();
    let shaderPath;
    const uniformNames = creationOptions.uniformNames || [];
    if (creationOptions.vertexShader) {
      shaderPath = {
        fragmentSource: creationOptions.fragmentShader,
        vertexSource: creationOptions.vertexShader,
        spectorName: creationOptions.name || "effectWrapper"
      };
    } else {
      uniformNames.push("scale");
      shaderPath = {
        fragmentSource: creationOptions.fragmentShader,
        vertex: "postprocess",
        spectorName: creationOptions.name || "effectWrapper"
      };
      this.onApplyObservable.add(() => {
        this.effect.setFloat2("scale", 1, 1);
      });
    }
    const defines = creationOptions.defines ? creationOptions.defines.join("\n") : "";
    this._drawWrapper = new DrawWrapper(creationOptions.engine);
    if (creationOptions.useShaderStore) {
      shaderPath.fragment = shaderPath.fragmentSource;
      if (!shaderPath.vertex) {
        shaderPath.vertex = shaderPath.vertexSource;
      }
      delete shaderPath.fragmentSource;
      delete shaderPath.vertexSource;
      this.effect = creationOptions.engine.createEffect(shaderPath, creationOptions.attributeNames || ["position"], uniformNames, creationOptions.samplerNames, defines, void 0, creationOptions.onCompiled, void 0, void 0, creationOptions.shaderLanguage, creationOptions.extraInitializationsAsync);
    } else {
      this.effect = new Effect(shaderPath, creationOptions.attributeNames || ["position"], uniformNames, creationOptions.samplerNames, creationOptions.engine, defines, void 0, creationOptions.onCompiled, void 0, void 0, void 0, creationOptions.shaderLanguage, creationOptions.extraInitializationsAsync);
      this._onContextRestoredObserver = creationOptions.engine.onContextRestoredObservable.add(() => {
        this.effect._pipelineContext = null;
        this.effect._prepareEffect();
      });
    }
  }
  /**
   * Disposes of the effect wrapper
   * @param _ignored kept for backward compatibility
   */
  dispose(_ignored = false) {
    if (this._onContextRestoredObserver) {
      this.effect.getEngine().onContextRestoredObservable.remove(this._onContextRestoredObserver);
      this._onContextRestoredObserver = null;
    }
    this.effect.dispose();
  }
};

// node_modules/@babylonjs/core/Misc/dumpTools.js
var _dumpToolsEngine;
var _enginePromise = null;
async function _CreateDumpRenderer() {
  if (!_enginePromise) {
    _enginePromise = new Promise((resolve, reject) => {
      let canvas;
      let engine = null;
      const options = {
        preserveDrawingBuffer: true,
        depth: false,
        stencil: false,
        alpha: true,
        premultipliedAlpha: false,
        antialias: false,
        failIfMajorPerformanceCaveat: false
      };
      import("./thinEngine-4WWSBCUX.js").then(({ ThinEngine: thinEngineClass }) => {
        try {
          canvas = new OffscreenCanvas(100, 100);
          engine = new thinEngineClass(canvas, false, options);
        } catch (e) {
          canvas = document.createElement("canvas");
          engine = new thinEngineClass(canvas, false, options);
        }
        EngineStore.Instances.pop();
        EngineStore.OnEnginesDisposedObservable.add((e) => {
          if (engine && e !== engine && !engine.isDisposed && EngineStore.Instances.length === 0) {
            Dispose();
          }
        });
        engine.getCaps().parallelShaderCompile = void 0;
        const renderer = new EffectRenderer(engine);
        import("./pass.fragment-KOCN5MT7.js").then(({ passPixelShader }) => {
          if (!engine) {
            reject("Engine is not defined");
            return;
          }
          const wrapper = new EffectWrapper({
            engine,
            name: passPixelShader.name,
            fragmentShader: passPixelShader.shader,
            samplerNames: ["textureSampler"]
          });
          _dumpToolsEngine = {
            canvas,
            engine,
            renderer,
            wrapper
          };
          resolve(_dumpToolsEngine);
        });
      }).catch(reject);
    });
  }
  return await _enginePromise;
}
async function DumpFramebuffer(width, height, engine, successCallback, mimeType = "image/png", fileName, quality) {
  const bufferView = await engine.readPixels(0, 0, width, height);
  const data = new Uint8Array(bufferView.buffer);
  DumpData(width, height, data, successCallback, mimeType, fileName, true, void 0, quality);
}
function DumpDataAsync(width, height, data, mimeType = "image/png", fileName, invertY = false, toArrayBuffer = false, quality) {
  return new Promise((resolve) => {
    DumpData(width, height, data, (result) => resolve(result), mimeType, fileName, invertY, toArrayBuffer, quality);
  });
}
function DumpData(width, height, data, successCallback, mimeType = "image/png", fileName, invertY = false, toArrayBuffer = false, quality) {
  _CreateDumpRenderer().then((renderer) => {
    renderer.engine.setSize(width, height, true);
    if (data instanceof Float32Array) {
      const data2 = new Uint8Array(data.length);
      let n = data.length;
      while (n--) {
        const v = data[n];
        data2[n] = Math.round(Clamp(v) * 255);
      }
      data = data2;
    }
    const texture = renderer.engine.createRawTexture(data, width, height, 5, false, !invertY, 1);
    renderer.renderer.setViewport();
    renderer.renderer.applyEffectWrapper(renderer.wrapper);
    renderer.wrapper.effect._bindTexture("textureSampler", texture);
    renderer.renderer.draw();
    if (toArrayBuffer) {
      Tools.ToBlob(renderer.canvas, (blob) => {
        const fileReader = new FileReader();
        fileReader.onload = (event) => {
          const arrayBuffer = event.target.result;
          if (successCallback) {
            successCallback(arrayBuffer);
          }
        };
        fileReader.readAsArrayBuffer(blob);
      }, mimeType, quality);
    } else {
      Tools.EncodeScreenshotCanvasData(renderer.canvas, successCallback, mimeType, fileName, quality);
    }
    texture.dispose();
  });
}
function Dispose() {
  if (_dumpToolsEngine) {
    _dumpToolsEngine.wrapper.dispose();
    _dumpToolsEngine.renderer.dispose();
    _dumpToolsEngine.engine.dispose();
  } else {
    _enginePromise == null ? void 0 : _enginePromise.then((dumpToolsEngine) => {
      dumpToolsEngine.wrapper.dispose();
      dumpToolsEngine.renderer.dispose();
      dumpToolsEngine.engine.dispose();
    });
  }
  _enginePromise = null;
  _dumpToolsEngine = null;
}
var DumpTools = {
  // eslint-disable-next-line @typescript-eslint/naming-convention
  DumpData,
  // eslint-disable-next-line @typescript-eslint/naming-convention
  DumpDataAsync,
  // eslint-disable-next-line @typescript-eslint/naming-convention
  DumpFramebuffer,
  // eslint-disable-next-line @typescript-eslint/naming-convention
  Dispose
};
var initSideEffects = () => {
  Tools.DumpData = DumpData;
  Tools.DumpDataAsync = DumpDataAsync;
  Tools.DumpFramebuffer = DumpFramebuffer;
};
initSideEffects();

export {
  DumpFramebuffer,
  DumpDataAsync,
  DumpData,
  Dispose,
  DumpTools
};
//# sourceMappingURL=chunk-RFN6Z2LB.js.map

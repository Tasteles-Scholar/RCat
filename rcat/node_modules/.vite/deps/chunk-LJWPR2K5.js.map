{
  "version": 3,
  "sources": ["../../../dev/core/src/Misc/andOrNotEvaluator.ts", "../../../dev/core/src/Misc/tags.ts", "../../@babylonjs/core/tslib.es6.js", "../../../dev/core/src/Maths/math.color.ts", "../../../dev/core/src/Maths/math.size.ts", "../../../dev/core/src/Misc/decorators.functions.ts", "../../../dev/core/src/Misc/decorators.ts", "../../../dev/core/src/Misc/decorators.serialization.ts", "../../../dev/core/src/Maths/math.plane.ts"],
  "sourcesContent": ["/**\r\n * Class used to evaluate queries containing `and` and `or` operators\r\n */\r\nexport class AndOrNotEvaluator {\r\n    /**\r\n     * Evaluate a query\r\n     * @param query defines the query to evaluate\r\n     * @param evaluateCallback defines the callback used to filter result\r\n     * @returns true if the query matches\r\n     */\r\n    public static Eval(query: string, evaluateCallback: (val: any) => boolean): boolean {\r\n        if (!query.match(/\\([^()]*\\)/g)) {\r\n            query = AndOrNotEvaluator._HandleParenthesisContent(query, evaluateCallback);\r\n        } else {\r\n            query = query.replace(/\\([^()]*\\)/g, (r) => {\r\n                // remove parenthesis\r\n                r = r.slice(1, r.length - 1);\r\n                return AndOrNotEvaluator._HandleParenthesisContent(r, evaluateCallback);\r\n            });\r\n        }\r\n\r\n        if (query === \"true\") {\r\n            return true;\r\n        }\r\n\r\n        if (query === \"false\") {\r\n            return false;\r\n        }\r\n\r\n        return AndOrNotEvaluator.Eval(query, evaluateCallback);\r\n    }\r\n\r\n    private static _HandleParenthesisContent(parenthesisContent: string, evaluateCallback: (val: string) => boolean): string {\r\n        evaluateCallback =\r\n            evaluateCallback ||\r\n            ((r) => {\r\n                return r === \"true\" ? true : false;\r\n            });\r\n\r\n        let result;\r\n        const or = parenthesisContent.split(\"||\");\r\n\r\n        for (const i in or) {\r\n            if (Object.prototype.hasOwnProperty.call(or, i)) {\r\n                let ori = AndOrNotEvaluator._SimplifyNegation(or[i].trim());\r\n                const and = ori.split(\"&&\");\r\n\r\n                if (and.length > 1) {\r\n                    for (let j = 0; j < and.length; ++j) {\r\n                        const andj = AndOrNotEvaluator._SimplifyNegation(and[j].trim());\r\n                        if (andj !== \"true\" && andj !== \"false\") {\r\n                            if (andj[0] === \"!\") {\r\n                                result = !evaluateCallback(andj.substring(1));\r\n                            } else {\r\n                                result = evaluateCallback(andj);\r\n                            }\r\n                        } else {\r\n                            result = andj === \"true\" ? true : false;\r\n                        }\r\n                        if (!result) {\r\n                            // no need to continue since 'false && ... && ...' will always return false\r\n                            ori = \"false\";\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (result || ori === \"true\") {\r\n                    // no need to continue since 'true || ... || ...' will always return true\r\n                    result = true;\r\n                    break;\r\n                }\r\n\r\n                // result equals false (or undefined)\r\n\r\n                if (ori !== \"true\" && ori !== \"false\") {\r\n                    if (ori[0] === \"!\") {\r\n                        result = !evaluateCallback(ori.substring(1));\r\n                    } else {\r\n                        result = evaluateCallback(ori);\r\n                    }\r\n                } else {\r\n                    result = ori === \"true\" ? true : false;\r\n                }\r\n            }\r\n        }\r\n\r\n        // the whole parenthesis scope is replaced by 'true' or 'false'\r\n        return result ? \"true\" : \"false\";\r\n    }\r\n\r\n    private static _SimplifyNegation(booleanString: string): string {\r\n        booleanString = booleanString.replace(/^[\\s!]+/, (r) => {\r\n            // remove whitespaces\r\n            r = r.replace(/[\\s]/g, () => \"\");\r\n            return r.length % 2 ? \"!\" : \"\";\r\n        });\r\n\r\n        booleanString = booleanString.trim();\r\n\r\n        if (booleanString === \"!true\") {\r\n            booleanString = \"false\";\r\n        } else if (booleanString === \"!false\") {\r\n            booleanString = \"true\";\r\n        }\r\n\r\n        return booleanString;\r\n    }\r\n}\r\n", "import { AndOrNotEvaluator } from \"./andOrNotEvaluator\";\r\n\r\n/**\r\n * Class used to store custom tags\r\n */\r\nexport class Tags {\r\n    /**\r\n     * Adds support for tags on the given object\r\n     * @param obj defines the object to use\r\n     */\r\n    public static EnableFor(obj: any): void {\r\n        obj._tags = obj._tags || {};\r\n\r\n        obj.hasTags = () => {\r\n            return Tags.HasTags(obj);\r\n        };\r\n\r\n        obj.addTags = (tagsString: string) => {\r\n            return Tags.AddTagsTo(obj, tagsString);\r\n        };\r\n\r\n        obj.removeTags = (tagsString: string) => {\r\n            return Tags.RemoveTagsFrom(obj, tagsString);\r\n        };\r\n\r\n        obj.matchesTagsQuery = (tagsQuery: string) => {\r\n            return Tags.MatchesQuery(obj, tagsQuery);\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Removes tags support\r\n     * @param obj defines the object to use\r\n     */\r\n    public static DisableFor(obj: any): void {\r\n        delete obj._tags;\r\n        delete obj.hasTags;\r\n        delete obj.addTags;\r\n        delete obj.removeTags;\r\n        delete obj.matchesTagsQuery;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if the given object has tags\r\n     * @param obj defines the object to use\r\n     * @returns a boolean\r\n     */\r\n    public static HasTags(obj: any): boolean {\r\n        if (!obj._tags) {\r\n            return false;\r\n        }\r\n\r\n        const tags = obj._tags;\r\n        for (const i in tags) {\r\n            if (Object.prototype.hasOwnProperty.call(tags, i)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Gets the tags available on a given object\r\n     * @param obj defines the object to use\r\n     * @param asString defines if the tags must be returned as a string instead of an array of strings\r\n     * @returns the tags\r\n     */\r\n    public static GetTags(obj: any, asString: boolean = true): any {\r\n        if (!obj._tags) {\r\n            return null;\r\n        }\r\n        if (asString) {\r\n            const tagsArray = [];\r\n            for (const tag in obj._tags) {\r\n                if (Object.prototype.hasOwnProperty.call(obj._tags, tag) && obj._tags[tag] === true) {\r\n                    tagsArray.push(tag);\r\n                }\r\n            }\r\n            return tagsArray.join(\" \");\r\n        } else {\r\n            return obj._tags;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds tags to an object\r\n     * @param obj defines the object to use\r\n     * @param tagsString defines the tag string. The tags 'true' and 'false' are reserved and cannot be used as tags.\r\n     * A tag cannot start with '||', '&&', and '!'. It cannot contain whitespaces\r\n     */\r\n    public static AddTagsTo(obj: any, tagsString: string): void {\r\n        if (!tagsString) {\r\n            return;\r\n        }\r\n\r\n        if (typeof tagsString !== \"string\") {\r\n            return;\r\n        }\r\n\r\n        const tags = tagsString.split(\" \");\r\n        tags.forEach(function (tag) {\r\n            Tags._AddTagTo(obj, tag);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _AddTagTo(obj: any, tag: string): void {\r\n        tag = tag.trim();\r\n\r\n        if (tag === \"\" || tag === \"true\" || tag === \"false\") {\r\n            return;\r\n        }\r\n\r\n        if (tag.match(/[\\s]/) || tag.match(/^([!]|([|]|[&]){2})/)) {\r\n            return;\r\n        }\r\n\r\n        Tags.EnableFor(obj);\r\n        obj._tags[tag] = true;\r\n    }\r\n\r\n    /**\r\n     * Removes specific tags from a specific object\r\n     * @param obj defines the object to use\r\n     * @param tagsString defines the tags to remove\r\n     */\r\n    public static RemoveTagsFrom(obj: any, tagsString: string) {\r\n        if (!Tags.HasTags(obj)) {\r\n            return;\r\n        }\r\n        const tags = tagsString.split(\" \");\r\n        for (const t in tags) {\r\n            Tags._RemoveTagFrom(obj, tags[t]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _RemoveTagFrom(obj: any, tag: string): void {\r\n        delete obj._tags[tag];\r\n    }\r\n\r\n    /**\r\n     * Defines if tags hosted on an object match a given query\r\n     * @param obj defines the object to use\r\n     * @param tagsQuery defines the tag query\r\n     * @returns a boolean\r\n     */\r\n    public static MatchesQuery(obj: any, tagsQuery: string): boolean {\r\n        if (tagsQuery === undefined) {\r\n            return true;\r\n        }\r\n\r\n        if (tagsQuery === \"\") {\r\n            return Tags.HasTags(obj);\r\n        }\r\n\r\n        return AndOrNotEvaluator.Eval(tagsQuery, (r) => Tags.HasTags(obj) && obj._tags[r]);\r\n    }\r\n}\r\n", "\n/******************************************************************************\nCopyright (c) Microsoft Corporation.\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\n/* global Reflect, Promise */\n\nvar extendStatics = function(d, b) {\n    extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n    return extendStatics(d, b);\n};\n\nexport function __extends(d, b) {\n    if (typeof b !== \"function\" && b !== null)\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nexport var __assign = function() {\n    __assign = Object.assign || function __assign(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n        }\n        return t;\n    }\n    return __assign.apply(this, arguments);\n}\n\nexport function __rest(s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n}\n\nexport function __decorate(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n}\n\nexport function __param(paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n}\n\nexport function __metadata(metadataKey, metadataValue) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\n}\n\nexport function __awaiter(thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n}\n\nexport function __generator(thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n}\n\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\n\nexport function __exportStar(m, o) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\n}\n\nexport function __values(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\n\nexport function __read(o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n}\n\n/** @deprecated */\nexport function __spread() {\n    for (var ar = [], i = 0; i < arguments.length; i++)\n        ar = ar.concat(__read(arguments[i]));\n    return ar;\n}\n\n/** @deprecated */\nexport function __spreadArrays() {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n}\n\nexport function __spreadArray(to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n}\n\nexport function __await(v) {\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\n}\n\nexport function __asyncGenerator(thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n    function fulfill(value) { resume(\"next\", value); }\n    function reject(value) { resume(\"throw\", value); }\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n}\n\nexport function __asyncDelegator(o) {\n    var i, p;\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\n}\n\nexport function __asyncValues(o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n}\n\nexport function __makeTemplateObject(cooked, raw) {\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\n    return cooked;\n};\n\nvar __setModuleDefault = Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n};\n\nexport function __importStar(mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n}\n\nexport function __importDefault(mod) {\n    return (mod && mod.__esModule) ? mod : { default: mod };\n}\n\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n}\n\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n}\n\nexport function __classPrivateFieldIn(state, receiver) {\n    if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\n    return typeof state === \"function\" ? receiver === state : state.has(receiver);\n}\n", "import { BuildArray } from \"../Misc/arrayTools\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\nimport type { DeepImmutable, FloatArray, Tuple } from \"../types\";\r\nimport { Epsilon, ToGammaSpace, ToLinearSpace } from \"./math.constants\";\r\nimport type { IColor3Like, IColor4Like } from \"./math.like\";\r\nimport { Clamp, ToHex, WithinEpsilon } from \"./math.scalar.functions\";\r\nimport type { Tensor } from \"./tensor\";\r\n\r\nfunction colorChannelToLinearSpace(color: number): number {\r\n    return Math.pow(color, ToLinearSpace);\r\n}\r\n\r\nfunction colorChannelToLinearSpaceExact(color: number): number {\r\n    if (color <= 0.04045) {\r\n        return 0.0773993808 * color;\r\n    }\r\n    return Math.pow(0.947867299 * (color + 0.055), 2.4);\r\n}\r\n\r\nfunction colorChannelToGammaSpace(color: number): number {\r\n    return Math.pow(color, ToGammaSpace);\r\n}\r\n\r\nfunction colorChannelToGammaSpaceExact(color: number): number {\r\n    if (color <= 0.0031308) {\r\n        return 12.92 * color;\r\n    }\r\n    return 1.055 * Math.pow(color, 0.41666) - 0.055;\r\n}\r\n\r\n/**\r\n * Class used to hold a RGB color\r\n */\r\nexport class Color3 implements Tensor<Tuple<number, 3>, IColor3Like>, IColor3Like {\r\n    /**\r\n     * @see Tensor.dimension\r\n     */\r\n    public declare readonly dimension: [3];\r\n\r\n    /**\r\n     * @see Tensor.rank\r\n     */\r\n    public declare readonly rank: 1;\r\n\r\n    /**\r\n     * Creates a new Color3 object from red, green, blue values, all between 0 and 1\r\n     * @param r defines the red component (between 0 and 1, default is 0)\r\n     * @param g defines the green component (between 0 and 1, default is 0)\r\n     * @param b defines the blue component (between 0 and 1, default is 0)\r\n     */\r\n    constructor(\r\n        /**\r\n         * [0] Defines the red component (between 0 and 1, default is 0)\r\n         */\r\n        public r: number = 0,\r\n        /**\r\n         * [0] Defines the green component (between 0 and 1, default is 0)\r\n         */\r\n        public g: number = 0,\r\n        /**\r\n         * [0] Defines the blue component (between 0 and 1, default is 0)\r\n         */\r\n        public b: number = 0\r\n    ) {}\r\n\r\n    /**\r\n     * Creates a string with the Color3 current values\r\n     * @returns the string representation of the Color3 object\r\n     */\r\n    public toString(): string {\r\n        return \"{R: \" + this.r + \" G:\" + this.g + \" B:\" + this.b + \"}\";\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"Color3\"\r\n     * @returns \"Color3\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"Color3\";\r\n    }\r\n\r\n    /**\r\n     * Compute the Color3 hash code\r\n     * @returns an unique number that can be used to hash Color3 objects\r\n     */\r\n    public getHashCode(): number {\r\n        let hash = (this.r * 255) | 0;\r\n        hash = (hash * 397) ^ ((this.g * 255) | 0);\r\n        hash = (hash * 397) ^ ((this.b * 255) | 0);\r\n        return hash;\r\n    }\r\n\r\n    // Operators\r\n\r\n    /**\r\n     * Stores in the given array from the given starting index the red, green, blue values as successive elements\r\n     * @param array defines the array where to store the r,g,b components\r\n     * @param index defines an optional index in the target array to define where to start storing values\r\n     * @returns the current Color3 object\r\n     */\r\n    public toArray(array: FloatArray, index: number = 0): this {\r\n        array[index] = this.r;\r\n        array[index + 1] = this.g;\r\n        array[index + 2] = this.b;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Update the current color with values stored in an array from the starting index of the given array\r\n     * @param array defines the source array\r\n     * @param offset defines an offset in the source array\r\n     * @returns the current Color3 object\r\n     */\r\n    public fromArray(array: DeepImmutable<ArrayLike<number>>, offset: number = 0): this {\r\n        Color3.FromArrayToRef(array, offset, this);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns a new Color4 object from the current Color3 and the given alpha\r\n     * @param alpha defines the alpha component on the new Color4 object (default is 1)\r\n     * @returns a new Color4 object\r\n     */\r\n    public toColor4(alpha: number = 1): Color4 {\r\n        return new Color4(this.r, this.g, this.b, alpha);\r\n    }\r\n\r\n    /**\r\n     * Returns a new array populated with 3 numeric elements : red, green and blue values\r\n     * @returns the new array\r\n     */\r\n    public asArray(): Tuple<number, 3> {\r\n        return [this.r, this.g, this.b];\r\n    }\r\n\r\n    /**\r\n     * Returns the luminance value\r\n     * @returns a float value\r\n     */\r\n    public toLuminance(): number {\r\n        return this.r * 0.3 + this.g * 0.59 + this.b * 0.11;\r\n    }\r\n\r\n    /**\r\n     * Multiply each Color3 rgb values by the given Color3 rgb values in a new Color3 object\r\n     * @param otherColor defines the second operand\r\n     * @returns the new Color3 object\r\n     */\r\n    public multiply(otherColor: DeepImmutable<IColor3Like>): Color3 {\r\n        return new Color3(this.r * otherColor.r, this.g * otherColor.g, this.b * otherColor.b);\r\n    }\r\n\r\n    /**\r\n     * Multiply the rgb values of the Color3 and the given Color3 and stores the result in the object \"result\"\r\n     * @param otherColor defines the second operand\r\n     * @param result defines the Color3 object where to store the result\r\n     * @returns the result Color3\r\n     */\r\n    public multiplyToRef<T extends IColor3Like>(otherColor: DeepImmutable<IColor3Like>, result: T): T {\r\n        result.r = this.r * otherColor.r;\r\n        result.g = this.g * otherColor.g;\r\n        result.b = this.b * otherColor.b;\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Multiplies the current Color3 coordinates by the given ones\r\n     * @param otherColor defines the second operand\r\n     * @returns the current updated Color3\r\n     */\r\n    public multiplyInPlace(otherColor: DeepImmutable<IColor3Like>): this {\r\n        this.r *= otherColor.r;\r\n        this.g *= otherColor.g;\r\n        this.b *= otherColor.b;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns a new Color3 set with the result of the multiplication of the current Color3 coordinates by the given floats\r\n     * @param r defines the r coordinate of the operand\r\n     * @param g defines the g coordinate of the operand\r\n     * @param b defines the b coordinate of the operand\r\n     * @returns the new Color3\r\n     */\r\n    public multiplyByFloats(r: number, g: number, b: number): Color3 {\r\n        return new Color3(this.r * r, this.g * g, this.b * b);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * Do not use\r\n     */\r\n    public divide(_other: DeepImmutable<IColor3Like>): never {\r\n        throw new ReferenceError(\"Can not divide a color\");\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * Do not use\r\n     */\r\n    public divideToRef(_other: DeepImmutable<IColor3Like>, _result: IColor3Like): never {\r\n        throw new ReferenceError(\"Can not divide a color\");\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * Do not use\r\n     */\r\n    public divideInPlace(_other: DeepImmutable<IColor3Like>): never {\r\n        throw new ReferenceError(\"Can not divide a color\");\r\n    }\r\n\r\n    /**\r\n     * Updates the current Color3 with the minimal coordinate values between its and the given color ones\r\n     * @param other defines the second operand\r\n     * @returns the current updated Color3\r\n     */\r\n    public minimizeInPlace(other: DeepImmutable<IColor3Like>): this {\r\n        return this.minimizeInPlaceFromFloats(other.r, other.g, other.b);\r\n    }\r\n\r\n    /**\r\n     * Updates the current Color3 with the maximal coordinate values between its and the given color ones.\r\n     * @param other defines the second operand\r\n     * @returns the current updated Color3\r\n     */\r\n    public maximizeInPlace(other: DeepImmutable<IColor3Like>): this {\r\n        return this.maximizeInPlaceFromFloats(other.r, other.g, other.b);\r\n    }\r\n\r\n    /**\r\n     * Updates the current Color3 with the minimal coordinate values between its and the given coordinates\r\n     * @param r defines the r coordinate of the operand\r\n     * @param g defines the g coordinate of the operand\r\n     * @param b defines the b coordinate of the operand\r\n     * @returns the current updated Color3\r\n     */\r\n    public minimizeInPlaceFromFloats(r: number, g: number, b: number): this {\r\n        this.r = Math.min(r, this.r);\r\n        this.g = Math.min(g, this.g);\r\n        this.b = Math.min(b, this.b);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Updates the current Color3 with the maximal coordinate values between its and the given coordinates.\r\n     * @param r defines the r coordinate of the operand\r\n     * @param g defines the g coordinate of the operand\r\n     * @param b defines the b coordinate of the operand\r\n     * @returns the current updated Color3\r\n     */\r\n    public maximizeInPlaceFromFloats(r: number, g: number, b: number): this {\r\n        this.r = Math.max(r, this.r);\r\n        this.g = Math.max(g, this.g);\r\n        this.b = Math.max(b, this.b);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * Do not use\r\n     */\r\n    public floorToRef(_result: IColor3Like): never {\r\n        throw new ReferenceError(\"Can not floor a color\");\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * Do not use\r\n     */\r\n    public floor(): never {\r\n        throw new ReferenceError(\"Can not floor a color\");\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * Do not use\r\n     */\r\n    public fractToRef(_result: IColor3Like): never {\r\n        throw new ReferenceError(\"Can not fract a color\");\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * Do not use\r\n     */\r\n    public fract(): never {\r\n        throw new ReferenceError(\"Can not fract a color\");\r\n    }\r\n\r\n    /**\r\n     * Determines equality between Color3 objects\r\n     * @param otherColor defines the second operand\r\n     * @returns true if the rgb values are equal to the given ones\r\n     */\r\n    public equals(otherColor: DeepImmutable<IColor3Like>): boolean {\r\n        return otherColor && this.r === otherColor.r && this.g === otherColor.g && this.b === otherColor.b;\r\n    }\r\n\r\n    /**\r\n     * Alias for equalsToFloats\r\n     * @param r red color component\r\n     * @param g green color component\r\n     * @param b blue color component\r\n     * @returns boolean\r\n     */\r\n    public equalsFloats(r: number, g: number, b: number): boolean {\r\n        return this.equalsToFloats(r, g, b);\r\n    }\r\n\r\n    /**\r\n     * Determines equality between the current Color3 object and a set of r,b,g values\r\n     * @param r defines the red component to check\r\n     * @param g defines the green component to check\r\n     * @param b defines the blue component to check\r\n     * @returns true if the rgb values are equal to the given ones\r\n     */\r\n    public equalsToFloats(r: number, g: number, b: number): boolean {\r\n        return this.r === r && this.g === g && this.b === b;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the current Color3 and the given color coordinates are distant less than epsilon\r\n     * @param otherColor defines the second operand\r\n     * @param epsilon defines the minimal distance to define values as equals\r\n     * @returns true if both colors are distant less than epsilon\r\n     */\r\n    public equalsWithEpsilon(otherColor: DeepImmutable<IColor3Like>, epsilon: number = Epsilon): boolean {\r\n        return WithinEpsilon(this.r, otherColor.r, epsilon) && WithinEpsilon(this.g, otherColor.g, epsilon) && WithinEpsilon(this.b, otherColor.b, epsilon);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * Do not use\r\n     */\r\n    public negate(): never {\r\n        throw new ReferenceError(\"Can not negate a color\");\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * Do not use\r\n     */\r\n    public negateInPlace(): never {\r\n        throw new ReferenceError(\"Can not negate a color\");\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * Do not use\r\n     */\r\n    public negateToRef(_result: IColor3Like): never {\r\n        throw new ReferenceError(\"Can not negate a color\");\r\n    }\r\n\r\n    /**\r\n     * Creates a new Color3 with the current Color3 values multiplied by scale\r\n     * @param scale defines the scaling factor to apply\r\n     * @returns a new Color3 object\r\n     */\r\n    public scale(scale: number): Color3 {\r\n        return new Color3(this.r * scale, this.g * scale, this.b * scale);\r\n    }\r\n\r\n    /**\r\n     * Multiplies the Color3 values by the float \"scale\"\r\n     * @param scale defines the scaling factor to apply\r\n     * @returns the current updated Color3\r\n     */\r\n    public scaleInPlace(scale: number): this {\r\n        this.r *= scale;\r\n        this.g *= scale;\r\n        this.b *= scale;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Multiplies the rgb values by scale and stores the result into \"result\"\r\n     * @param scale defines the scaling factor\r\n     * @param result defines the Color3 object where to store the result\r\n     * @returns the result Color3\r\n     */\r\n    public scaleToRef<T extends IColor3Like>(scale: number, result: T): T {\r\n        result.r = this.r * scale;\r\n        result.g = this.g * scale;\r\n        result.b = this.b * scale;\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Scale the current Color3 values by a factor and add the result to a given Color3\r\n     * @param scale defines the scale factor\r\n     * @param result defines color to store the result into\r\n     * @returns the result Color3\r\n     */\r\n    public scaleAndAddToRef<T extends IColor3Like>(scale: number, result: T): T {\r\n        result.r += this.r * scale;\r\n        result.g += this.g * scale;\r\n        result.b += this.b * scale;\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Clamps the rgb values by the min and max values and stores the result into \"result\"\r\n     * @param min defines minimum clamping value (default is 0)\r\n     * @param max defines maximum clamping value (default is 1)\r\n     * @param result defines color to store the result into\r\n     * @returns the result Color3\r\n     */\r\n    public clampToRef<T extends IColor3Like>(min: number = 0, max: number = 1, result: T): T {\r\n        result.r = Clamp(this.r, min, max);\r\n        result.g = Clamp(this.g, min, max);\r\n        result.b = Clamp(this.b, min, max);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates a new Color3 set with the added values of the current Color3 and of the given one\r\n     * @param otherColor defines the second operand\r\n     * @returns the new Color3\r\n     */\r\n    public add(otherColor: DeepImmutable<IColor3Like>): Color3 {\r\n        return new Color3(this.r + otherColor.r, this.g + otherColor.g, this.b + otherColor.b);\r\n    }\r\n\r\n    /**\r\n     * Adds the given color to the current Color3\r\n     * @param otherColor defines the second operand\r\n     * @returns the current updated Color3\r\n     */\r\n    public addInPlace(otherColor: DeepImmutable<IColor3Like>): this {\r\n        this.r += otherColor.r;\r\n        this.g += otherColor.g;\r\n        this.b += otherColor.b;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds the given coordinates to the current Color3\r\n     * @param r defines the r coordinate of the operand\r\n     * @param g defines the g coordinate of the operand\r\n     * @param b defines the b coordinate of the operand\r\n     * @returns the current updated Color3\r\n     */\r\n    public addInPlaceFromFloats(r: number, g: number, b: number): this {\r\n        this.r += r;\r\n        this.g += g;\r\n        this.b += b;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Stores the result of the addition of the current Color3 and given one rgb values into \"result\"\r\n     * @param otherColor defines the second operand\r\n     * @param result defines Color3 object to store the result into\r\n     * @returns the unmodified current Color3\r\n     */\r\n    public addToRef<T extends IColor3Like>(otherColor: DeepImmutable<IColor3Like>, result: T): T {\r\n        result.r = this.r + otherColor.r;\r\n        result.g = this.g + otherColor.g;\r\n        result.b = this.b + otherColor.b;\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Returns a new Color3 set with the subtracted values of the given one from the current Color3\r\n     * @param otherColor defines the second operand\r\n     * @returns the new Color3\r\n     */\r\n    public subtract(otherColor: DeepImmutable<IColor3Like>): Color3 {\r\n        return new Color3(this.r - otherColor.r, this.g - otherColor.g, this.b - otherColor.b);\r\n    }\r\n\r\n    /**\r\n     * Stores the result of the subtraction of given one from the current Color3 rgb values into \"result\"\r\n     * @param otherColor defines the second operand\r\n     * @param result defines Color3 object to store the result into\r\n     * @returns the unmodified current Color3\r\n     */\r\n    public subtractToRef<T extends IColor3Like>(otherColor: DeepImmutable<IColor3Like>, result: T): T {\r\n        result.r = this.r - otherColor.r;\r\n        result.g = this.g - otherColor.g;\r\n        result.b = this.b - otherColor.b;\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Subtract the given color from the current Color3\r\n     * @param otherColor defines the second operand\r\n     * @returns the current updated Color3\r\n     */\r\n    public subtractInPlace(otherColor: DeepImmutable<IColor3Like>): this {\r\n        this.r -= otherColor.r;\r\n        this.g -= otherColor.g;\r\n        this.b -= otherColor.b;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns a new Color3 set with the subtraction of the given floats from the current Color3 coordinates\r\n     * @param r defines the r coordinate of the operand\r\n     * @param g defines the g coordinate of the operand\r\n     * @param b defines the b coordinate of the operand\r\n     * @returns the resulting Color3\r\n     */\r\n    public subtractFromFloats(r: number, g: number, b: number): Color3 {\r\n        return new Color3(this.r - r, this.g - g, this.b - b);\r\n    }\r\n\r\n    /**\r\n     * Subtracts the given floats from the current Color3 coordinates and set the given color \"result\" with this result\r\n     * @param r defines the r coordinate of the operand\r\n     * @param g defines the g coordinate of the operand\r\n     * @param b defines the b coordinate of the operand\r\n     * @param result defines the Color3 object where to store the result\r\n     * @returns the result\r\n     */\r\n    public subtractFromFloatsToRef<T extends IColor3Like>(r: number, g: number, b: number, result: T): T {\r\n        result.r = this.r - r;\r\n        result.g = this.g - g;\r\n        result.b = this.b - b;\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Copy the current object\r\n     * @returns a new Color3 copied the current one\r\n     */\r\n    public clone(): Color3 {\r\n        return new Color3(this.r, this.g, this.b);\r\n    }\r\n\r\n    /**\r\n     * Copies the rgb values from the source in the current Color3\r\n     * @param source defines the source Color3 object\r\n     * @returns the updated Color3 object\r\n     */\r\n    public copyFrom(source: DeepImmutable<IColor3Like>): this {\r\n        this.r = source.r;\r\n        this.g = source.g;\r\n        this.b = source.b;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Updates the Color3 rgb values from the given floats\r\n     * @param r defines the red component to read from\r\n     * @param g defines the green component to read from\r\n     * @param b defines the blue component to read from\r\n     * @returns the current Color3 object\r\n     */\r\n    public copyFromFloats(r: number, g: number, b: number): this {\r\n        this.r = r;\r\n        this.g = g;\r\n        this.b = b;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Updates the Color3 rgb values from the given floats\r\n     * @param r defines the red component to read from\r\n     * @param g defines the green component to read from\r\n     * @param b defines the blue component to read from\r\n     * @returns the current Color3 object\r\n     */\r\n    public set(r: number, g: number, b: number): this {\r\n        return this.copyFromFloats(r, g, b);\r\n    }\r\n\r\n    /**\r\n     * Copies the given float to the current Color3 coordinates\r\n     * @param v defines the r, g and b coordinates of the operand\r\n     * @returns the current updated Color3\r\n     */\r\n    public setAll(v: number): this {\r\n        this.r = this.g = this.b = v;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Compute the Color3 hexadecimal code as a string\r\n     * @returns a string containing the hexadecimal representation of the Color3 object\r\n     */\r\n    public toHexString(): string {\r\n        const intR = Math.round(this.r * 255);\r\n        const intG = Math.round(this.g * 255);\r\n        const intB = Math.round(this.b * 255);\r\n        return \"#\" + ToHex(intR) + ToHex(intG) + ToHex(intB);\r\n    }\r\n\r\n    /**\r\n     * Updates the Color3 rgb values from the string containing valid hexadecimal values\r\n     * @param hex defines a string containing valid hexadecimal values\r\n     * @returns the current Color3 object\r\n     */\r\n    public fromHexString(hex: string): this {\r\n        if (hex.substring(0, 1) !== \"#\" || hex.length !== 7) {\r\n            return this;\r\n        }\r\n\r\n        this.r = parseInt(hex.substring(1, 3), 16) / 255;\r\n        this.g = parseInt(hex.substring(3, 5), 16) / 255;\r\n        this.b = parseInt(hex.substring(5, 7), 16) / 255;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Converts current color in rgb space to HSV values\r\n     * @returns a new color3 representing the HSV values\r\n     */\r\n    public toHSV(): Color3 {\r\n        return this.toHSVToRef(new Color3());\r\n    }\r\n\r\n    /**\r\n     * Converts current color in rgb space to HSV values\r\n     * @param result defines the Color3 where to store the HSV values\r\n     * @returns the updated result\r\n     */\r\n    public toHSVToRef<T extends IColor3Like>(result: T): T {\r\n        const r = this.r;\r\n        const g = this.g;\r\n        const b = this.b;\r\n\r\n        const max = Math.max(r, g, b);\r\n        const min = Math.min(r, g, b);\r\n        let h = 0;\r\n        let s = 0;\r\n        const v = max;\r\n\r\n        const dm = max - min;\r\n\r\n        if (max !== 0) {\r\n            s = dm / max;\r\n        }\r\n\r\n        if (max != min) {\r\n            if (max == r) {\r\n                h = (g - b) / dm;\r\n                if (g < b) {\r\n                    h += 6;\r\n                }\r\n            } else if (max == g) {\r\n                h = (b - r) / dm + 2;\r\n            } else if (max == b) {\r\n                h = (r - g) / dm + 4;\r\n            }\r\n            h *= 60;\r\n        }\r\n\r\n        result.r = h;\r\n        result.g = s;\r\n        result.b = v;\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Computes a new Color3 converted from the current one to linear space\r\n     * @param exact defines if the conversion will be done in an exact way which is slower but more accurate (default is false)\r\n     * @returns a new Color3 object\r\n     */\r\n    public toLinearSpace(exact = false): Color3 {\r\n        const convertedColor = new Color3();\r\n        this.toLinearSpaceToRef(convertedColor, exact);\r\n        return convertedColor;\r\n    }\r\n\r\n    /**\r\n     * Converts the Color3 values to linear space and stores the result in \"convertedColor\"\r\n     * @param convertedColor defines the Color3 object where to store the linear space version\r\n     * @param exact defines if the conversion will be done in an exact way which is slower but more accurate (default is false)\r\n     * @returns the unmodified Color3\r\n     */\r\n    public toLinearSpaceToRef(convertedColor: IColor3Like, exact = false): this {\r\n        if (exact) {\r\n            convertedColor.r = colorChannelToLinearSpaceExact(this.r);\r\n            convertedColor.g = colorChannelToLinearSpaceExact(this.g);\r\n            convertedColor.b = colorChannelToLinearSpaceExact(this.b);\r\n        } else {\r\n            convertedColor.r = colorChannelToLinearSpace(this.r);\r\n            convertedColor.g = colorChannelToLinearSpace(this.g);\r\n            convertedColor.b = colorChannelToLinearSpace(this.b);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Computes a new Color3 converted from the current one to gamma space\r\n     * @param exact defines if the conversion will be done in an exact way which is slower but more accurate (default is false)\r\n     * @returns a new Color3 object\r\n     */\r\n    public toGammaSpace(exact = false): Color3 {\r\n        const convertedColor = new Color3();\r\n        this.toGammaSpaceToRef(convertedColor, exact);\r\n        return convertedColor;\r\n    }\r\n\r\n    /**\r\n     * Converts the Color3 values to gamma space and stores the result in \"convertedColor\"\r\n     * @param convertedColor defines the Color3 object where to store the gamma space version\r\n     * @param exact defines if the conversion will be done in an exact way which is slower but more accurate (default is false)\r\n     * @returns the unmodified Color3\r\n     */\r\n    public toGammaSpaceToRef(convertedColor: IColor3Like, exact = false): this {\r\n        if (exact) {\r\n            convertedColor.r = colorChannelToGammaSpaceExact(this.r);\r\n            convertedColor.g = colorChannelToGammaSpaceExact(this.g);\r\n            convertedColor.b = colorChannelToGammaSpaceExact(this.b);\r\n        } else {\r\n            convertedColor.r = colorChannelToGammaSpace(this.r);\r\n            convertedColor.g = colorChannelToGammaSpace(this.g);\r\n            convertedColor.b = colorChannelToGammaSpace(this.b);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    // Statics\r\n\r\n    private static _BlackReadOnly = Color3.Black() as DeepImmutable<Color3>;\r\n\r\n    /**\r\n     * Converts Hue, saturation and value to a Color3 (RGB)\r\n     * @param hue defines the hue (value between 0 and 360)\r\n     * @param saturation defines the saturation (value between 0 and 1)\r\n     * @param value defines the value (value between 0 and 1)\r\n     * @param result defines the Color3 where to store the RGB values\r\n     * @returns the updated result\r\n     */\r\n    public static HSVtoRGBToRef<T extends IColor3Like>(hue: number, saturation: number, value: number, result: T): T {\r\n        const chroma = value * saturation;\r\n        const h = hue / 60;\r\n        const x = chroma * (1 - Math.abs((h % 2) - 1));\r\n        let r = 0;\r\n        let g = 0;\r\n        let b = 0;\r\n\r\n        if (h >= 0 && h <= 1) {\r\n            r = chroma;\r\n            g = x;\r\n        } else if (h >= 1 && h <= 2) {\r\n            r = x;\r\n            g = chroma;\r\n        } else if (h >= 2 && h <= 3) {\r\n            g = chroma;\r\n            b = x;\r\n        } else if (h >= 3 && h <= 4) {\r\n            g = x;\r\n            b = chroma;\r\n        } else if (h >= 4 && h <= 5) {\r\n            r = x;\r\n            b = chroma;\r\n        } else if (h >= 5 && h <= 6) {\r\n            r = chroma;\r\n            b = x;\r\n        }\r\n\r\n        const m = value - chroma;\r\n        result.r = r + m;\r\n        result.g = g + m;\r\n        result.b = b + m;\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Converts Hue, saturation and value to a new Color3 (RGB)\r\n     * @param hue defines the hue (value between 0 and 360)\r\n     * @param saturation defines the saturation (value between 0 and 1)\r\n     * @param value defines the value (value between 0 and 1)\r\n     * @returns a new Color3 object\r\n     */\r\n    public static FromHSV(hue: number, saturation: number, value: number): Color3 {\r\n        const result = new Color3(0, 0, 0);\r\n        Color3.HSVtoRGBToRef(hue, saturation, value, result);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates a new Color3 from the string containing valid hexadecimal values\r\n     * @param hex defines a string containing valid hexadecimal values\r\n     * @returns a new Color3 object\r\n     */\r\n    public static FromHexString(hex: string): Color3 {\r\n        return new Color3(0, 0, 0).fromHexString(hex);\r\n    }\r\n\r\n    /**\r\n     * Creates a new Color3 from the starting index of the given array\r\n     * @param array defines the source array\r\n     * @param offset defines an offset in the source array\r\n     * @returns a new Color3 object\r\n     */\r\n    public static FromArray(array: DeepImmutable<ArrayLike<number>>, offset: number = 0): Color3 {\r\n        return new Color3(array[offset], array[offset + 1], array[offset + 2]);\r\n    }\r\n\r\n    /**\r\n     * Creates a new Color3 from the starting index element of the given array\r\n     * @param array defines the source array to read from\r\n     * @param offset defines the offset in the source array\r\n     * @param result defines the target Color3 object\r\n     */\r\n    public static FromArrayToRef(array: DeepImmutable<ArrayLike<number>>, offset: number = 0, result: Color3) {\r\n        result.r = array[offset];\r\n        result.g = array[offset + 1];\r\n        result.b = array[offset + 2];\r\n    }\r\n\r\n    /**\r\n     * Creates a new Color3 from integer values (\\< 256)\r\n     * @param r defines the red component to read from (value between 0 and 255)\r\n     * @param g defines the green component to read from (value between 0 and 255)\r\n     * @param b defines the blue component to read from (value between 0 and 255)\r\n     * @returns a new Color3 object\r\n     */\r\n    public static FromInts(r: number, g: number, b: number): Color3 {\r\n        return new Color3(r / 255.0, g / 255.0, b / 255.0);\r\n    }\r\n\r\n    /**\r\n     * Creates a new Color3 with values linearly interpolated of \"amount\" between the start Color3 and the end Color3\r\n     * @param start defines the start Color3 value\r\n     * @param end defines the end Color3 value\r\n     * @param amount defines the gradient value between start and end\r\n     * @returns a new Color3 object\r\n     */\r\n    public static Lerp(start: DeepImmutable<Color3>, end: DeepImmutable<Color3>, amount: number): Color3 {\r\n        const result = new Color3(0.0, 0.0, 0.0);\r\n        Color3.LerpToRef(start, end, amount, result);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates a new Color3 with values linearly interpolated of \"amount\" between the start Color3 and the end Color3\r\n     * @param left defines the start value\r\n     * @param right defines the end value\r\n     * @param amount defines the gradient factor\r\n     * @param result defines the Color3 object where to store the result\r\n     */\r\n    public static LerpToRef(left: DeepImmutable<Color3>, right: DeepImmutable<Color3>, amount: number, result: Color3): void {\r\n        result.r = left.r + (right.r - left.r) * amount;\r\n        result.g = left.g + (right.g - left.g) * amount;\r\n        result.b = left.b + (right.b - left.b) * amount;\r\n    }\r\n\r\n    /**\r\n     * Returns a new Color3 located for \"amount\" (float) on the Hermite interpolation spline defined by the vectors \"value1\", \"tangent1\", \"value2\", \"tangent2\"\r\n     * @param value1 defines the first control point\r\n     * @param tangent1 defines the first tangent Color3\r\n     * @param value2 defines the second control point\r\n     * @param tangent2 defines the second tangent Color3\r\n     * @param amount defines the amount on the interpolation spline (between 0 and 1)\r\n     * @returns the new Color3\r\n     */\r\n    public static Hermite(value1: DeepImmutable<Color3>, tangent1: DeepImmutable<Color3>, value2: DeepImmutable<Color3>, tangent2: DeepImmutable<Color3>, amount: number): Color3 {\r\n        const squared = amount * amount;\r\n        const cubed = amount * squared;\r\n        const part1 = 2.0 * cubed - 3.0 * squared + 1.0;\r\n        const part2 = -2.0 * cubed + 3.0 * squared;\r\n        const part3 = cubed - 2.0 * squared + amount;\r\n        const part4 = cubed - squared;\r\n\r\n        const r = value1.r * part1 + value2.r * part2 + tangent1.r * part3 + tangent2.r * part4;\r\n        const g = value1.g * part1 + value2.g * part2 + tangent1.g * part3 + tangent2.g * part4;\r\n        const b = value1.b * part1 + value2.b * part2 + tangent1.b * part3 + tangent2.b * part4;\r\n        return new Color3(r, g, b);\r\n    }\r\n\r\n    /**\r\n     * Returns a new Color3 which is the 1st derivative of the Hermite spline defined by the colors \"value1\", \"value2\", \"tangent1\", \"tangent2\".\r\n     * @param value1 defines the first control point\r\n     * @param tangent1 defines the first tangent\r\n     * @param value2 defines the second control point\r\n     * @param tangent2 defines the second tangent\r\n     * @param time define where the derivative must be done\r\n     * @returns 1st derivative\r\n     */\r\n    public static Hermite1stDerivative(\r\n        value1: DeepImmutable<Color3>,\r\n        tangent1: DeepImmutable<Color3>,\r\n        value2: DeepImmutable<Color3>,\r\n        tangent2: DeepImmutable<Color3>,\r\n        time: number\r\n    ): Color3 {\r\n        const result = Color3.Black();\r\n\r\n        this.Hermite1stDerivativeToRef(value1, tangent1, value2, tangent2, time, result);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Returns a new Color3 which is the 1st derivative of the Hermite spline defined by the colors \"value1\", \"value2\", \"tangent1\", \"tangent2\".\r\n     * @param value1 defines the first control point\r\n     * @param tangent1 defines the first tangent\r\n     * @param value2 defines the second control point\r\n     * @param tangent2 defines the second tangent\r\n     * @param time define where the derivative must be done\r\n     * @param result define where to store the derivative\r\n     */\r\n    public static Hermite1stDerivativeToRef(\r\n        value1: DeepImmutable<Color3>,\r\n        tangent1: DeepImmutable<Color3>,\r\n        value2: DeepImmutable<Color3>,\r\n        tangent2: DeepImmutable<Color3>,\r\n        time: number,\r\n        result: Color3\r\n    ) {\r\n        const t2 = time * time;\r\n\r\n        result.r = (t2 - time) * 6 * value1.r + (3 * t2 - 4 * time + 1) * tangent1.r + (-t2 + time) * 6 * value2.r + (3 * t2 - 2 * time) * tangent2.r;\r\n        result.g = (t2 - time) * 6 * value1.g + (3 * t2 - 4 * time + 1) * tangent1.g + (-t2 + time) * 6 * value2.g + (3 * t2 - 2 * time) * tangent2.g;\r\n        result.b = (t2 - time) * 6 * value1.b + (3 * t2 - 4 * time + 1) * tangent1.b + (-t2 + time) * 6 * value2.b + (3 * t2 - 2 * time) * tangent2.b;\r\n    }\r\n\r\n    /**\r\n     * Returns a Color3 value containing a red color\r\n     * @returns a new Color3 object\r\n     */\r\n    public static Red(): Color3 {\r\n        return new Color3(1, 0, 0);\r\n    }\r\n    /**\r\n     * Returns a Color3 value containing a green color\r\n     * @returns a new Color3 object\r\n     */\r\n    public static Green(): Color3 {\r\n        return new Color3(0, 1, 0);\r\n    }\r\n    /**\r\n     * Returns a Color3 value containing a blue color\r\n     * @returns a new Color3 object\r\n     */\r\n    public static Blue(): Color3 {\r\n        return new Color3(0, 0, 1);\r\n    }\r\n    /**\r\n     * Returns a Color3 value containing a black color\r\n     * @returns a new Color3 object\r\n     */\r\n    public static Black(): Color3 {\r\n        return new Color3(0, 0, 0);\r\n    }\r\n\r\n    /**\r\n     * Gets a Color3 value containing a black color that must not be updated\r\n     */\r\n    public static get BlackReadOnly(): DeepImmutable<Color3> {\r\n        return Color3._BlackReadOnly;\r\n    }\r\n\r\n    /**\r\n     * Returns a Color3 value containing a white color\r\n     * @returns a new Color3 object\r\n     */\r\n    public static White(): Color3 {\r\n        return new Color3(1, 1, 1);\r\n    }\r\n    /**\r\n     * Returns a Color3 value containing a purple color\r\n     * @returns a new Color3 object\r\n     */\r\n    public static Purple(): Color3 {\r\n        return new Color3(0.5, 0, 0.5);\r\n    }\r\n    /**\r\n     * Returns a Color3 value containing a magenta color\r\n     * @returns a new Color3 object\r\n     */\r\n    public static Magenta(): Color3 {\r\n        return new Color3(1, 0, 1);\r\n    }\r\n    /**\r\n     * Returns a Color3 value containing a yellow color\r\n     * @returns a new Color3 object\r\n     */\r\n    public static Yellow(): Color3 {\r\n        return new Color3(1, 1, 0);\r\n    }\r\n    /**\r\n     * Returns a Color3 value containing a gray color\r\n     * @returns a new Color3 object\r\n     */\r\n    public static Gray(): Color3 {\r\n        return new Color3(0.5, 0.5, 0.5);\r\n    }\r\n    /**\r\n     * Returns a Color3 value containing a teal color\r\n     * @returns a new Color3 object\r\n     */\r\n    public static Teal(): Color3 {\r\n        return new Color3(0, 1.0, 1.0);\r\n    }\r\n    /**\r\n     * Returns a Color3 value containing a random color\r\n     * @returns a new Color3 object\r\n     */\r\n    public static Random(): Color3 {\r\n        return new Color3(Math.random(), Math.random(), Math.random());\r\n    }\r\n}\r\nObject.defineProperties(Color3.prototype, {\r\n    dimension: { value: [3] },\r\n    rank: { value: 1 },\r\n});\r\n\r\n/**\r\n * Class used to hold a RBGA color\r\n */\r\nexport class Color4 implements Tensor<Tuple<number, 4>, IColor4Like>, IColor4Like {\r\n    /**\r\n     * @see Tensor.dimension\r\n     */\r\n    public declare readonly dimension: [4];\r\n\r\n    /**\r\n     * @see Tensor.rank\r\n     */\r\n    public declare readonly rank: 1;\r\n\r\n    /**\r\n     * Creates a new Color4 object from red, green, blue values, all between 0 and 1\r\n     * @param r defines the red component (between 0 and 1, default is 0)\r\n     * @param g defines the green component (between 0 and 1, default is 0)\r\n     * @param b defines the blue component (between 0 and 1, default is 0)\r\n     * @param a defines the alpha component (between 0 and 1, default is 1)\r\n     */\r\n    constructor(\r\n        /**\r\n         * [0] Defines the red component (between 0 and 1, default is 0)\r\n         */\r\n        public r: number = 0,\r\n        /**\r\n         * [0] Defines the green component (between 0 and 1, default is 0)\r\n         */\r\n        public g: number = 0,\r\n        /**\r\n         * [0] Defines the blue component (between 0 and 1, default is 0)\r\n         */\r\n        public b: number = 0,\r\n        /**\r\n         * [1] Defines the alpha component (between 0 and 1, default is 1)\r\n         */\r\n        public a: number = 1\r\n    ) {}\r\n\r\n    // Operators\r\n\r\n    /**\r\n     * Creates a new array populated with 4 numeric elements : red, green, blue, alpha values\r\n     * @returns the new array\r\n     */\r\n    public asArray(): Tuple<number, 4> {\r\n        return [this.r, this.g, this.b, this.a];\r\n    }\r\n\r\n    /**\r\n     * Stores from the starting index in the given array the Color4 successive values\r\n     * @param array defines the array where to store the r,g,b components\r\n     * @param index defines an optional index in the target array to define where to start storing values\r\n     * @returns the current Color4 object\r\n     */\r\n    public toArray(array: FloatArray, index: number = 0): this {\r\n        array[index] = this.r;\r\n        array[index + 1] = this.g;\r\n        array[index + 2] = this.b;\r\n        array[index + 3] = this.a;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Update the current color with values stored in an array from the starting index of the given array\r\n     * @param array defines the source array\r\n     * @param offset defines an offset in the source array\r\n     * @returns the current Color4 object\r\n     */\r\n    public fromArray(array: DeepImmutable<ArrayLike<number>>, offset: number = 0): this {\r\n        this.r = array[offset];\r\n        this.g = array[offset + 1];\r\n        this.b = array[offset + 2];\r\n        this.a = array[offset + 3];\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Determines equality between Color4 objects\r\n     * @param otherColor defines the second operand\r\n     * @returns true if the rgba values are equal to the given ones\r\n     */\r\n    public equals(otherColor: DeepImmutable<IColor4Like>): boolean {\r\n        return otherColor && this.r === otherColor.r && this.g === otherColor.g && this.b === otherColor.b && this.a === otherColor.a;\r\n    }\r\n\r\n    /**\r\n     * Creates a new Color4 set with the added values of the current Color4 and of the given one\r\n     * @param otherColor defines the second operand\r\n     * @returns a new Color4 object\r\n     */\r\n    public add(otherColor: DeepImmutable<IColor4Like>): Color4 {\r\n        return new Color4(this.r + otherColor.r, this.g + otherColor.g, this.b + otherColor.b, this.a + otherColor.a);\r\n    }\r\n\r\n    /**\r\n     * Updates the given color \"result\" with the result of the addition of the current Color4 and the given one.\r\n     * @param otherColor the color to add\r\n     * @param result the color to store the result\r\n     * @returns result input\r\n     */\r\n    public addToRef<T extends IColor4Like>(otherColor: DeepImmutable<IColor4Like>, result: T): T {\r\n        result.r = this.r + otherColor.r;\r\n        result.g = this.g + otherColor.g;\r\n        result.b = this.b + otherColor.b;\r\n        result.a = this.a + otherColor.a;\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Adds in place the given Color4 values to the current Color4 object\r\n     * @param otherColor defines the second operand\r\n     * @returns the current updated Color4 object\r\n     */\r\n    public addInPlace(otherColor: DeepImmutable<IColor4Like>): this {\r\n        this.r += otherColor.r;\r\n        this.g += otherColor.g;\r\n        this.b += otherColor.b;\r\n        this.a += otherColor.a;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds the given coordinates to the current Color4\r\n     * @param r defines the r coordinate of the operand\r\n     * @param g defines the g coordinate of the operand\r\n     * @param b defines the b coordinate of the operand\r\n     * @param a defines the a coordinate of the operand\r\n     * @returns the current updated Color4\r\n     */\r\n    public addInPlaceFromFloats(r: number, g: number, b: number, a: number): this {\r\n        this.r += r;\r\n        this.g += g;\r\n        this.b += b;\r\n        this.a += a;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Creates a new Color4 set with the subtracted values of the given one from the current Color4\r\n     * @param otherColor defines the second operand\r\n     * @returns a new Color4 object\r\n     */\r\n    public subtract(otherColor: DeepImmutable<IColor4Like>): Color4 {\r\n        return new Color4(this.r - otherColor.r, this.g - otherColor.g, this.b - otherColor.b, this.a - otherColor.a);\r\n    }\r\n\r\n    /**\r\n     * Subtracts the given ones from the current Color4 values and stores the results in \"result\"\r\n     * @param otherColor defines the second operand\r\n     * @param result defines the Color4 object where to store the result\r\n     * @returns the result Color4 object\r\n     */\r\n    public subtractToRef<T extends IColor4Like>(otherColor: DeepImmutable<IColor4Like>, result: T): T {\r\n        result.r = this.r - otherColor.r;\r\n        result.g = this.g - otherColor.g;\r\n        result.b = this.b - otherColor.b;\r\n        result.a = this.a - otherColor.a;\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Subtract in place the given color from the current Color4.\r\n     * @param otherColor the color to subtract\r\n     * @returns the updated Color4.\r\n     */\r\n    public subtractInPlace(otherColor: DeepImmutable<IColor4Like>): this {\r\n        this.r -= otherColor.r;\r\n        this.g -= otherColor.g;\r\n        this.b -= otherColor.b;\r\n        this.a -= otherColor.a;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns a new Color4 set with the result of the subtraction of the given floats from the current Color4 coordinates.\r\n     * @param r value to subtract\r\n     * @param g value to subtract\r\n     * @param b value to subtract\r\n     * @param a value to subtract\r\n     * @returns new color containing the result\r\n     */\r\n    public subtractFromFloats(r: number, g: number, b: number, a: number): Color4 {\r\n        return new Color4(this.r - r, this.g - g, this.b - b, this.a - a);\r\n    }\r\n\r\n    /**\r\n     * Sets the given color \"result\" set with the result of the subtraction of the given floats from the current Color4 coordinates.\r\n     * @param r value to subtract\r\n     * @param g value to subtract\r\n     * @param b value to subtract\r\n     * @param a value to subtract\r\n     * @param result the color to store the result in\r\n     * @returns result input\r\n     */\r\n    public subtractFromFloatsToRef<T extends IColor4Like>(r: number, g: number, b: number, a: number, result: T): T {\r\n        result.r = this.r - r;\r\n        result.g = this.g - g;\r\n        result.b = this.b - b;\r\n        result.a = this.a - a;\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates a new Color4 with the current Color4 values multiplied by scale\r\n     * @param scale defines the scaling factor to apply\r\n     * @returns a new Color4 object\r\n     */\r\n    public scale(scale: number): Color4 {\r\n        return new Color4(this.r * scale, this.g * scale, this.b * scale, this.a * scale);\r\n    }\r\n\r\n    /**\r\n     * Multiplies the Color4 values by the float \"scale\"\r\n     * @param scale defines the scaling factor to apply\r\n     * @returns the current updated Color4\r\n     */\r\n    public scaleInPlace(scale: number): this {\r\n        this.r *= scale;\r\n        this.g *= scale;\r\n        this.b *= scale;\r\n        this.a *= scale;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Multiplies the current Color4 values by scale and stores the result in \"result\"\r\n     * @param scale defines the scaling factor to apply\r\n     * @param result defines the Color4 object where to store the result\r\n     * @returns the result Color4\r\n     */\r\n    public scaleToRef<T extends IColor4Like>(scale: number, result: T): T {\r\n        result.r = this.r * scale;\r\n        result.g = this.g * scale;\r\n        result.b = this.b * scale;\r\n        result.a = this.a * scale;\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Scale the current Color4 values by a factor and add the result to a given Color4\r\n     * @param scale defines the scale factor\r\n     * @param result defines the Color4 object where to store the result\r\n     * @returns the result Color4\r\n     */\r\n    public scaleAndAddToRef<T extends IColor4Like>(scale: number, result: T): T {\r\n        result.r += this.r * scale;\r\n        result.g += this.g * scale;\r\n        result.b += this.b * scale;\r\n        result.a += this.a * scale;\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Clamps the rgb values by the min and max values and stores the result into \"result\"\r\n     * @param min defines minimum clamping value (default is 0)\r\n     * @param max defines maximum clamping value (default is 1)\r\n     * @param result defines color to store the result into.\r\n     * @returns the result Color4\r\n     */\r\n    public clampToRef<T extends IColor4Like>(min: number = 0, max: number = 1, result: T): T {\r\n        result.r = Clamp(this.r, min, max);\r\n        result.g = Clamp(this.g, min, max);\r\n        result.b = Clamp(this.b, min, max);\r\n        result.a = Clamp(this.a, min, max);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Multiply an Color4 value by another and return a new Color4 object\r\n     * @param color defines the Color4 value to multiply by\r\n     * @returns a new Color4 object\r\n     */\r\n    public multiply(color: DeepImmutable<IColor4Like>): Color4 {\r\n        return new Color4(this.r * color.r, this.g * color.g, this.b * color.b, this.a * color.a);\r\n    }\r\n\r\n    /**\r\n     * Multiply a Color4 value by another and push the result in a reference value\r\n     * @param color defines the Color4 value to multiply by\r\n     * @param result defines the Color4 to fill the result in\r\n     * @returns the result Color4\r\n     */\r\n    public multiplyToRef<T extends IColor4Like>(color: DeepImmutable<IColor4Like>, result: T): T {\r\n        result.r = this.r * color.r;\r\n        result.g = this.g * color.g;\r\n        result.b = this.b * color.b;\r\n        result.a = this.a * color.a;\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Multiplies in place the current Color4 by the given one.\r\n     * @param otherColor color to multiple with\r\n     * @returns the updated Color4.\r\n     */\r\n    public multiplyInPlace(otherColor: DeepImmutable<IColor4Like>): this {\r\n        this.r *= otherColor.r;\r\n        this.g *= otherColor.g;\r\n        this.b *= otherColor.b;\r\n        this.a *= otherColor.a;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns a new Color4 set with the multiplication result of the given floats and the current Color4 coordinates.\r\n     * @param r value multiply with\r\n     * @param g value multiply with\r\n     * @param b value multiply with\r\n     * @param a value multiply with\r\n     * @returns resulting new color\r\n     */\r\n    public multiplyByFloats(r: number, g: number, b: number, a: number): Color4 {\r\n        return new Color4(this.r * r, this.g * g, this.b * b, this.a * a);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * Do not use\r\n     */\r\n    public divide(_other: DeepImmutable<IColor4Like>): never {\r\n        throw new ReferenceError(\"Can not divide a color\");\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * Do not use\r\n     */\r\n    public divideToRef(_other: DeepImmutable<IColor4Like>, _result: IColor4Like): never {\r\n        throw new ReferenceError(\"Can not divide a color\");\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * Do not use\r\n     */\r\n    public divideInPlace(_other: DeepImmutable<IColor4Like>): never {\r\n        throw new ReferenceError(\"Can not divide a color\");\r\n    }\r\n\r\n    /**\r\n     * Updates the Color4 coordinates with the minimum values between its own and the given color ones\r\n     * @param other defines the second operand\r\n     * @returns the current updated Color4\r\n     */\r\n    public minimizeInPlace(other: DeepImmutable<IColor4Like>): this {\r\n        this.r = Math.min(this.r, other.r);\r\n        this.g = Math.min(this.g, other.g);\r\n        this.b = Math.min(this.b, other.b);\r\n        this.a = Math.min(this.a, other.a);\r\n        return this;\r\n    }\r\n    /**\r\n     * Updates the Color4 coordinates with the maximum values between its own and the given color ones\r\n     * @param other defines the second operand\r\n     * @returns the current updated Color4\r\n     */\r\n    public maximizeInPlace(other: DeepImmutable<IColor4Like>): this {\r\n        this.r = Math.max(this.r, other.r);\r\n        this.g = Math.max(this.g, other.g);\r\n        this.b = Math.max(this.b, other.b);\r\n        this.a = Math.max(this.a, other.a);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Updates the current Color4 with the minimal coordinate values between its and the given coordinates\r\n     * @param r defines the r coordinate of the operand\r\n     * @param g defines the g coordinate of the operand\r\n     * @param b defines the b coordinate of the operand\r\n     * @param a defines the a coordinate of the operand\r\n     * @returns the current updated Color4\r\n     */\r\n    public minimizeInPlaceFromFloats(r: number, g: number, b: number, a: number): this {\r\n        this.r = Math.min(r, this.r);\r\n        this.g = Math.min(g, this.g);\r\n        this.b = Math.min(b, this.b);\r\n        this.a = Math.min(a, this.a);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Updates the current Color4 with the maximal coordinate values between its and the given coordinates.\r\n     * @param r defines the r coordinate of the operand\r\n     * @param g defines the g coordinate of the operand\r\n     * @param b defines the b coordinate of the operand\r\n     * @param a defines the a coordinate of the operand\r\n     * @returns the current updated Color4\r\n     */\r\n    public maximizeInPlaceFromFloats(r: number, g: number, b: number, a: number): this {\r\n        this.r = Math.max(r, this.r);\r\n        this.g = Math.max(g, this.g);\r\n        this.b = Math.max(b, this.b);\r\n        this.a = Math.max(a, this.a);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * Do not use\r\n     */\r\n    public floorToRef(_result: IColor4Like): never {\r\n        throw new ReferenceError(\"Can not floor a color\");\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * Do not use\r\n     */\r\n    public floor(): never {\r\n        throw new ReferenceError(\"Can not floor a color\");\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * Do not use\r\n     */\r\n    public fractToRef(_result: IColor4Like): never {\r\n        throw new ReferenceError(\"Can not fract a color\");\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * Do not use\r\n     */\r\n    public fract(): never {\r\n        throw new ReferenceError(\"Can not fract a color\");\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * Do not use\r\n     */\r\n    public negate(): never {\r\n        throw new ReferenceError(\"Can not negate a color\");\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * Do not use\r\n     */\r\n    public negateInPlace(): never {\r\n        throw new ReferenceError(\"Can not negate a color\");\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * Do not use\r\n     */\r\n    public negateToRef(_result: IColor4Like): never {\r\n        throw new ReferenceError(\"Can not negate a color\");\r\n    }\r\n\r\n    /**\r\n     * Boolean : True if the current Color4 coordinates are each beneath the distance \"epsilon\" from the given color ones.\r\n     * @param otherColor color to compare against\r\n     * @param epsilon (Default: very small number)\r\n     * @returns true if they are equal\r\n     */\r\n    public equalsWithEpsilon(otherColor: DeepImmutable<IColor4Like>, epsilon: number = Epsilon): boolean {\r\n        return (\r\n            WithinEpsilon(this.r, otherColor.r, epsilon) &&\r\n            WithinEpsilon(this.g, otherColor.g, epsilon) &&\r\n            WithinEpsilon(this.b, otherColor.b, epsilon) &&\r\n            WithinEpsilon(this.a, otherColor.a, epsilon)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Boolean : True if the given floats are strictly equal to the current Color4 coordinates.\r\n     * @param x x value to compare against\r\n     * @param y y value to compare against\r\n     * @param z z value to compare against\r\n     * @param w w value to compare against\r\n     * @returns true if equal\r\n     */\r\n    public equalsToFloats(x: number, y: number, z: number, w: number): boolean {\r\n        return this.r === x && this.g === y && this.b === z && this.a === w;\r\n    }\r\n\r\n    /**\r\n     * Creates a string with the Color4 current values\r\n     * @returns the string representation of the Color4 object\r\n     */\r\n    public toString(): string {\r\n        return \"{R: \" + this.r + \" G:\" + this.g + \" B:\" + this.b + \" A:\" + this.a + \"}\";\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"Color4\"\r\n     * @returns \"Color4\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"Color4\";\r\n    }\r\n\r\n    /**\r\n     * Compute the Color4 hash code\r\n     * @returns an unique number that can be used to hash Color4 objects\r\n     */\r\n    public getHashCode(): number {\r\n        let hash = (this.r * 255) | 0;\r\n        hash = (hash * 397) ^ ((this.g * 255) | 0);\r\n        hash = (hash * 397) ^ ((this.b * 255) | 0);\r\n        hash = (hash * 397) ^ ((this.a * 255) | 0);\r\n        return hash;\r\n    }\r\n\r\n    /**\r\n     * Creates a new Color4 copied from the current one\r\n     * @returns a new Color4 object\r\n     */\r\n    public clone(): Color4 {\r\n        const result = new Color4();\r\n        return result.copyFrom(this);\r\n    }\r\n\r\n    /**\r\n     * Copies the given Color4 values into the current one\r\n     * @param source defines the source Color4 object\r\n     * @returns the current updated Color4 object\r\n     */\r\n    public copyFrom(source: DeepImmutable<IColor4Like>): this {\r\n        this.r = source.r;\r\n        this.g = source.g;\r\n        this.b = source.b;\r\n        this.a = source.a;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Copies the given float values into the current one\r\n     * @param r defines the red component to read from\r\n     * @param g defines the green component to read from\r\n     * @param b defines the blue component to read from\r\n     * @param a defines the alpha component to read from\r\n     * @returns the current updated Color4 object\r\n     */\r\n    public copyFromFloats(r: number, g: number, b: number, a: number): this {\r\n        this.r = r;\r\n        this.g = g;\r\n        this.b = b;\r\n        this.a = a;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Copies the given float values into the current one\r\n     * @param r defines the red component to read from\r\n     * @param g defines the green component to read from\r\n     * @param b defines the blue component to read from\r\n     * @param a defines the alpha component to read from\r\n     * @returns the current updated Color4 object\r\n     */\r\n    public set(r: number, g: number, b: number, a: number): this {\r\n        return this.copyFromFloats(r, g, b, a);\r\n    }\r\n\r\n    /**\r\n     * Copies the given float to the current Vector4 coordinates\r\n     * @param v defines the r, g, b, and a coordinates of the operand\r\n     * @returns the current updated Vector4\r\n     */\r\n    public setAll(v: number): this {\r\n        this.r = this.g = this.b = this.a = v;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Compute the Color4 hexadecimal code as a string\r\n     * @param returnAsColor3 defines if the string should only contains RGB values (off by default)\r\n     * @returns a string containing the hexadecimal representation of the Color4 object\r\n     */\r\n    public toHexString(returnAsColor3 = false): string {\r\n        const intR = Math.round(this.r * 255);\r\n        const intG = Math.round(this.g * 255);\r\n        const intB = Math.round(this.b * 255);\r\n\r\n        if (returnAsColor3) {\r\n            return \"#\" + ToHex(intR) + ToHex(intG) + ToHex(intB);\r\n        }\r\n\r\n        const intA = Math.round(this.a * 255);\r\n        return \"#\" + ToHex(intR) + ToHex(intG) + ToHex(intB) + ToHex(intA);\r\n    }\r\n\r\n    /**\r\n     * Updates the Color4 rgba values from the string containing valid hexadecimal values.\r\n     *\r\n     * A valid hex string is either in the format #RRGGBB or #RRGGBBAA.\r\n     *\r\n     * When a hex string without alpha is passed, the resulting Color4 keeps\r\n     * its previous alpha value.\r\n     *\r\n     * An invalid string does not modify this object\r\n     *\r\n     * @param hex defines a string containing valid hexadecimal values\r\n     * @returns the current updated Color4 object\r\n     */\r\n    public fromHexString(hex: string): this {\r\n        if (hex.substring(0, 1) !== \"#\" || (hex.length !== 9 && hex.length !== 7)) {\r\n            return this;\r\n        }\r\n\r\n        this.r = parseInt(hex.substring(1, 3), 16) / 255;\r\n        this.g = parseInt(hex.substring(3, 5), 16) / 255;\r\n        this.b = parseInt(hex.substring(5, 7), 16) / 255;\r\n        if (hex.length === 9) {\r\n            this.a = parseInt(hex.substring(7, 9), 16) / 255;\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Computes a new Color4 converted from the current one to linear space\r\n     * @param exact defines if the conversion will be done in an exact way which is slower but more accurate (default is false)\r\n     * @returns a new Color4 object\r\n     */\r\n    public toLinearSpace(exact = false): Color4 {\r\n        const convertedColor = new Color4();\r\n        this.toLinearSpaceToRef(convertedColor, exact);\r\n        return convertedColor;\r\n    }\r\n\r\n    /**\r\n     * Converts the Color4 values to linear space and stores the result in \"convertedColor\"\r\n     * @param convertedColor defines the Color4 object where to store the linear space version\r\n     * @param exact defines if the conversion will be done in an exact way which is slower but more accurate (default is false)\r\n     * @returns the unmodified Color4\r\n     */\r\n    public toLinearSpaceToRef(convertedColor: IColor4Like, exact = false): this {\r\n        if (exact) {\r\n            convertedColor.r = colorChannelToLinearSpaceExact(this.r);\r\n            convertedColor.g = colorChannelToLinearSpaceExact(this.g);\r\n            convertedColor.b = colorChannelToLinearSpaceExact(this.b);\r\n        } else {\r\n            convertedColor.r = colorChannelToLinearSpace(this.r);\r\n            convertedColor.g = colorChannelToLinearSpace(this.g);\r\n            convertedColor.b = colorChannelToLinearSpace(this.b);\r\n        }\r\n        convertedColor.a = this.a;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Computes a new Color4 converted from the current one to gamma space\r\n     * @param exact defines if the conversion will be done in an exact way which is slower but more accurate (default is false)\r\n     * @returns a new Color4 object\r\n     */\r\n    public toGammaSpace(exact = false): Color4 {\r\n        const convertedColor = new Color4();\r\n        this.toGammaSpaceToRef(convertedColor, exact);\r\n        return convertedColor;\r\n    }\r\n\r\n    /**\r\n     * Converts the Color4 values to gamma space and stores the result in \"convertedColor\"\r\n     * @param convertedColor defines the Color4 object where to store the gamma space version\r\n     * @param exact defines if the conversion will be done in an exact way which is slower but more accurate (default is false)\r\n     * @returns the unmodified Color4\r\n     */\r\n    public toGammaSpaceToRef(convertedColor: IColor4Like, exact = false): this {\r\n        if (exact) {\r\n            convertedColor.r = colorChannelToGammaSpaceExact(this.r);\r\n            convertedColor.g = colorChannelToGammaSpaceExact(this.g);\r\n            convertedColor.b = colorChannelToGammaSpaceExact(this.b);\r\n        } else {\r\n            convertedColor.r = colorChannelToGammaSpace(this.r);\r\n            convertedColor.g = colorChannelToGammaSpace(this.g);\r\n            convertedColor.b = colorChannelToGammaSpace(this.b);\r\n        }\r\n        convertedColor.a = this.a;\r\n        return this;\r\n    }\r\n\r\n    // Statics\r\n\r\n    /**\r\n     * Creates a new Color4 from the string containing valid hexadecimal values.\r\n     *\r\n     * A valid hex string is either in the format #RRGGBB or #RRGGBBAA.\r\n     *\r\n     * When a hex string without alpha is passed, the resulting Color4 has\r\n     * its alpha value set to 1.0.\r\n     *\r\n     * An invalid string results in a Color with all its channels set to 0.0,\r\n     * i.e. \"transparent black\".\r\n     *\r\n     * @param hex defines a string containing valid hexadecimal values\r\n     * @returns a new Color4 object\r\n     */\r\n    public static FromHexString(hex: string): Color4 {\r\n        if (hex.substring(0, 1) !== \"#\" || (hex.length !== 9 && hex.length !== 7)) {\r\n            return new Color4(0.0, 0.0, 0.0, 0.0);\r\n        }\r\n\r\n        return new Color4(0.0, 0.0, 0.0, 1.0).fromHexString(hex);\r\n    }\r\n\r\n    /**\r\n     * Creates a new Color4 object set with the linearly interpolated values of \"amount\" between the left Color4 object and the right Color4 object\r\n     * @param left defines the start value\r\n     * @param right defines the end value\r\n     * @param amount defines the gradient factor\r\n     * @returns a new Color4 object\r\n     */\r\n    public static Lerp(left: DeepImmutable<IColor4Like>, right: DeepImmutable<IColor4Like>, amount: number): Color4 {\r\n        return Color4.LerpToRef(left, right, amount, new Color4());\r\n    }\r\n\r\n    /**\r\n     * Set the given \"result\" with the linearly interpolated values of \"amount\" between the left Color4 object and the right Color4 object\r\n     * @param left defines the start value\r\n     * @param right defines the end value\r\n     * @param amount defines the gradient factor\r\n     * @param result defines the Color4 object where to store data\r\n     * @returns the updated result\r\n     */\r\n    public static LerpToRef<T extends IColor4Like>(left: DeepImmutable<IColor4Like>, right: DeepImmutable<IColor4Like>, amount: number, result: T): T {\r\n        result.r = left.r + (right.r - left.r) * amount;\r\n        result.g = left.g + (right.g - left.g) * amount;\r\n        result.b = left.b + (right.b - left.b) * amount;\r\n        result.a = left.a + (right.a - left.a) * amount;\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Interpolate between two Color4 using Hermite interpolation\r\n     * @param value1 defines first Color4\r\n     * @param tangent1 defines the incoming tangent\r\n     * @param value2 defines second Color4\r\n     * @param tangent2 defines the outgoing tangent\r\n     * @param amount defines the target Color4\r\n     * @returns the new interpolated Color4\r\n     */\r\n    public static Hermite(\r\n        value1: DeepImmutable<IColor4Like>,\r\n        tangent1: DeepImmutable<IColor4Like>,\r\n        value2: DeepImmutable<IColor4Like>,\r\n        tangent2: DeepImmutable<IColor4Like>,\r\n        amount: number\r\n    ): Color4 {\r\n        const squared = amount * amount;\r\n        const cubed = amount * squared;\r\n        const part1 = 2.0 * cubed - 3.0 * squared + 1.0;\r\n        const part2 = -2.0 * cubed + 3.0 * squared;\r\n        const part3 = cubed - 2.0 * squared + amount;\r\n        const part4 = cubed - squared;\r\n\r\n        const r = value1.r * part1 + value2.r * part2 + tangent1.r * part3 + tangent2.r * part4;\r\n        const g = value1.g * part1 + value2.g * part2 + tangent1.g * part3 + tangent2.g * part4;\r\n        const b = value1.b * part1 + value2.b * part2 + tangent1.b * part3 + tangent2.b * part4;\r\n        const a = value1.a * part1 + value2.a * part2 + tangent1.a * part3 + tangent2.a * part4;\r\n        return new Color4(r, g, b, a);\r\n    }\r\n\r\n    /**\r\n     * Returns a new Color4 which is the 1st derivative of the Hermite spline defined by the colors \"value1\", \"value2\", \"tangent1\", \"tangent2\".\r\n     * @param value1 defines the first control point\r\n     * @param tangent1 defines the first tangent\r\n     * @param value2 defines the second control point\r\n     * @param tangent2 defines the second tangent\r\n     * @param time define where the derivative must be done\r\n     * @returns 1st derivative\r\n     */\r\n    public static Hermite1stDerivative(\r\n        value1: DeepImmutable<IColor4Like>,\r\n        tangent1: DeepImmutable<IColor4Like>,\r\n        value2: DeepImmutable<IColor4Like>,\r\n        tangent2: DeepImmutable<IColor4Like>,\r\n        time: number\r\n    ): Color4 {\r\n        const result = new Color4();\r\n\r\n        this.Hermite1stDerivativeToRef(value1, tangent1, value2, tangent2, time, result);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Update a Color4 with the 1st derivative of the Hermite spline defined by the colors \"value1\", \"value2\", \"tangent1\", \"tangent2\".\r\n     * @param value1 defines the first control point\r\n     * @param tangent1 defines the first tangent\r\n     * @param value2 defines the second control point\r\n     * @param tangent2 defines the second tangent\r\n     * @param time define where the derivative must be done\r\n     * @param result define where to store the derivative\r\n     */\r\n    public static Hermite1stDerivativeToRef(\r\n        value1: DeepImmutable<IColor4Like>,\r\n        tangent1: DeepImmutable<IColor4Like>,\r\n        value2: DeepImmutable<IColor4Like>,\r\n        tangent2: DeepImmutable<IColor4Like>,\r\n        time: number,\r\n        result: IColor4Like\r\n    ) {\r\n        const t2 = time * time;\r\n\r\n        result.r = (t2 - time) * 6 * value1.r + (3 * t2 - 4 * time + 1) * tangent1.r + (-t2 + time) * 6 * value2.r + (3 * t2 - 2 * time) * tangent2.r;\r\n        result.g = (t2 - time) * 6 * value1.g + (3 * t2 - 4 * time + 1) * tangent1.g + (-t2 + time) * 6 * value2.g + (3 * t2 - 2 * time) * tangent2.g;\r\n        result.b = (t2 - time) * 6 * value1.b + (3 * t2 - 4 * time + 1) * tangent1.b + (-t2 + time) * 6 * value2.b + (3 * t2 - 2 * time) * tangent2.b;\r\n        result.a = (t2 - time) * 6 * value1.a + (3 * t2 - 4 * time + 1) * tangent1.a + (-t2 + time) * 6 * value2.a + (3 * t2 - 2 * time) * tangent2.a;\r\n    }\r\n\r\n    /**\r\n     * Creates a new Color4 from a Color3 and an alpha value\r\n     * @param color3 defines the source Color3 to read from\r\n     * @param alpha defines the alpha component (1.0 by default)\r\n     * @returns a new Color4 object\r\n     */\r\n    public static FromColor3(color3: DeepImmutable<IColor3Like>, alpha: number = 1.0): Color4 {\r\n        return new Color4(color3.r, color3.g, color3.b, alpha);\r\n    }\r\n\r\n    /**\r\n     * Creates a new Color4 from the starting index element of the given array\r\n     * @param array defines the source array to read from\r\n     * @param offset defines the offset in the source array\r\n     * @returns a new Color4 object\r\n     */\r\n    public static FromArray(array: DeepImmutable<ArrayLike<number>>, offset: number = 0): Color4 {\r\n        return new Color4(array[offset], array[offset + 1], array[offset + 2], array[offset + 3]);\r\n    }\r\n\r\n    /**\r\n     * Creates a new Color4 from the starting index element of the given array\r\n     * @param array defines the source array to read from\r\n     * @param offset defines the offset in the source array\r\n     * @param result defines the target Color4 object\r\n     */\r\n    public static FromArrayToRef(array: DeepImmutable<ArrayLike<number>>, offset: number = 0, result: Color4) {\r\n        result.r = array[offset];\r\n        result.g = array[offset + 1];\r\n        result.b = array[offset + 2];\r\n        result.a = array[offset + 3];\r\n    }\r\n\r\n    /**\r\n     * Creates a new Color3 from integer values (less than 256)\r\n     * @param r defines the red component to read from (value between 0 and 255)\r\n     * @param g defines the green component to read from (value between 0 and 255)\r\n     * @param b defines the blue component to read from (value between 0 and 255)\r\n     * @param a defines the alpha component to read from (value between 0 and 255)\r\n     * @returns a new Color3 object\r\n     */\r\n    public static FromInts(r: number, g: number, b: number, a: number): Color4 {\r\n        return new Color4(r / 255.0, g / 255.0, b / 255.0, a / 255.0);\r\n    }\r\n\r\n    /**\r\n     * Check the content of a given array and convert it to an array containing RGBA data\r\n     * If the original array was already containing count * 4 values then it is returned directly\r\n     * @param colors defines the array to check\r\n     * @param count defines the number of RGBA data to expect\r\n     * @returns an array containing count * 4 values (RGBA)\r\n     */\r\n    public static CheckColors4(colors: number[], count: number): number[] {\r\n        // Check if color3 was used\r\n        if (colors.length === count * 3) {\r\n            const colors4 = [];\r\n            for (let index = 0; index < colors.length; index += 3) {\r\n                const newIndex = (index / 3) * 4;\r\n                colors4[newIndex] = colors[index];\r\n                colors4[newIndex + 1] = colors[index + 1];\r\n                colors4[newIndex + 2] = colors[index + 2];\r\n                colors4[newIndex + 3] = 1.0;\r\n            }\r\n\r\n            return colors4;\r\n        }\r\n\r\n        return colors;\r\n    }\r\n}\r\nObject.defineProperties(Color4.prototype, {\r\n    dimension: { value: [4] },\r\n    rank: { value: 1 },\r\n});\r\n\r\n/**\r\n * @internal\r\n */\r\nexport class TmpColors {\r\n    public static Color3: Color3[] = BuildArray(3, Color3.Black);\r\n    public static Color4: Color4[] = BuildArray(3, () => new Color4(0, 0, 0, 0));\r\n}\r\n\r\nRegisterClass(\"BABYLON.Color3\", Color3);\r\nRegisterClass(\"BABYLON.Color4\", Color4);\r\n", "/**\r\n * Interface for the size containing width and height\r\n */\r\nexport interface ISize {\r\n    /**\r\n     * Width\r\n     */\r\n    width: number;\r\n    /**\r\n     * Height\r\n     */\r\n    height: number;\r\n}\r\n\r\n/**\r\n * Size containing width and height\r\n */\r\nexport class Size implements ISize {\r\n    /**\r\n     * Width\r\n     */\r\n    public width: number;\r\n    /**\r\n     * Height\r\n     */\r\n    public height: number;\r\n\r\n    /**\r\n     * Creates a Size object from the given width and height (floats).\r\n     * @param width width of the new size\r\n     * @param height height of the new size\r\n     */\r\n    public constructor(width: number, height: number) {\r\n        this.width = width;\r\n        this.height = height;\r\n    }\r\n\r\n    /**\r\n     * Returns a string with the Size width and height\r\n     * @returns a string with the Size width and height\r\n     */\r\n    public toString(): string {\r\n        return `{W: ${this.width}, H: ${this.height}}`;\r\n    }\r\n    /**\r\n     * \"Size\"\r\n     * @returns the string \"Size\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"Size\";\r\n    }\r\n    /**\r\n     * Returns the Size hash code.\r\n     * @returns a hash code for a unique width and height\r\n     */\r\n    public getHashCode(): number {\r\n        let hash = this.width | 0;\r\n        hash = (hash * 397) ^ (this.height | 0);\r\n        return hash;\r\n    }\r\n    /**\r\n     * Updates the current size from the given one.\r\n     * @param src the given size\r\n     */\r\n    public copyFrom(src: Size) {\r\n        this.width = src.width;\r\n        this.height = src.height;\r\n    }\r\n    /**\r\n     * Updates in place the current Size from the given floats.\r\n     * @param width width of the new size\r\n     * @param height height of the new size\r\n     * @returns the updated Size.\r\n     */\r\n    public copyFromFloats(width: number, height: number): Size {\r\n        this.width = width;\r\n        this.height = height;\r\n        return this;\r\n    }\r\n    /**\r\n     * Updates in place the current Size from the given floats.\r\n     * @param width width to set\r\n     * @param height height to set\r\n     * @returns the updated Size.\r\n     */\r\n    public set(width: number, height: number): Size {\r\n        return this.copyFromFloats(width, height);\r\n    }\r\n    /**\r\n     * Multiplies the width and height by numbers\r\n     * @param w factor to multiple the width by\r\n     * @param h factor to multiple the height by\r\n     * @returns a new Size set with the multiplication result of the current Size and the given floats.\r\n     */\r\n    public multiplyByFloats(w: number, h: number): Size {\r\n        return new Size(this.width * w, this.height * h);\r\n    }\r\n    /**\r\n     * Clones the size\r\n     * @returns a new Size copied from the given one.\r\n     */\r\n    public clone(): Size {\r\n        return new Size(this.width, this.height);\r\n    }\r\n    /**\r\n     * True if the current Size and the given one width and height are strictly equal.\r\n     * @param other the other size to compare against\r\n     * @returns True if the current Size and the given one width and height are strictly equal.\r\n     */\r\n    public equals(other: Size): boolean {\r\n        if (!other) {\r\n            return false;\r\n        }\r\n        return this.width === other.width && this.height === other.height;\r\n    }\r\n    /**\r\n     * The surface of the Size : width * height (float).\r\n     */\r\n    public get surface(): number {\r\n        return this.width * this.height;\r\n    }\r\n    /**\r\n     * Create a new size of zero\r\n     * @returns a new Size set to (0.0, 0.0)\r\n     */\r\n    public static Zero(): Size {\r\n        return new Size(0.0, 0.0);\r\n    }\r\n    /**\r\n     * Sums the width and height of two sizes\r\n     * @param otherSize size to add to this size\r\n     * @returns a new Size set as the addition result of the current Size and the given one.\r\n     */\r\n    public add(otherSize: Size): Size {\r\n        const r = new Size(this.width + otherSize.width, this.height + otherSize.height);\r\n        return r;\r\n    }\r\n    /**\r\n     * Subtracts the width and height of two\r\n     * @param otherSize size to subtract to this size\r\n     * @returns a new Size set as the subtraction result of  the given one from the current Size.\r\n     */\r\n    public subtract(otherSize: Size): Size {\r\n        const r = new Size(this.width - otherSize.width, this.height - otherSize.height);\r\n        return r;\r\n    }\r\n    /**\r\n     * Scales the width and height\r\n     * @param scale the scale to multiply the width and height by\r\n     * @returns a new Size set with the multiplication result of the current Size and the given floats.\r\n     */\r\n    public scale(scale: number): Size {\r\n        return new Size(this.width * scale, this.height * scale);\r\n    }\r\n    /**\r\n     * Creates a new Size set at the linear interpolation \"amount\" between \"start\" and \"end\"\r\n     * @param start starting size to lerp between\r\n     * @param end end size to lerp between\r\n     * @param amount amount to lerp between the start and end values\r\n     * @returns a new Size set at the linear interpolation \"amount\" between \"start\" and \"end\"\r\n     */\r\n    public static Lerp(start: Size, end: Size, amount: number): Size {\r\n        const w = start.width + (end.width - start.width) * amount;\r\n        const h = start.height + (end.height - start.height) * amount;\r\n\r\n        return new Size(w, h);\r\n    }\r\n}\r\n", "// eslint-disable-next-line @typescript-eslint/naming-convention\r\nconst __mergedStore = {};\r\n\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nconst __decoratorInitialStore = {};\r\n\r\n/** @internal */\r\nexport function GetDirectStore(target: any): any {\r\n    const classKey = target.getClassName();\r\n\r\n    if (!(<any>__decoratorInitialStore)[classKey]) {\r\n        (<any>__decoratorInitialStore)[classKey] = {};\r\n    }\r\n\r\n    return (<any>__decoratorInitialStore)[classKey];\r\n}\r\n\r\n/**\r\n * @returns the list of properties flagged as serializable\r\n * @param target host object\r\n */\r\nexport function GetMergedStore(target: any): any {\r\n    const classKey = target.getClassName();\r\n\r\n    if ((<any>__mergedStore)[classKey]) {\r\n        return (<any>__mergedStore)[classKey];\r\n    }\r\n\r\n    (<any>__mergedStore)[classKey] = {};\r\n\r\n    const store = (<any>__mergedStore)[classKey];\r\n    let currentTarget = target;\r\n    let currentKey = classKey;\r\n    while (currentKey) {\r\n        const initialStore = (<any>__decoratorInitialStore)[currentKey];\r\n        for (const property in initialStore) {\r\n            store[property] = initialStore[property];\r\n        }\r\n\r\n        let parent: any;\r\n        let done = false;\r\n\r\n        do {\r\n            parent = Object.getPrototypeOf(currentTarget);\r\n            if (!parent.getClassName) {\r\n                done = true;\r\n                break;\r\n            }\r\n\r\n            if (parent.getClassName() !== currentKey) {\r\n                break;\r\n            }\r\n\r\n            currentTarget = parent;\r\n        } while (parent);\r\n\r\n        if (done) {\r\n            break;\r\n        }\r\n\r\n        currentKey = parent.getClassName();\r\n        currentTarget = parent;\r\n    }\r\n\r\n    return store;\r\n}\r\n", "/* eslint-disable @typescript-eslint/no-unused-vars */\r\n/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"../types\";\r\nimport { GetDirectStore } from \"./decorators.functions\";\r\nimport { _WarnImport } from \"./devTools\";\r\n\r\nfunction generateSerializableMember(type: number, sourceName?: string) {\r\n    return (target: any, propertyKey: string | symbol) => {\r\n        const classStore = GetDirectStore(target);\r\n\r\n        if (!classStore[propertyKey]) {\r\n            classStore[propertyKey] = { type: type, sourceName: sourceName };\r\n        }\r\n    };\r\n}\r\n\r\nfunction generateExpandMember(setCallback: string, targetKey: Nullable<string> = null) {\r\n    return (target: any, propertyKey: string) => {\r\n        const key = targetKey || \"_\" + propertyKey;\r\n        Object.defineProperty(target, propertyKey, {\r\n            get: function (this: any) {\r\n                return this[key];\r\n            },\r\n            set: function (this: any, value) {\r\n                // does this object (i.e. vector3) has an equals function? use it!\r\n                // Note - not using \"with epsilon\" here, it is expected te behave like the internal cache does.\r\n                if (typeof this.equals === \"function\") {\r\n                    if (this.equals(value)) {\r\n                        return;\r\n                    }\r\n                }\r\n                if (this[key] === value) {\r\n                    return;\r\n                }\r\n                this[key] = value;\r\n\r\n                target[setCallback].apply(this);\r\n            },\r\n            enumerable: true,\r\n            configurable: true,\r\n        });\r\n    };\r\n}\r\n\r\nexport function expandToProperty(callback: string, targetKey: Nullable<string> = null) {\r\n    return generateExpandMember(callback, targetKey);\r\n}\r\n\r\nexport function serialize(sourceName?: string) {\r\n    return generateSerializableMember(0, sourceName); // value member\r\n}\r\n\r\nexport function serializeAsTexture(sourceName?: string) {\r\n    return generateSerializableMember(1, sourceName); // texture member\r\n}\r\n\r\nexport function serializeAsColor3(sourceName?: string) {\r\n    return generateSerializableMember(2, sourceName); // color3 member\r\n}\r\n\r\nexport function serializeAsFresnelParameters(sourceName?: string) {\r\n    return generateSerializableMember(3, sourceName); // fresnel parameters member\r\n}\r\n\r\nexport function serializeAsVector2(sourceName?: string) {\r\n    return generateSerializableMember(4, sourceName); // vector2 member\r\n}\r\n\r\nexport function serializeAsVector3(sourceName?: string) {\r\n    return generateSerializableMember(5, sourceName); // vector3 member\r\n}\r\n\r\nexport function serializeAsMeshReference(sourceName?: string) {\r\n    return generateSerializableMember(6, sourceName); // mesh reference member\r\n}\r\n\r\nexport function serializeAsColorCurves(sourceName?: string) {\r\n    return generateSerializableMember(7, sourceName); // color curves\r\n}\r\n\r\nexport function serializeAsColor4(sourceName?: string) {\r\n    return generateSerializableMember(8, sourceName); // color 4\r\n}\r\n\r\nexport function serializeAsImageProcessingConfiguration(sourceName?: string) {\r\n    return generateSerializableMember(9, sourceName); // image processing\r\n}\r\n\r\nexport function serializeAsQuaternion(sourceName?: string) {\r\n    return generateSerializableMember(10, sourceName); // quaternion member\r\n}\r\n\r\nexport function serializeAsMatrix(sourceName?: string) {\r\n    return generateSerializableMember(12, sourceName); // matrix member\r\n}\r\n\r\n/**\r\n * Decorator used to define property that can be serialized as reference to a camera\r\n * @param sourceName defines the name of the property to decorate\r\n * @returns Property Decorator\r\n */\r\nexport function serializeAsCameraReference(sourceName?: string) {\r\n    return generateSerializableMember(11, sourceName); // camera reference member\r\n}\r\n\r\n/** @internal */\r\ndeclare const _native: any;\r\n\r\n/**\r\n * Decorator used to redirect a function to a native implementation if available.\r\n * @internal\r\n */\r\nexport function nativeOverride<T extends (...params: any[]) => boolean>(\r\n    target: any,\r\n    propertyKey: string,\r\n    descriptor: TypedPropertyDescriptor<(...params: Parameters<T>) => unknown>,\r\n    predicate?: T\r\n) {\r\n    // Cache the original JS function for later.\r\n    const jsFunc = descriptor.value!;\r\n\r\n    // Override the JS function to check for a native override on first invocation. Setting descriptor.value overrides the function at the early stage of code being loaded/imported.\r\n    descriptor.value = (...params: Parameters<T>): unknown => {\r\n        // Assume the resolved function will be the original JS function, then we will check for the Babylon Native context.\r\n        let func = jsFunc;\r\n\r\n        // Check if we are executing in a Babylon Native context (e.g. check the presence of the _native global property) and if so also check if a function override is available.\r\n        if (typeof _native !== \"undefined\" && _native[propertyKey]) {\r\n            const nativeFunc = _native[propertyKey] as (...params: Parameters<T>) => unknown;\r\n            // If a predicate was provided, then we'll need to invoke the predicate on each invocation of the underlying function to determine whether to call the native function or the JS function.\r\n            if (predicate) {\r\n                // The resolved function will execute the predicate and then either execute the native function or the JS function.\r\n                func = (...params: Parameters<T>) => (predicate(...params) ? nativeFunc(...params) : jsFunc(...params));\r\n            } else {\r\n                // The resolved function will directly execute the native function.\r\n                func = nativeFunc;\r\n            }\r\n        }\r\n\r\n        // Override the JS function again with the final resolved target function.\r\n        target[propertyKey] = func;\r\n\r\n        // The JS function has now been overridden based on whether we're executing in the context of Babylon Native, but we still need to invoke that function.\r\n        // Future invocations of the function will just directly invoke the final overridden function, not any of the decorator setup logic above.\r\n        return func(...params);\r\n    };\r\n}\r\n\r\n/**\r\n * Decorator factory that applies the nativeOverride decorator, but determines whether to redirect to the native implementation based on a filter function that evaluates the function arguments.\r\n * @param predicate\r\n * @example @nativeOverride.filter((...[arg1]: Parameters<typeof someClass.someMethod>) => arg1.length > 20)\r\n *          public someMethod(arg1: string, arg2: number): string {\r\n * @internal\r\n */\r\nnativeOverride.filter = function <T extends (...params: any) => boolean>(predicate: T) {\r\n    return (target: any, propertyKey: string, descriptor: TypedPropertyDescriptor<(...params: Parameters<T>) => unknown>) =>\r\n        nativeOverride(target, propertyKey, descriptor, predicate);\r\n};\r\n", "import type { FresnelParameters } from \"../Materials/fresnelParameters\";\r\nimport type { ImageProcessingConfiguration } from \"../Materials/imageProcessingConfiguration\";\r\nimport { _WarnImport } from \"./devTools\";\r\nimport type { ColorCurves } from \"../Materials/colorCurves\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport type { IAnimatable } from \"../Animations/animatable.interface\";\r\nimport { Tags } from \"./tags\";\r\nimport { Color3, Color4 } from \"../Maths/math.color\";\r\nimport { Matrix, Quaternion, Vector2, Vector3 } from \"../Maths/math.vector\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport { GetMergedStore } from \"./decorators.functions\";\r\n\r\n/** @internal */\r\nexport interface CopySourceOptions {\r\n    /*\r\n     * if a texture is used in more than one channel (e.g diffuse and opacity),\r\n     * only clone it once and reuse it on the other channels. Default false\r\n     */\r\n    cloneTexturesOnlyOnce?: boolean;\r\n}\r\n\r\nconst _copySource = function <T>(creationFunction: () => T, source: T, instanciate: boolean, options: CopySourceOptions = {}): T {\r\n    const destination = creationFunction();\r\n\r\n    // Tags\r\n    if (Tags && Tags.HasTags(source)) {\r\n        Tags.AddTagsTo(destination, Tags.GetTags(source, true));\r\n    }\r\n\r\n    const classStore = GetMergedStore(destination);\r\n\r\n    // Map from source texture uniqueId to destination texture\r\n    const textureMap: Record<number, any> = {};\r\n\r\n    // Properties\r\n    for (const property in classStore) {\r\n        const propertyDescriptor = classStore[property];\r\n        const sourceProperty = (<any>source)[property];\r\n        const propertyType = propertyDescriptor.type;\r\n\r\n        if (sourceProperty !== undefined && sourceProperty !== null && (property !== \"uniqueId\" || SerializationHelper.AllowLoadingUniqueId)) {\r\n            switch (propertyType) {\r\n                case 0: // Value\r\n                case 6: // Mesh reference\r\n                case 11: // Camera reference\r\n                    (<any>destination)[property] = sourceProperty;\r\n                    break;\r\n                case 1: // Texture\r\n                    if (options.cloneTexturesOnlyOnce && textureMap[sourceProperty.uniqueId]) {\r\n                        (<any>destination)[property] = textureMap[sourceProperty.uniqueId];\r\n                    } else {\r\n                        (<any>destination)[property] = instanciate || sourceProperty.isRenderTarget ? sourceProperty : sourceProperty.clone();\r\n                        textureMap[sourceProperty.uniqueId] = (<any>destination)[property];\r\n                    }\r\n                    break;\r\n                case 2: // Color3\r\n                case 3: // FresnelParameters\r\n                case 4: // Vector2\r\n                case 5: // Vector3\r\n                case 7: // Color Curves\r\n                case 10: // Quaternion\r\n                case 12: // Matrix\r\n                    (<any>destination)[property] = instanciate ? sourceProperty : sourceProperty.clone();\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n\r\n    return destination;\r\n};\r\n\r\n/**\r\n * Class used to help serialization objects\r\n */\r\nexport class SerializationHelper {\r\n    /**\r\n     * Gets or sets a boolean to indicate if the UniqueId property should be serialized\r\n     */\r\n    public static AllowLoadingUniqueId = false;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _ImageProcessingConfigurationParser = (sourceProperty: any): ImageProcessingConfiguration => {\r\n        throw _WarnImport(\"ImageProcessingConfiguration\");\r\n    };\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _FresnelParametersParser = (sourceProperty: any): FresnelParameters => {\r\n        throw _WarnImport(\"FresnelParameters\");\r\n    };\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _ColorCurvesParser = (sourceProperty: any): ColorCurves => {\r\n        throw _WarnImport(\"ColorCurves\");\r\n    };\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _TextureParser = (sourceProperty: any, scene: Scene, rootUrl: string): Nullable<BaseTexture> => {\r\n        throw _WarnImport(\"Texture\");\r\n    };\r\n\r\n    /**\r\n     * Appends the serialized animations from the source animations\r\n     * @param source Source containing the animations\r\n     * @param destination Target to store the animations\r\n     */\r\n    public static AppendSerializedAnimations(source: IAnimatable, destination: any): void {\r\n        if (source.animations) {\r\n            destination.animations = [];\r\n            for (let animationIndex = 0; animationIndex < source.animations.length; animationIndex++) {\r\n                const animation = source.animations[animationIndex];\r\n\r\n                destination.animations.push(animation.serialize());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Static function used to serialized a specific entity\r\n     * @param entity defines the entity to serialize\r\n     * @param serializationObject defines the optional target object where serialization data will be stored\r\n     * @returns a JSON compatible object representing the serialization of the entity\r\n     */\r\n    public static Serialize<T>(entity: T, serializationObject?: any): any {\r\n        if (!serializationObject) {\r\n            serializationObject = {};\r\n        }\r\n\r\n        // Tags\r\n        if (Tags) {\r\n            serializationObject.tags = Tags.GetTags(entity);\r\n        }\r\n\r\n        const serializedProperties = GetMergedStore(entity);\r\n\r\n        // Properties\r\n        for (const property in serializedProperties) {\r\n            const propertyDescriptor = serializedProperties[property];\r\n            const targetPropertyName = propertyDescriptor.sourceName || property;\r\n            const propertyType = propertyDescriptor.type;\r\n            const sourceProperty = (<any>entity)[property];\r\n\r\n            if (sourceProperty !== undefined && sourceProperty !== null && (property !== \"uniqueId\" || SerializationHelper.AllowLoadingUniqueId)) {\r\n                switch (propertyType) {\r\n                    case 0: // Value\r\n                        serializationObject[targetPropertyName] = sourceProperty;\r\n                        break;\r\n                    case 1: // Texture\r\n                        serializationObject[targetPropertyName] = sourceProperty.serialize();\r\n                        break;\r\n                    case 2: // Color3\r\n                        serializationObject[targetPropertyName] = sourceProperty.asArray();\r\n                        break;\r\n                    case 3: // FresnelParameters\r\n                        serializationObject[targetPropertyName] = sourceProperty.serialize();\r\n                        break;\r\n                    case 4: // Vector2\r\n                        serializationObject[targetPropertyName] = sourceProperty.asArray();\r\n                        break;\r\n                    case 5: // Vector3\r\n                        serializationObject[targetPropertyName] = sourceProperty.asArray();\r\n                        break;\r\n                    case 6: // Mesh reference\r\n                        serializationObject[targetPropertyName] = sourceProperty.id;\r\n                        break;\r\n                    case 7: // Color Curves\r\n                        serializationObject[targetPropertyName] = sourceProperty.serialize();\r\n                        break;\r\n                    case 8: // Color 4\r\n                        serializationObject[targetPropertyName] = (<Color4>sourceProperty).asArray();\r\n                        break;\r\n                    case 9: // Image Processing\r\n                        serializationObject[targetPropertyName] = (<ImageProcessingConfiguration>sourceProperty).serialize();\r\n                        break;\r\n                    case 10: // Quaternion\r\n                        serializationObject[targetPropertyName] = (<Quaternion>sourceProperty).asArray();\r\n                        break;\r\n                    case 11: // Camera reference\r\n                        serializationObject[targetPropertyName] = (<Camera>sourceProperty).id;\r\n                        break;\r\n                    case 12: // Matrix\r\n                        serializationObject[targetPropertyName] = (<Matrix>sourceProperty).asArray();\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Given a source json and a destination object in a scene, this function will parse the source and will try to apply its content to the destination object\r\n     * @param source the source json data\r\n     * @param destination the destination object\r\n     * @param scene the scene where the object is\r\n     * @param rootUrl root url to use to load assets\r\n     */\r\n    public static ParseProperties(source: any, destination: any, scene: Nullable<Scene>, rootUrl: Nullable<string>) {\r\n        if (!rootUrl) {\r\n            rootUrl = \"\";\r\n        }\r\n\r\n        const classStore = GetMergedStore(destination);\r\n\r\n        // Properties\r\n        for (const property in classStore) {\r\n            const propertyDescriptor = classStore[property];\r\n            const sourceProperty = source[propertyDescriptor.sourceName || property];\r\n            const propertyType = propertyDescriptor.type;\r\n\r\n            if (sourceProperty !== undefined && sourceProperty !== null && (property !== \"uniqueId\" || SerializationHelper.AllowLoadingUniqueId)) {\r\n                const dest = <any>destination;\r\n                switch (propertyType) {\r\n                    case 0: // Value\r\n                        dest[property] = sourceProperty;\r\n                        break;\r\n                    case 1: // Texture\r\n                        if (scene) {\r\n                            dest[property] = SerializationHelper._TextureParser(sourceProperty, scene, rootUrl);\r\n                        }\r\n                        break;\r\n                    case 2: // Color3\r\n                        dest[property] = Color3.FromArray(sourceProperty);\r\n                        break;\r\n                    case 3: // FresnelParameters\r\n                        dest[property] = SerializationHelper._FresnelParametersParser(sourceProperty);\r\n                        break;\r\n                    case 4: // Vector2\r\n                        dest[property] = Vector2.FromArray(sourceProperty);\r\n                        break;\r\n                    case 5: // Vector3\r\n                        dest[property] = Vector3.FromArray(sourceProperty);\r\n                        break;\r\n                    case 6: // Mesh reference\r\n                        if (scene) {\r\n                            dest[property] = scene.getLastMeshById(sourceProperty);\r\n                        }\r\n                        break;\r\n                    case 7: // Color Curves\r\n                        dest[property] = SerializationHelper._ColorCurvesParser(sourceProperty);\r\n                        break;\r\n                    case 8: // Color 4\r\n                        dest[property] = Color4.FromArray(sourceProperty);\r\n                        break;\r\n                    case 9: // Image Processing\r\n                        dest[property] = SerializationHelper._ImageProcessingConfigurationParser(sourceProperty);\r\n                        break;\r\n                    case 10: // Quaternion\r\n                        dest[property] = Quaternion.FromArray(sourceProperty);\r\n                        break;\r\n                    case 11: // Camera reference\r\n                        if (scene) {\r\n                            dest[property] = scene.getCameraById(sourceProperty);\r\n                        }\r\n                        break;\r\n                    case 12: // Matrix\r\n                        dest[property] = Matrix.FromArray(sourceProperty);\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates a new entity from a serialization data object\r\n     * @param creationFunction defines a function used to instanciated the new entity\r\n     * @param source defines the source serialization data\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root url for resources\r\n     * @returns a new entity\r\n     */\r\n    public static Parse<T>(creationFunction: () => T, source: any, scene: Nullable<Scene>, rootUrl: Nullable<string> = null): T {\r\n        const destination = creationFunction();\r\n\r\n        // Tags\r\n        if (Tags) {\r\n            Tags.AddTagsTo(destination, source.tags);\r\n        }\r\n\r\n        SerializationHelper.ParseProperties(source, destination, scene, rootUrl);\r\n\r\n        return destination;\r\n    }\r\n\r\n    /**\r\n     * Clones an object\r\n     * @param creationFunction defines the function used to instanciate the new object\r\n     * @param source defines the source object\r\n     * @param options defines the options to use\r\n     * @returns the cloned object\r\n     */\r\n    public static Clone<T>(creationFunction: () => T, source: T, options: CopySourceOptions = {}): T {\r\n        return _copySource(creationFunction, source, false, options);\r\n    }\r\n\r\n    /**\r\n     * Instanciates a new object based on a source one (some data will be shared between both object)\r\n     * @param creationFunction defines the function used to instanciate the new object\r\n     * @param source defines the source object\r\n     * @returns the new object\r\n     */\r\n    public static Instanciate<T>(creationFunction: () => T, source: T): T {\r\n        return _copySource(creationFunction, source, true);\r\n    }\r\n}\r\n", "import type { DeepImmutable } from \"../types\";\r\nimport { Vector3, Matrix } from \"./math.vector\";\r\nimport type { IPlaneLike } from \"./math.like\";\r\n\r\n/**\r\n * Represents a plane by the equation ax + by + cz + d = 0\r\n */\r\nexport class Plane implements IPlaneLike {\r\n    private static _TmpMatrix = Matrix.Identity();\r\n\r\n    /**\r\n     * Normal of the plane (a,b,c)\r\n     */\r\n    public normal: Vector3;\r\n    /**\r\n     * d component of the plane\r\n     */\r\n    public d: number;\r\n    /**\r\n     * Creates a Plane object according to the given floats a, b, c, d and the plane equation : ax + by + cz + d = 0\r\n     * @param a a component of the plane\r\n     * @param b b component of the plane\r\n     * @param c c component of the plane\r\n     * @param d d component of the plane\r\n     */\r\n    constructor(a: number, b: number, c: number, d: number) {\r\n        this.normal = new Vector3(a, b, c);\r\n        this.d = d;\r\n    }\r\n\r\n    /**\r\n     * @returns the plane coordinates as a new array of 4 elements [a, b, c, d].\r\n     */\r\n    public asArray(): number[] {\r\n        return [this.normal.x, this.normal.y, this.normal.z, this.d];\r\n    }\r\n\r\n    // Methods\r\n    /**\r\n     * @returns a new plane copied from the current Plane.\r\n     */\r\n    public clone(): Plane {\r\n        return new Plane(this.normal.x, this.normal.y, this.normal.z, this.d);\r\n    }\r\n    /**\r\n     * @returns the string \"Plane\".\r\n     */\r\n    public getClassName(): string {\r\n        return \"Plane\";\r\n    }\r\n    /**\r\n     * @returns the Plane hash code.\r\n     */\r\n    public getHashCode(): number {\r\n        let hash = this.normal.getHashCode();\r\n        hash = (hash * 397) ^ (this.d | 0);\r\n        return hash;\r\n    }\r\n    /**\r\n     * Normalize the current Plane in place.\r\n     * @returns the updated Plane.\r\n     */\r\n    public normalize(): Plane {\r\n        const norm = Math.sqrt(this.normal.x * this.normal.x + this.normal.y * this.normal.y + this.normal.z * this.normal.z);\r\n        let magnitude = 0.0;\r\n\r\n        if (norm !== 0) {\r\n            magnitude = 1.0 / norm;\r\n        }\r\n        this.normal.x *= magnitude;\r\n        this.normal.y *= magnitude;\r\n        this.normal.z *= magnitude;\r\n        this.d *= magnitude;\r\n        return this;\r\n    }\r\n    /**\r\n     * Applies a transformation the plane and returns the result\r\n     * @param transformation the transformation matrix to be applied to the plane\r\n     * @returns a new Plane as the result of the transformation of the current Plane by the given matrix.\r\n     */\r\n    public transform(transformation: DeepImmutable<Matrix>): Plane {\r\n        const invertedMatrix = Plane._TmpMatrix;\r\n        transformation.invertToRef(invertedMatrix);\r\n        const m = invertedMatrix.m;\r\n        const x = this.normal.x;\r\n        const y = this.normal.y;\r\n        const z = this.normal.z;\r\n        const d = this.d;\r\n\r\n        const normalX = x * m[0] + y * m[1] + z * m[2] + d * m[3];\r\n        const normalY = x * m[4] + y * m[5] + z * m[6] + d * m[7];\r\n        const normalZ = x * m[8] + y * m[9] + z * m[10] + d * m[11];\r\n        const finalD = x * m[12] + y * m[13] + z * m[14] + d * m[15];\r\n\r\n        return new Plane(normalX, normalY, normalZ, finalD);\r\n    }\r\n\r\n    /**\r\n     * Compute the dot product between the point and the plane normal\r\n     * @param point point to calculate the dot product with\r\n     * @returns the dot product (float) of the point coordinates and the plane normal.\r\n     */\r\n    public dotCoordinate(point: DeepImmutable<Vector3>): number {\r\n        return this.normal.x * point.x + this.normal.y * point.y + this.normal.z * point.z + this.d;\r\n    }\r\n\r\n    /**\r\n     * Updates the current Plane from the plane defined by the three given points.\r\n     * @param point1 one of the points used to construct the plane\r\n     * @param point2 one of the points used to construct the plane\r\n     * @param point3 one of the points used to construct the plane\r\n     * @returns the updated Plane.\r\n     */\r\n    public copyFromPoints(point1: DeepImmutable<Vector3>, point2: DeepImmutable<Vector3>, point3: DeepImmutable<Vector3>): Plane {\r\n        const x1 = point2.x - point1.x;\r\n        const y1 = point2.y - point1.y;\r\n        const z1 = point2.z - point1.z;\r\n        const x2 = point3.x - point1.x;\r\n        const y2 = point3.y - point1.y;\r\n        const z2 = point3.z - point1.z;\r\n        const yz = y1 * z2 - z1 * y2;\r\n        const xz = z1 * x2 - x1 * z2;\r\n        const xy = x1 * y2 - y1 * x2;\r\n        const pyth = Math.sqrt(yz * yz + xz * xz + xy * xy);\r\n        let invPyth;\r\n\r\n        if (pyth !== 0) {\r\n            invPyth = 1.0 / pyth;\r\n        } else {\r\n            invPyth = 0.0;\r\n        }\r\n\r\n        this.normal.x = yz * invPyth;\r\n        this.normal.y = xz * invPyth;\r\n        this.normal.z = xy * invPyth;\r\n        this.d = -(this.normal.x * point1.x + this.normal.y * point1.y + this.normal.z * point1.z);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Checks if the plane is facing a given direction (meaning if the plane's normal is pointing in the opposite direction of the given vector).\r\n     * Note that for this function to work as expected you should make sure that:\r\n     *   - direction and the plane normal are normalized\r\n     *   - epsilon is a number just bigger than -1, something like -0.99 for eg\r\n     * @param direction the direction to check if the plane is facing\r\n     * @param epsilon value the dot product is compared against (returns true if dot <= epsilon)\r\n     * @returns True if the plane is facing the given direction\r\n     */\r\n    public isFrontFacingTo(direction: DeepImmutable<Vector3>, epsilon: number): boolean {\r\n        const dot = Vector3.Dot(this.normal, direction);\r\n        return dot <= epsilon;\r\n    }\r\n\r\n    /**\r\n     * Calculates the distance to a point\r\n     * @param point point to calculate distance to\r\n     * @returns the signed distance (float) from the given point to the Plane.\r\n     */\r\n    public signedDistanceTo(point: DeepImmutable<Vector3>): number {\r\n        return Vector3.Dot(point, this.normal) + this.d;\r\n    }\r\n\r\n    // Statics\r\n    /**\r\n     * Creates a plane from an  array\r\n     * @param array the array to create a plane from\r\n     * @returns a new Plane from the given array.\r\n     */\r\n    static FromArray(array: DeepImmutable<ArrayLike<number>>): Plane {\r\n        return new Plane(array[0], array[1], array[2], array[3]);\r\n    }\r\n    /**\r\n     * Creates a plane from three points\r\n     * @param point1 point used to create the plane\r\n     * @param point2 point used to create the plane\r\n     * @param point3 point used to create the plane\r\n     * @returns a new Plane defined by the three given points.\r\n     */\r\n    static FromPoints(point1: DeepImmutable<Vector3>, point2: DeepImmutable<Vector3>, point3: DeepImmutable<Vector3>): Plane {\r\n        const result = new Plane(0.0, 0.0, 0.0, 0.0);\r\n        result.copyFromPoints(point1, point2, point3);\r\n        return result;\r\n    }\r\n    /**\r\n     * Creates a plane from an origin point and a normal\r\n     * @param origin origin of the plane to be constructed\r\n     * @param normal normal of the plane to be constructed\r\n     * @returns a new Plane the normal vector to this plane at the given origin point.\r\n     */\r\n    static FromPositionAndNormal(origin: DeepImmutable<Vector3>, normal: Vector3): Plane {\r\n        const plane = new Plane(0.0, 0.0, 0.0, 0.0);\r\n        return this.FromPositionAndNormalToRef(origin, normal, plane);\r\n    }\r\n\r\n    /**\r\n     * Updates the given Plane \"result\" from an origin point and a normal.\r\n     * @param origin origin of the plane to be constructed\r\n     * @param normal the normalized normals of the plane to be constructed\r\n     * @param result defines the Plane where to store the result\r\n     * @returns result input\r\n     */\r\n    static FromPositionAndNormalToRef<T extends Plane>(origin: DeepImmutable<Vector3>, normal: DeepImmutable<Vector3>, result: T): T {\r\n        result.normal.copyFrom(normal);\r\n        result.normal.normalize();\r\n        result.d = -origin.dot(result.normal);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Calculates the distance from a plane and a point\r\n     * @param origin origin of the plane to be constructed\r\n     * @param normal normal of the plane to be constructed\r\n     * @param point point to calculate distance to\r\n     * @returns the signed distance between the plane defined by the normal vector at the \"origin\"\" point and the given other point.\r\n     */\r\n    static SignedDistanceToPlaneFromPositionAndNormal(origin: DeepImmutable<Vector3>, normal: DeepImmutable<Vector3>, point: DeepImmutable<Vector3>): number {\r\n        const d = -(normal.x * origin.x + normal.y * origin.y + normal.z * origin.z);\r\n        return Vector3.Dot(point, normal) + d;\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": ["params"]
}

{
  "version": 3,
  "sources": ["../../../dev/core/src/Materials/effectRenderer.ts", "../../../dev/core/src/Misc/dumpTools.ts"],
  "sourcesContent": ["import type { Nullable } from \"../types\";\r\nimport type { AbstractEngine } from \"../Engines/abstractEngine\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport { Viewport } from \"../Maths/math.viewport\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport type { Observer } from \"../Misc/observable\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { Effect } from \"./effect\";\r\nimport type { DataBuffer } from \"../Buffers/dataBuffer\";\r\nimport { DrawWrapper } from \"./drawWrapper\";\r\nimport type { IRenderTargetTexture, RenderTargetWrapper } from \"../Engines/renderTargetWrapper\";\r\nimport type { ShaderLanguage } from \"./shaderLanguage\";\r\n\r\n// Prevents ES6 issue if not imported.\r\nimport \"../Shaders/postprocess.vertex\";\r\n\r\n/**\r\n * Effect Render Options\r\n */\r\nexport interface IEffectRendererOptions {\r\n    /**\r\n     * Defines the vertices positions.\r\n     */\r\n    positions?: number[];\r\n    /**\r\n     * Defines the indices.\r\n     */\r\n    indices?: number[];\r\n}\r\n\r\n// Fullscreen quad buffers by default.\r\nconst defaultOptions = {\r\n    positions: [1, 1, -1, 1, -1, -1, 1, -1],\r\n    indices: [0, 1, 2, 0, 2, 3],\r\n};\r\n\r\n/**\r\n * Helper class to render one or more effects.\r\n * You can access the previous rendering in your shader by declaring a sampler named textureSampler\r\n */\r\nexport class EffectRenderer {\r\n    /**\r\n     * The engine the effect renderer has been created for.\r\n     */\r\n    public readonly engine: AbstractEngine;\r\n\r\n    private _vertexBuffers: { [key: string]: VertexBuffer };\r\n    private _indexBuffer: DataBuffer;\r\n\r\n    private _fullscreenViewport = new Viewport(0, 0, 1, 1);\r\n    private _onContextRestoredObserver: Nullable<Observer<AbstractEngine>>;\r\n\r\n    private _savedStateDepthTest: boolean;\r\n    private _savedStateStencilTest: boolean;\r\n\r\n    /**\r\n     * Creates an effect renderer\r\n     * @param engine the engine to use for rendering\r\n     * @param options defines the options of the effect renderer\r\n     */\r\n    constructor(engine: AbstractEngine, options: IEffectRendererOptions = defaultOptions) {\r\n        const positions = options.positions ?? defaultOptions.positions;\r\n        const indices = options.indices ?? defaultOptions.indices;\r\n\r\n        this.engine = engine;\r\n        this._vertexBuffers = {\r\n            [VertexBuffer.PositionKind]: new VertexBuffer(engine, positions, VertexBuffer.PositionKind, false, false, 2),\r\n        };\r\n        this._indexBuffer = engine.createIndexBuffer(indices);\r\n\r\n        this._onContextRestoredObserver = engine.onContextRestoredObservable.add(() => {\r\n            this._indexBuffer = engine.createIndexBuffer(indices);\r\n\r\n            for (const key in this._vertexBuffers) {\r\n                const vertexBuffer = this._vertexBuffers[key];\r\n                vertexBuffer._rebuild();\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Sets the current viewport in normalized coordinates 0-1\r\n     * @param viewport Defines the viewport to set (defaults to 0 0 1 1)\r\n     */\r\n    public setViewport(viewport = this._fullscreenViewport): void {\r\n        this.engine.setViewport(viewport);\r\n    }\r\n\r\n    /**\r\n     * Binds the embedded attributes buffer to the effect.\r\n     * @param effect Defines the effect to bind the attributes for\r\n     */\r\n    public bindBuffers(effect: Effect): void {\r\n        this.engine.bindBuffers(this._vertexBuffers, this._indexBuffer, effect);\r\n    }\r\n\r\n    /**\r\n     * Sets the current effect wrapper to use during draw.\r\n     * The effect needs to be ready before calling this api.\r\n     * This also sets the default full screen position attribute.\r\n     * @param effectWrapper Defines the effect to draw with\r\n     */\r\n    public applyEffectWrapper(effectWrapper: EffectWrapper): void {\r\n        this.engine.setState(true);\r\n        this.engine.depthCullingState.depthTest = false;\r\n        this.engine.stencilState.stencilTest = false;\r\n        this.engine.enableEffect(effectWrapper._drawWrapper);\r\n        this.bindBuffers(effectWrapper.effect);\r\n        effectWrapper.onApplyObservable.notifyObservers({});\r\n    }\r\n\r\n    /**\r\n     * Saves engine states\r\n     */\r\n    public saveStates(): void {\r\n        this._savedStateDepthTest = this.engine.depthCullingState.depthTest;\r\n        this._savedStateStencilTest = this.engine.stencilState.stencilTest;\r\n    }\r\n\r\n    /**\r\n     * Restores engine states\r\n     */\r\n    public restoreStates(): void {\r\n        this.engine.depthCullingState.depthTest = this._savedStateDepthTest;\r\n        this.engine.stencilState.stencilTest = this._savedStateStencilTest;\r\n    }\r\n\r\n    /**\r\n     * Draws a full screen quad.\r\n     */\r\n    public draw(): void {\r\n        this.engine.drawElementsType(Constants.MATERIAL_TriangleFillMode, 0, 6);\r\n    }\r\n\r\n    private _isRenderTargetTexture(texture: RenderTargetWrapper | IRenderTargetTexture): texture is IRenderTargetTexture {\r\n        return (texture as IRenderTargetTexture).renderTarget !== undefined;\r\n    }\r\n\r\n    /**\r\n     * renders one or more effects to a specified texture\r\n     * @param effectWrapper the effect to renderer\r\n     * @param outputTexture texture to draw to, if null it will render to the screen.\r\n     */\r\n    public render(effectWrapper: EffectWrapper, outputTexture: Nullable<RenderTargetWrapper | IRenderTargetTexture> = null) {\r\n        // Ensure effect is ready\r\n        if (!effectWrapper.effect.isReady()) {\r\n            return;\r\n        }\r\n\r\n        this.saveStates();\r\n\r\n        // Reset state\r\n        this.setViewport();\r\n\r\n        const out = outputTexture === null ? null : this._isRenderTargetTexture(outputTexture) ? outputTexture.renderTarget! : outputTexture;\r\n\r\n        if (out) {\r\n            this.engine.bindFramebuffer(out);\r\n        }\r\n\r\n        this.applyEffectWrapper(effectWrapper);\r\n\r\n        this.draw();\r\n\r\n        if (out) {\r\n            this.engine.unBindFramebuffer(out);\r\n        }\r\n\r\n        this.restoreStates();\r\n    }\r\n\r\n    /**\r\n     * Disposes of the effect renderer\r\n     */\r\n    dispose() {\r\n        const vertexBuffer = this._vertexBuffers[VertexBuffer.PositionKind];\r\n        if (vertexBuffer) {\r\n            vertexBuffer.dispose();\r\n            delete this._vertexBuffers[VertexBuffer.PositionKind];\r\n        }\r\n\r\n        if (this._indexBuffer) {\r\n            this.engine._releaseBuffer(this._indexBuffer);\r\n        }\r\n\r\n        if (this._onContextRestoredObserver) {\r\n            this.engine.onContextRestoredObservable.remove(this._onContextRestoredObserver);\r\n            this._onContextRestoredObserver = null;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Options to create an EffectWrapper\r\n */\r\ninterface EffectWrapperCreationOptions {\r\n    /**\r\n     * Engine to use to create the effect\r\n     */\r\n    engine: AbstractEngine;\r\n    /**\r\n     * Fragment shader for the effect\r\n     */\r\n    fragmentShader: string;\r\n    /**\r\n     * Use the shader store instead of direct source code\r\n     */\r\n    useShaderStore?: boolean;\r\n    /**\r\n     * Vertex shader for the effect\r\n     */\r\n    vertexShader?: string;\r\n    /**\r\n     * Attributes to use in the shader\r\n     */\r\n    attributeNames?: Array<string>;\r\n    /**\r\n     * Uniforms to use in the shader\r\n     */\r\n    uniformNames?: Array<string>;\r\n    /**\r\n     * Texture sampler names to use in the shader\r\n     */\r\n    samplerNames?: Array<string>;\r\n    /**\r\n     * Defines to use in the shader\r\n     */\r\n    defines?: Array<string>;\r\n    /**\r\n     * Callback when effect is compiled\r\n     */\r\n    onCompiled?: Nullable<(effect: Effect) => void>;\r\n    /**\r\n     * The friendly name of the effect displayed in Spector.\r\n     */\r\n    name?: string;\r\n    /**\r\n     * The language the shader is written in (default: GLSL)\r\n     */\r\n    shaderLanguage?: ShaderLanguage;\r\n    /**\r\n     * Additional async code to run before preparing the effect\r\n     */\r\n    extraInitializationsAsync?: () => Promise<void>;\r\n}\r\n\r\n/**\r\n * Wraps an effect to be used for rendering\r\n */\r\nexport class EffectWrapper {\r\n    /**\r\n     * Event that is fired right before the effect is drawn (should be used to update uniforms)\r\n     */\r\n    public onApplyObservable = new Observable<{}>();\r\n    /**\r\n     * The underlying effect\r\n     */\r\n    public get effect(): Effect {\r\n        return this._drawWrapper.effect!;\r\n    }\r\n\r\n    public set effect(effect: Effect) {\r\n        this._drawWrapper.effect = effect;\r\n    }\r\n\r\n    /** @internal */\r\n    public _drawWrapper: DrawWrapper;\r\n\r\n    private _onContextRestoredObserver: Nullable<Observer<AbstractEngine>>;\r\n\r\n    /**\r\n     * Creates an effect to be renderer\r\n     * @param creationOptions options to create the effect\r\n     */\r\n    constructor(creationOptions: EffectWrapperCreationOptions) {\r\n        let shaderPath: any;\r\n        const uniformNames = creationOptions.uniformNames || [];\r\n\r\n        if (creationOptions.vertexShader) {\r\n            shaderPath = {\r\n                fragmentSource: creationOptions.fragmentShader,\r\n                vertexSource: creationOptions.vertexShader,\r\n                spectorName: creationOptions.name || \"effectWrapper\",\r\n            };\r\n        } else {\r\n            // Default scale to use in post process vertex shader.\r\n            uniformNames.push(\"scale\");\r\n\r\n            shaderPath = {\r\n                fragmentSource: creationOptions.fragmentShader,\r\n                vertex: \"postprocess\",\r\n                spectorName: creationOptions.name || \"effectWrapper\",\r\n            };\r\n\r\n            // Sets the default scale to identity for the post process vertex shader.\r\n            this.onApplyObservable.add(() => {\r\n                this.effect.setFloat2(\"scale\", 1, 1);\r\n            });\r\n        }\r\n\r\n        const defines = creationOptions.defines ? creationOptions.defines.join(\"\\n\") : \"\";\r\n        this._drawWrapper = new DrawWrapper(creationOptions.engine);\r\n\r\n        if (creationOptions.useShaderStore) {\r\n            shaderPath.fragment = shaderPath.fragmentSource;\r\n            if (!shaderPath.vertex) {\r\n                shaderPath.vertex = shaderPath.vertexSource;\r\n            }\r\n\r\n            delete shaderPath.fragmentSource;\r\n            delete shaderPath.vertexSource;\r\n\r\n            this.effect = creationOptions.engine.createEffect(\r\n                shaderPath,\r\n                creationOptions.attributeNames || [\"position\"],\r\n                uniformNames,\r\n                creationOptions.samplerNames,\r\n                defines,\r\n                undefined,\r\n                creationOptions.onCompiled,\r\n                undefined,\r\n                undefined,\r\n                creationOptions.shaderLanguage,\r\n                creationOptions.extraInitializationsAsync\r\n            );\r\n        } else {\r\n            this.effect = new Effect(\r\n                shaderPath,\r\n                creationOptions.attributeNames || [\"position\"],\r\n                uniformNames,\r\n                creationOptions.samplerNames,\r\n                creationOptions.engine,\r\n                defines,\r\n                undefined,\r\n                creationOptions.onCompiled,\r\n                undefined,\r\n                undefined,\r\n                undefined,\r\n                creationOptions.shaderLanguage,\r\n                creationOptions.extraInitializationsAsync\r\n            );\r\n\r\n            this._onContextRestoredObserver = creationOptions.engine.onContextRestoredObservable.add(() => {\r\n                this.effect._pipelineContext = null; // because _prepareEffect will try to dispose this pipeline before recreating it and that would lead to webgl errors\r\n                this.effect._prepareEffect();\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disposes of the effect wrapper\r\n     * @param _ignored kept for backward compatibility\r\n     */\r\n    public dispose(_ignored: boolean = false) {\r\n        if (this._onContextRestoredObserver) {\r\n            this.effect.getEngine().onContextRestoredObservable.remove(this._onContextRestoredObserver);\r\n            this._onContextRestoredObserver = null;\r\n        }\r\n        this.effect.dispose();\r\n    }\r\n}\r\n", "/* eslint-disable @typescript-eslint/no-unused-vars */\r\nimport { _WarnImport } from \"./devTools\";\r\n\r\nimport type { ThinEngine } from \"../Engines/thinEngine\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { EffectRenderer, EffectWrapper } from \"../Materials/effectRenderer\";\r\nimport { Tools } from \"./tools\";\r\nimport type { Nullable } from \"../types\";\r\nimport { Clamp } from \"../Maths/math.scalar.functions\";\r\nimport type { AbstractEngine } from \"../Engines/abstractEngine\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\n\r\ntype DumpToolsEngine = {\r\n    canvas: HTMLCanvasElement | OffscreenCanvas;\r\n    engine: ThinEngine;\r\n    renderer: EffectRenderer;\r\n    wrapper: EffectWrapper;\r\n};\r\n\r\nlet _dumpToolsEngine: Nullable<DumpToolsEngine>;\r\n\r\nlet _enginePromise: Promise<DumpToolsEngine> | null = null;\r\n\r\nasync function _CreateDumpRenderer(): Promise<DumpToolsEngine> {\r\n    if (!_enginePromise) {\r\n        _enginePromise = new Promise((resolve, reject) => {\r\n            let canvas: HTMLCanvasElement | OffscreenCanvas;\r\n            let engine: Nullable<ThinEngine> = null;\r\n            const options = {\r\n                preserveDrawingBuffer: true,\r\n                depth: false,\r\n                stencil: false,\r\n                alpha: true,\r\n                premultipliedAlpha: false,\r\n                antialias: false,\r\n                failIfMajorPerformanceCaveat: false,\r\n            };\r\n            import(\"../Engines/thinEngine\")\r\n                .then(({ ThinEngine: thinEngineClass }) => {\r\n                    try {\r\n                        canvas = new OffscreenCanvas(100, 100); // will be resized later\r\n                        engine = new thinEngineClass(canvas, false, options);\r\n                    } catch (e) {\r\n                        // The browser either does not support OffscreenCanvas or WebGL context in OffscreenCanvas, fallback on a regular canvas\r\n                        canvas = document.createElement(\"canvas\");\r\n                        engine = new thinEngineClass(canvas, false, options);\r\n                    }\r\n                    // remove this engine from the list of instances to avoid using it for other purposes\r\n                    EngineStore.Instances.pop();\r\n                    // However, make sure to dispose it when no other engines are left\r\n                    EngineStore.OnEnginesDisposedObservable.add((e) => {\r\n                        // guaranteed to run when no other instances are left\r\n                        // only dispose if it's not the current engine\r\n                        if (engine && e !== engine && !engine.isDisposed && EngineStore.Instances.length === 0) {\r\n                            // Dump the engine and the associated resources\r\n                            Dispose();\r\n                        }\r\n                    });\r\n                    engine.getCaps().parallelShaderCompile = undefined;\r\n                    const renderer = new EffectRenderer(engine);\r\n                    import(\"../Shaders/pass.fragment\").then(({ passPixelShader }) => {\r\n                        if (!engine) {\r\n                            reject(\"Engine is not defined\");\r\n                            return;\r\n                        }\r\n                        const wrapper = new EffectWrapper({\r\n                            engine,\r\n                            name: passPixelShader.name,\r\n                            fragmentShader: passPixelShader.shader,\r\n                            samplerNames: [\"textureSampler\"],\r\n                        });\r\n                        _dumpToolsEngine = {\r\n                            canvas,\r\n                            engine,\r\n                            renderer,\r\n                            wrapper,\r\n                        };\r\n                        resolve(_dumpToolsEngine);\r\n                    });\r\n                })\r\n                .catch(reject);\r\n        });\r\n    }\r\n    return await _enginePromise;\r\n}\r\n\r\n/**\r\n * Dumps the current bound framebuffer\r\n * @param width defines the rendering width\r\n * @param height defines the rendering height\r\n * @param engine defines the hosting engine\r\n * @param successCallback defines the callback triggered once the data are available\r\n * @param mimeType defines the mime type of the result\r\n * @param fileName defines the filename to download. If present, the result will automatically be downloaded\r\n * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.\r\n * @returns a void promise\r\n */\r\nexport async function DumpFramebuffer(\r\n    width: number,\r\n    height: number,\r\n    engine: AbstractEngine,\r\n    successCallback?: (data: string) => void,\r\n    mimeType = \"image/png\",\r\n    fileName?: string,\r\n    quality?: number\r\n) {\r\n    // Read the contents of the framebuffer\r\n    const bufferView = await engine.readPixels(0, 0, width, height);\r\n\r\n    const data = new Uint8Array(bufferView.buffer);\r\n\r\n    DumpData(width, height, data, successCallback as (data: string | ArrayBuffer) => void, mimeType, fileName, true, undefined, quality);\r\n}\r\n\r\n/**\r\n * Dumps an array buffer\r\n * @param width defines the rendering width\r\n * @param height defines the rendering height\r\n * @param data the data array\r\n * @param mimeType defines the mime type of the result\r\n * @param fileName defines the filename to download. If present, the result will automatically be downloaded\r\n * @param invertY true to invert the picture in the Y dimension\r\n * @param toArrayBuffer true to convert the data to an ArrayBuffer (encoded as `mimeType`) instead of a base64 string\r\n * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.\r\n * @returns a promise that resolve to the final data\r\n */\r\nexport function DumpDataAsync(\r\n    width: number,\r\n    height: number,\r\n    data: ArrayBufferView,\r\n    mimeType = \"image/png\",\r\n    fileName?: string,\r\n    invertY = false,\r\n    toArrayBuffer = false,\r\n    quality?: number\r\n): Promise<string | ArrayBuffer> {\r\n    return new Promise((resolve) => {\r\n        DumpData(width, height, data, (result) => resolve(result), mimeType, fileName, invertY, toArrayBuffer, quality);\r\n    });\r\n}\r\n\r\n/**\r\n * Dumps an array buffer\r\n * @param width defines the rendering width\r\n * @param height defines the rendering height\r\n * @param data the data array\r\n * @param successCallback defines the callback triggered once the data are available\r\n * @param mimeType defines the mime type of the result\r\n * @param fileName defines the filename to download. If present, the result will automatically be downloaded\r\n * @param invertY true to invert the picture in the Y dimension\r\n * @param toArrayBuffer true to convert the data to an ArrayBuffer (encoded as `mimeType`) instead of a base64 string\r\n * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.\r\n */\r\nexport function DumpData(\r\n    width: number,\r\n    height: number,\r\n    data: ArrayBufferView,\r\n    successCallback?: (data: string | ArrayBuffer) => void,\r\n    mimeType = \"image/png\",\r\n    fileName?: string,\r\n    invertY = false,\r\n    toArrayBuffer = false,\r\n    quality?: number\r\n): void {\r\n    _CreateDumpRenderer().then((renderer) => {\r\n        renderer.engine.setSize(width, height, true);\r\n\r\n        // Convert if data are float32\r\n        if (data instanceof Float32Array) {\r\n            const data2 = new Uint8Array(data.length);\r\n            let n = data.length;\r\n            while (n--) {\r\n                const v = data[n];\r\n                data2[n] = Math.round(Clamp(v) * 255);\r\n            }\r\n            data = data2;\r\n        }\r\n\r\n        // Create the image\r\n        const texture = renderer.engine.createRawTexture(data, width, height, Constants.TEXTUREFORMAT_RGBA, false, !invertY, Constants.TEXTURE_NEAREST_NEAREST);\r\n\r\n        renderer.renderer.setViewport();\r\n        renderer.renderer.applyEffectWrapper(renderer.wrapper);\r\n        renderer.wrapper.effect._bindTexture(\"textureSampler\", texture);\r\n        renderer.renderer.draw();\r\n\r\n        if (toArrayBuffer) {\r\n            Tools.ToBlob(\r\n                renderer.canvas,\r\n                (blob) => {\r\n                    const fileReader = new FileReader();\r\n                    fileReader.onload = (event: any) => {\r\n                        const arrayBuffer = event.target!.result as ArrayBuffer;\r\n                        if (successCallback) {\r\n                            successCallback(arrayBuffer);\r\n                        }\r\n                    };\r\n                    fileReader.readAsArrayBuffer(blob!);\r\n                },\r\n                mimeType,\r\n                quality\r\n            );\r\n        } else {\r\n            Tools.EncodeScreenshotCanvasData(renderer.canvas, successCallback, mimeType, fileName, quality);\r\n        }\r\n\r\n        texture.dispose();\r\n    });\r\n}\r\n\r\n/**\r\n * Dispose the dump tools associated resources\r\n */\r\nexport function Dispose() {\r\n    if (_dumpToolsEngine) {\r\n        _dumpToolsEngine.wrapper.dispose();\r\n        _dumpToolsEngine.renderer.dispose();\r\n        _dumpToolsEngine.engine.dispose();\r\n    } else {\r\n        // in cases where the engine is not yet created, we need to wait for it to dispose it\r\n        _enginePromise?.then((dumpToolsEngine) => {\r\n            dumpToolsEngine.wrapper.dispose();\r\n            dumpToolsEngine.renderer.dispose();\r\n            dumpToolsEngine.engine.dispose();\r\n        });\r\n    }\r\n    _enginePromise = null;\r\n    _dumpToolsEngine = null;\r\n}\r\n\r\n/**\r\n * Object containing a set of static utilities functions to dump data from a canvas\r\n * @deprecated use functions\r\n */\r\nexport const DumpTools = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    DumpData,\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    DumpDataAsync,\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    DumpFramebuffer,\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    Dispose,\r\n};\r\n\r\n/**\r\n * This will be executed automatically for UMD and es5.\r\n * If esm dev wants the side effects to execute they will have to run it manually\r\n * Once we build native modules those need to be exported.\r\n * @internal\r\n */\r\nconst initSideEffects = () => {\r\n    // References the dependencies.\r\n    Tools.DumpData = DumpData;\r\n    Tools.DumpDataAsync = DumpDataAsync;\r\n    Tools.DumpFramebuffer = DumpFramebuffer;\r\n};\r\n\r\ninitSideEffects();\r\n"],
  "mappings": "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",
  "names": []
}

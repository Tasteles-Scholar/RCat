{
  "version": 3,
  "sources": ["../../../dev/core/src/Events/pointerEvents.ts", "../../../dev/core/src/Events/keyboardEvents.ts", "../../../dev/core/src/Misc/perfCounter.ts", "../../../dev/core/src/Materials/uniformBuffer.ts", "../../../dev/core/src/Collisions/pickingInfo.ts", "../../../dev/core/src/sceneComponent.ts", "../../../dev/core/src/Lights/lightConstants.ts"],
  "sourcesContent": ["import type { Nullable } from \"../types\";\r\nimport { Vector2 } from \"../Maths/math.vector\";\r\nimport type { PickingInfo } from \"../Collisions/pickingInfo\";\r\nimport type { IMouseEvent, IPointerEvent } from \"./deviceInputEvents\";\r\nimport type { InputManager } from \"../Inputs/scene.inputManager\";\r\n\r\nimport type { Ray } from \"../Culling/ray\";\r\n\r\n/**\r\n * Gather the list of pointer event types as constants.\r\n */\r\nexport class PointerEventTypes {\r\n    /**\r\n     * The pointerdown event is fired when a pointer becomes active. For mouse, it is fired when the device transitions from no buttons depressed to at least one button depressed. For touch, it is fired when physical contact is made with the digitizer. For pen, it is fired when the stylus makes physical contact with the digitizer.\r\n     */\r\n    public static readonly POINTERDOWN = 0x01;\r\n    /**\r\n     * The pointerup event is fired when a pointer is no longer active.\r\n     */\r\n    public static readonly POINTERUP = 0x02;\r\n    /**\r\n     * The pointermove event is fired when a pointer changes coordinates.\r\n     */\r\n    public static readonly POINTERMOVE = 0x04;\r\n    /**\r\n     * The pointerwheel event is fired when a mouse wheel has been rotated.\r\n     */\r\n    public static readonly POINTERWHEEL = 0x08;\r\n    /**\r\n     * The pointerpick event is fired when a mesh or sprite has been picked by the pointer.\r\n     */\r\n    public static readonly POINTERPICK = 0x10;\r\n    /**\r\n     * The pointertap event is fired when a the object has been touched and released without drag.\r\n     */\r\n    public static readonly POINTERTAP = 0x20;\r\n    /**\r\n     * The pointerdoubletap event is fired when a the object has been touched and released twice without drag.\r\n     */\r\n    public static readonly POINTERDOUBLETAP = 0x40;\r\n}\r\n\r\n/**\r\n * Base class of pointer info types.\r\n */\r\nexport class PointerInfoBase {\r\n    /**\r\n     * Instantiates the base class of pointers info.\r\n     * @param type Defines the type of event (PointerEventTypes)\r\n     * @param event Defines the related dom event\r\n     */\r\n    constructor(\r\n        /**\r\n         * Defines the type of event (PointerEventTypes)\r\n         */\r\n        public type: number,\r\n        /**\r\n         * Defines the related dom event\r\n         */\r\n        public event: IMouseEvent\r\n    ) {}\r\n}\r\n\r\n/**\r\n * This class is used to store pointer related info for the onPrePointerObservable event.\r\n * Set the skipOnPointerObservable property to true if you want the engine to stop any process after this event is triggered, even not calling onPointerObservable\r\n */\r\nexport class PointerInfoPre extends PointerInfoBase {\r\n    /**\r\n     * Ray from a pointer if available (eg. 6dof controller)\r\n     */\r\n    public ray: Nullable<Ray> = null;\r\n\r\n    /**\r\n     * Defines picking info coming from a near interaction (proximity instead of ray-based picking)\r\n     */\r\n    public nearInteractionPickingInfo: Nullable<PickingInfo>;\r\n\r\n    /**\r\n     * The original picking info that was used to trigger the pointer event\r\n     */\r\n    public originalPickingInfo: Nullable<PickingInfo> = null;\r\n\r\n    /**\r\n     * Defines the local position of the pointer on the canvas.\r\n     */\r\n    public localPosition: Vector2;\r\n\r\n    /**\r\n     * Defines whether the engine should skip the next OnPointerObservable associated to this pre.\r\n     */\r\n    public skipOnPointerObservable: boolean;\r\n\r\n    /**\r\n     * Instantiates a PointerInfoPre to store pointer related info to the onPrePointerObservable event.\r\n     * @param type Defines the type of event (PointerEventTypes)\r\n     * @param event Defines the related dom event\r\n     * @param localX Defines the local x coordinates of the pointer when the event occured\r\n     * @param localY Defines the local y coordinates of the pointer when the event occured\r\n     */\r\n    constructor(type: number, event: IMouseEvent, localX: number, localY: number) {\r\n        super(type, event);\r\n        this.skipOnPointerObservable = false;\r\n        this.localPosition = new Vector2(localX, localY);\r\n    }\r\n}\r\n\r\n/**\r\n * This type contains all the data related to a pointer event in Babylon.js.\r\n * The event member is an instance of PointerEvent for all types except PointerWheel and is of type MouseWheelEvent when type equals PointerWheel. The different event types can be found in the PointerEventTypes class.\r\n */\r\nexport class PointerInfo extends PointerInfoBase {\r\n    private _pickInfo: Nullable<PickingInfo>;\r\n    private _inputManager: Nullable<InputManager>;\r\n\r\n    /**\r\n     * Defines the picking info associated with this PointerInfo object (if applicable)\r\n     */\r\n    public get pickInfo(): Nullable<PickingInfo> {\r\n        if (!this._pickInfo) {\r\n            this._generatePickInfo();\r\n        }\r\n\r\n        return this._pickInfo;\r\n    }\r\n    /**\r\n     * Instantiates a PointerInfo to store pointer related info to the onPointerObservable event.\r\n     * @param type Defines the type of event (PointerEventTypes)\r\n     * @param event Defines the related dom event\r\n     * @param pickInfo Defines the picking info associated to the info (if any)\r\n     * @param inputManager Defines the InputManager to use if there is no pickInfo\r\n     */\r\n    constructor(type: number, event: IMouseEvent, pickInfo: Nullable<PickingInfo>, inputManager: Nullable<InputManager> = null) {\r\n        super(type, event);\r\n        this._pickInfo = pickInfo;\r\n        this._inputManager = inputManager;\r\n    }\r\n\r\n    /**\r\n     * Generates the picking info if needed\r\n     */\r\n    /** @internal */\r\n    public _generatePickInfo(): void {\r\n        if (this._inputManager) {\r\n            this._pickInfo = this._inputManager._pickMove(this.event as IPointerEvent);\r\n            this._inputManager._setRayOnPointerInfo(this._pickInfo, this.event);\r\n            this._inputManager = null;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Data relating to a touch event on the screen.\r\n */\r\nexport interface PointerTouch {\r\n    /**\r\n     * X coordinate of touch.\r\n     */\r\n    x: number;\r\n    /**\r\n     * Y coordinate of touch.\r\n     */\r\n    y: number;\r\n    /**\r\n     * Id of touch. Unique for each finger.\r\n     */\r\n    pointerId: number;\r\n    /**\r\n     * Event type passed from DOM.\r\n     */\r\n    type: any;\r\n}\r\n", "import type { IKeyboardEvent } from \"./deviceInputEvents\";\r\n\r\n/**\r\n * Gather the list of keyboard event types as constants.\r\n */\r\nexport class KeyboardEventTypes {\r\n    /**\r\n     * The keydown event is fired when a key becomes active (pressed).\r\n     */\r\n    public static readonly KEYDOWN = 0x01;\r\n    /**\r\n     * The keyup event is fired when a key has been released.\r\n     */\r\n    public static readonly KEYUP = 0x02;\r\n}\r\n\r\n/**\r\n * This class is used to store keyboard related info for the onKeyboardObservable event.\r\n */\r\nexport class KeyboardInfo {\r\n    /**\r\n     * Instantiates a new keyboard info.\r\n     * This class is used to store keyboard related info for the onKeyboardObservable event.\r\n     * @param type Defines the type of event (KeyboardEventTypes)\r\n     * @param event Defines the related dom event\r\n     */\r\n    constructor(\r\n        /**\r\n         * Defines the type of event (KeyboardEventTypes)\r\n         */\r\n        public type: number,\r\n        /**\r\n         * Defines the related dom event\r\n         */\r\n        public event: IKeyboardEvent\r\n    ) {}\r\n}\r\n\r\n/**\r\n * This class is used to store keyboard related info for the onPreKeyboardObservable event.\r\n * Set the skipOnKeyboardObservable property to true if you want the engine to stop any process after this event is triggered, even not calling onKeyboardObservable\r\n */\r\nexport class KeyboardInfoPre extends KeyboardInfo {\r\n    /**\r\n     * Defines whether the engine should skip the next onKeyboardObservable associated to this pre.\r\n     */\r\n    public skipOnKeyboardObservable: boolean;\r\n\r\n    /**\r\n     * Defines whether the engine should skip the next onKeyboardObservable associated to this pre.\r\n     * @deprecated use skipOnKeyboardObservable property instead\r\n     */\r\n    public get skipOnPointerObservable() {\r\n        return this.skipOnKeyboardObservable;\r\n    }\r\n    public set skipOnPointerObservable(value) {\r\n        this.skipOnKeyboardObservable = value;\r\n    }\r\n\r\n    /**\r\n     * Instantiates a new keyboard pre info.\r\n     * This class is used to store keyboard related info for the onPreKeyboardObservable event.\r\n     * @param type Defines the type of event (KeyboardEventTypes)\r\n     * @param event Defines the related dom event\r\n     */\r\n    constructor(\r\n        /**\r\n         * Defines the type of event (KeyboardEventTypes)\r\n         */\r\n        public override type: number,\r\n        /**\r\n         * Defines the related dom event\r\n         */\r\n        public override event: IKeyboardEvent\r\n    ) {\r\n        super(type, event);\r\n        this.skipOnKeyboardObservable = false;\r\n    }\r\n}\r\n", "import { PrecisionDate } from \"./precisionDate\";\r\n\r\n/**\r\n * This class is used to track a performance counter which is number based.\r\n * The user has access to many properties which give statistics of different nature.\r\n *\r\n * The implementer can track two kinds of Performance Counter: time and count.\r\n * For time you can optionally call fetchNewFrame() to notify the start of a new frame to monitor, then call beginMonitoring() to start and endMonitoring() to record the lapsed time. endMonitoring takes a newFrame parameter for you to specify if the monitored time should be set for a new frame or accumulated to the current frame being monitored.\r\n * For count you first have to call fetchNewFrame() to notify the start of a new frame to monitor, then call addCount() how many time required to increment the count value you monitor.\r\n */\r\nexport class PerfCounter {\r\n    /**\r\n     * Gets or sets a global boolean to turn on and off all the counters\r\n     */\r\n    public static Enabled = true;\r\n\r\n    /**\r\n     * Returns the smallest value ever\r\n     */\r\n    public get min(): number {\r\n        return this._min;\r\n    }\r\n\r\n    /**\r\n     * Returns the biggest value ever\r\n     */\r\n    public get max(): number {\r\n        return this._max;\r\n    }\r\n\r\n    /**\r\n     * Returns the average value since the performance counter is running\r\n     */\r\n    public get average(): number {\r\n        return this._average;\r\n    }\r\n\r\n    /**\r\n     * Returns the average value of the last second the counter was monitored\r\n     */\r\n    public get lastSecAverage(): number {\r\n        return this._lastSecAverage;\r\n    }\r\n\r\n    /**\r\n     * Returns the current value\r\n     */\r\n    public get current(): number {\r\n        return this._current;\r\n    }\r\n\r\n    /**\r\n     * Gets the accumulated total\r\n     */\r\n    public get total(): number {\r\n        return this._totalAccumulated;\r\n    }\r\n\r\n    /**\r\n     * Gets the total value count\r\n     */\r\n    public get count(): number {\r\n        return this._totalValueCount;\r\n    }\r\n\r\n    /**\r\n     * Creates a new counter\r\n     */\r\n    constructor() {\r\n        this._startMonitoringTime = 0;\r\n        this._min = 0;\r\n        this._max = 0;\r\n        this._average = 0;\r\n        this._lastSecAverage = 0;\r\n        this._current = 0;\r\n        this._totalValueCount = 0;\r\n        this._totalAccumulated = 0;\r\n        this._lastSecAccumulated = 0;\r\n        this._lastSecTime = 0;\r\n        this._lastSecValueCount = 0;\r\n    }\r\n\r\n    /**\r\n     * Call this method to start monitoring a new frame.\r\n     * This scenario is typically used when you accumulate monitoring time many times for a single frame, you call this method at the start of the frame, then beginMonitoring to start recording and endMonitoring(false) to accumulated the recorded time to the PerfCounter or addCount() to accumulate a monitored count.\r\n     */\r\n    public fetchNewFrame() {\r\n        this._totalValueCount++;\r\n        this._current = 0;\r\n        this._lastSecValueCount++;\r\n    }\r\n\r\n    /**\r\n     * Call this method to monitor a count of something (e.g. mesh drawn in viewport count)\r\n     * @param newCount the count value to add to the monitored count\r\n     * @param fetchResult true when it's the last time in the frame you add to the counter and you wish to update the statistics properties (min/max/average), false if you only want to update statistics.\r\n     */\r\n    public addCount(newCount: number, fetchResult: boolean) {\r\n        if (!PerfCounter.Enabled) {\r\n            return;\r\n        }\r\n        this._current += newCount;\r\n        if (fetchResult) {\r\n            this._fetchResult();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Start monitoring this performance counter\r\n     */\r\n    public beginMonitoring() {\r\n        if (!PerfCounter.Enabled) {\r\n            return;\r\n        }\r\n        this._startMonitoringTime = PrecisionDate.Now;\r\n    }\r\n\r\n    /**\r\n     * Compute the time lapsed since the previous beginMonitoring() call.\r\n     * @param newFrame true by default to fetch the result and monitor a new frame, if false the time monitored will be added to the current frame counter\r\n     */\r\n    public endMonitoring(newFrame: boolean = true) {\r\n        if (!PerfCounter.Enabled) {\r\n            return;\r\n        }\r\n\r\n        if (newFrame) {\r\n            this.fetchNewFrame();\r\n        }\r\n\r\n        const currentTime = PrecisionDate.Now;\r\n        this._current = currentTime - this._startMonitoringTime;\r\n\r\n        if (newFrame) {\r\n            this._fetchResult();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Call this method to end the monitoring of a frame.\r\n     * This scenario is typically used when you accumulate monitoring time many times for a single frame, you call this method at the end of the frame, after beginMonitoring to start recording and endMonitoring(false) to accumulated the recorded time to the PerfCounter or addCount() to accumulate a monitored count.\r\n     */\r\n    public endFrame() {\r\n        this._fetchResult();\r\n    }\r\n\r\n    /** @internal */\r\n    public _fetchResult() {\r\n        this._totalAccumulated += this._current;\r\n        this._lastSecAccumulated += this._current;\r\n\r\n        // Min/Max update\r\n        this._min = Math.min(this._min, this._current);\r\n        this._max = Math.max(this._max, this._current);\r\n        this._average = this._totalAccumulated / this._totalValueCount;\r\n\r\n        // Reset last sec?\r\n        const now = PrecisionDate.Now;\r\n        if (now - this._lastSecTime > 1000) {\r\n            this._lastSecAverage = this._lastSecAccumulated / this._lastSecValueCount;\r\n            this._lastSecTime = now;\r\n            this._lastSecAccumulated = 0;\r\n            this._lastSecValueCount = 0;\r\n        }\r\n    }\r\n\r\n    private _startMonitoringTime: number;\r\n    private _min: number;\r\n    private _max: number;\r\n    private _average: number;\r\n    private _current: number;\r\n    private _totalValueCount: number;\r\n    private _totalAccumulated: number;\r\n    private _lastSecAverage: number;\r\n    private _lastSecAccumulated: number;\r\n    private _lastSecTime: number;\r\n    private _lastSecValueCount: number;\r\n}\r\n", "import { Logger } from \"../Misc/logger\";\r\nimport type { Nullable, FloatArray } from \"../types\";\r\nimport type { IMatrixLike, IVector3Like, IVector4Like, IColor3Like, IColor4Like } from \"../Maths/math.like\";\r\nimport type { Effect } from \"./effect\";\r\nimport type { ThinTexture } from \"../Materials/Textures/thinTexture\";\r\nimport type { DataBuffer } from \"../Buffers/dataBuffer\";\r\nimport type { InternalTexture } from \"./Textures/internalTexture\";\r\nimport { Tools } from \"../Misc/tools\";\r\nimport type { AbstractEngine } from \"core/Engines/abstractEngine\";\r\n\r\n/**\r\n * Uniform buffer objects.\r\n *\r\n * Handles blocks of uniform on the GPU.\r\n *\r\n * If WebGL 2 is not available, this class falls back on traditional setUniformXXX calls.\r\n *\r\n * For more information, please refer to :\r\n * https://www.khronos.org/opengl/wiki/Uniform_Buffer_Object\r\n */\r\nexport class UniformBuffer {\r\n    /** @internal */\r\n    public static _UpdatedUbosInFrame: { [name: string]: number } = {};\r\n\r\n    private _engine: AbstractEngine;\r\n    private _buffer: Nullable<DataBuffer>;\r\n    private _buffers: Array<[DataBuffer, Float32Array | undefined]>;\r\n    private _bufferIndex: number;\r\n    private _createBufferOnWrite: boolean;\r\n    private _data: number[];\r\n    private _bufferData: Float32Array;\r\n    private _dynamic?: boolean;\r\n    private _uniformLocations: { [key: string]: number };\r\n    private _uniformSizes: { [key: string]: number };\r\n    private _uniformArraySizes: { [key: string]: { strideSize: number; arraySize: number } };\r\n    private _uniformLocationPointer: number;\r\n    private _needSync: boolean;\r\n    private _noUBO: boolean;\r\n    private _currentEffect: Effect;\r\n    private _currentEffectName: string;\r\n    private _name: string;\r\n    private _currentFrameId: number;\r\n\r\n    // Pool for avoiding memory leaks\r\n    private static _MAX_UNIFORM_SIZE = 256;\r\n    private static _TempBuffer = new Float32Array(UniformBuffer._MAX_UNIFORM_SIZE);\r\n    private static _TempBufferInt32View = new Int32Array(UniformBuffer._TempBuffer.buffer);\r\n    private static _TempBufferUInt32View = new Uint32Array(UniformBuffer._TempBuffer.buffer);\r\n\r\n    /**\r\n     * Lambda to Update a 3x3 Matrix in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateMatrix3x3: (name: string, matrix: Float32Array) => void;\r\n\r\n    /**\r\n     * Lambda to Update a 2x2 Matrix in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateMatrix2x2: (name: string, matrix: Float32Array) => void;\r\n\r\n    /**\r\n     * Lambda to Update a single float in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateFloat: (name: string, x: number) => void;\r\n\r\n    /**\r\n     * Lambda to Update a vec2 of float in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateFloat2: (name: string, x: number, y: number, suffix?: string) => void;\r\n\r\n    /**\r\n     * Lambda to Update a vec3 of float in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateFloat3: (name: string, x: number, y: number, z: number, suffix?: string) => void;\r\n\r\n    /**\r\n     * Lambda to Update a vec4 of float in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateFloat4: (name: string, x: number, y: number, z: number, w: number, suffix?: string) => void;\r\n\r\n    /**\r\n     * Lambda to Update an array of float in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateFloatArray: (name: string, array: Float32Array) => void;\r\n\r\n    /**\r\n     * Lambda to Update an array of number in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateArray: (name: string, array: number[]) => void;\r\n\r\n    /**\r\n     * Lambda to Update an array of number in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateIntArray: (name: string, array: Int32Array) => void;\r\n\r\n    /**\r\n     * Lambda to Update an array of number in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateUIntArray: (name: string, array: Uint32Array) => void;\r\n\r\n    /**\r\n     * Lambda to Update a 4x4 Matrix in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateMatrix: (name: string, mat: IMatrixLike) => void;\r\n\r\n    /**\r\n     * Lambda to Update an array of 4x4 Matrix in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateMatrices: (name: string, mat: Float32Array) => void;\r\n\r\n    /**\r\n     * Lambda to Update vec3 of float from a Vector in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateVector3: (name: string, vector: IVector3Like) => void;\r\n\r\n    /**\r\n     * Lambda to Update vec4 of float from a Vector in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateVector4: (name: string, vector: IVector4Like) => void;\r\n\r\n    /**\r\n     * Lambda to Update vec3 of float from a Color in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateColor3: (name: string, color: IColor3Like, suffix?: string) => void;\r\n\r\n    /**\r\n     * Lambda to Update vec4 of float from a Color in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateColor4: (name: string, color: IColor3Like, alpha: number, suffix?: string) => void;\r\n\r\n    /**\r\n     * Lambda to Update vec4 of float from a Color in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateDirectColor4: (name: string, color: IColor4Like, suffix?: string) => void;\r\n\r\n    /**\r\n     * Lambda to Update a int a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateInt: (name: string, x: number, suffix?: string) => void;\r\n\r\n    /**\r\n     * Lambda to Update a vec2 of int in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateInt2: (name: string, x: number, y: number, suffix?: string) => void;\r\n\r\n    /**\r\n     * Lambda to Update a vec3 of int in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateInt3: (name: string, x: number, y: number, z: number, suffix?: string) => void;\r\n\r\n    /**\r\n     * Lambda to Update a vec4 of int in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateInt4: (name: string, x: number, y: number, z: number, w: number, suffix?: string) => void;\r\n\r\n    /**\r\n     * Lambda to Update a unsigned int a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateUInt: (name: string, x: number, suffix?: string) => void;\r\n\r\n    /**\r\n     * Lambda to Update a vec2 of unsigned int in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateUInt2: (name: string, x: number, y: number, suffix?: string) => void;\r\n\r\n    /**\r\n     * Lambda to Update a vec3 of unsigned int in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateUInt3: (name: string, x: number, y: number, z: number, suffix?: string) => void;\r\n\r\n    /**\r\n     * Lambda to Update a vec4 of unsigned int in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateUInt4: (name: string, x: number, y: number, z: number, w: number, suffix?: string) => void;\r\n\r\n    /**\r\n     * Instantiates a new Uniform buffer objects.\r\n     *\r\n     * Handles blocks of uniform on the GPU.\r\n     *\r\n     * If WebGL 2 is not available, this class falls back on traditional setUniformXXX calls.\r\n     *\r\n     * For more information, please refer to :\r\n     * @see https://www.khronos.org/opengl/wiki/Uniform_Buffer_Object\r\n     * @param engine Define the engine the buffer is associated with\r\n     * @param data Define the data contained in the buffer\r\n     * @param dynamic Define if the buffer is updatable\r\n     * @param name to assign to the buffer (debugging purpose)\r\n     * @param forceNoUniformBuffer define that this object must not rely on UBO objects\r\n     */\r\n    constructor(engine: AbstractEngine, data?: number[], dynamic?: boolean, name?: string, forceNoUniformBuffer = false) {\r\n        this._engine = engine;\r\n        this._noUBO = !engine.supportsUniformBuffers || forceNoUniformBuffer;\r\n        this._dynamic = dynamic;\r\n        this._name = name ?? \"no-name\";\r\n\r\n        this._data = data || [];\r\n\r\n        this._uniformLocations = {};\r\n        this._uniformSizes = {};\r\n        this._uniformArraySizes = {};\r\n        this._uniformLocationPointer = 0;\r\n        this._needSync = false;\r\n\r\n        if (this._engine._features.trackUbosInFrame) {\r\n            this._buffers = [];\r\n            this._bufferIndex = -1;\r\n            this._createBufferOnWrite = false;\r\n            this._currentFrameId = 0;\r\n        }\r\n\r\n        if (this._noUBO) {\r\n            this.updateMatrix3x3 = this._updateMatrix3x3ForEffect;\r\n            this.updateMatrix2x2 = this._updateMatrix2x2ForEffect;\r\n            this.updateFloat = this._updateFloatForEffect;\r\n            this.updateFloat2 = this._updateFloat2ForEffect;\r\n            this.updateFloat3 = this._updateFloat3ForEffect;\r\n            this.updateFloat4 = this._updateFloat4ForEffect;\r\n            this.updateFloatArray = this._updateFloatArrayForEffect;\r\n            this.updateArray = this._updateArrayForEffect;\r\n            this.updateIntArray = this._updateIntArrayForEffect;\r\n            this.updateUIntArray = this._updateUIntArrayForEffect;\r\n            this.updateMatrix = this._updateMatrixForEffect;\r\n            this.updateMatrices = this._updateMatricesForEffect;\r\n            this.updateVector3 = this._updateVector3ForEffect;\r\n            this.updateVector4 = this._updateVector4ForEffect;\r\n            this.updateColor3 = this._updateColor3ForEffect;\r\n            this.updateColor4 = this._updateColor4ForEffect;\r\n            this.updateDirectColor4 = this._updateDirectColor4ForEffect;\r\n            this.updateInt = this._updateIntForEffect;\r\n            this.updateInt2 = this._updateInt2ForEffect;\r\n            this.updateInt3 = this._updateInt3ForEffect;\r\n            this.updateInt4 = this._updateInt4ForEffect;\r\n            this.updateUInt = this._updateUIntForEffect;\r\n            this.updateUInt2 = this._updateUInt2ForEffect;\r\n            this.updateUInt3 = this._updateUInt3ForEffect;\r\n            this.updateUInt4 = this._updateUInt4ForEffect;\r\n        } else {\r\n            this._engine._uniformBuffers.push(this);\r\n\r\n            this.updateMatrix3x3 = this._updateMatrix3x3ForUniform;\r\n            this.updateMatrix2x2 = this._updateMatrix2x2ForUniform;\r\n            this.updateFloat = this._updateFloatForUniform;\r\n            this.updateFloat2 = this._updateFloat2ForUniform;\r\n            this.updateFloat3 = this._updateFloat3ForUniform;\r\n            this.updateFloat4 = this._updateFloat4ForUniform;\r\n            this.updateFloatArray = this._updateFloatArrayForUniform;\r\n            this.updateArray = this._updateArrayForUniform;\r\n            this.updateIntArray = this._updateIntArrayForUniform;\r\n            this.updateUIntArray = this._updateUIntArrayForUniform;\r\n            this.updateMatrix = this._updateMatrixForUniform;\r\n            this.updateMatrices = this._updateMatricesForUniform;\r\n            this.updateVector3 = this._updateVector3ForUniform;\r\n            this.updateVector4 = this._updateVector4ForUniform;\r\n            this.updateColor3 = this._updateColor3ForUniform;\r\n            this.updateColor4 = this._updateColor4ForUniform;\r\n            this.updateDirectColor4 = this._updateDirectColor4ForUniform;\r\n            this.updateInt = this._updateIntForUniform;\r\n            this.updateInt2 = this._updateInt2ForUniform;\r\n            this.updateInt3 = this._updateInt3ForUniform;\r\n            this.updateInt4 = this._updateInt4ForUniform;\r\n            this.updateUInt = this._updateUIntForUniform;\r\n            this.updateUInt2 = this._updateUInt2ForUniform;\r\n            this.updateUInt3 = this._updateUInt3ForUniform;\r\n            this.updateUInt4 = this._updateUInt4ForUniform;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Indicates if the buffer is using the WebGL2 UBO implementation,\r\n     * or just falling back on setUniformXXX calls.\r\n     */\r\n    public get useUbo(): boolean {\r\n        return !this._noUBO;\r\n    }\r\n\r\n    /**\r\n     * Indicates if the WebGL underlying uniform buffer is in sync\r\n     * with the javascript cache data.\r\n     */\r\n    public get isSync(): boolean {\r\n        return !this._needSync;\r\n    }\r\n\r\n    /**\r\n     * Indicates if the WebGL underlying uniform buffer is dynamic.\r\n     * Also, a dynamic UniformBuffer will disable cache verification and always\r\n     * update the underlying WebGL uniform buffer to the GPU.\r\n     * @returns if Dynamic, otherwise false\r\n     */\r\n    public isDynamic(): boolean {\r\n        return this._dynamic !== undefined;\r\n    }\r\n\r\n    /**\r\n     * The data cache on JS side.\r\n     * @returns the underlying data as a float array\r\n     */\r\n    public getData(): Float32Array {\r\n        return this._bufferData;\r\n    }\r\n\r\n    /**\r\n     * The underlying WebGL Uniform buffer.\r\n     * @returns the webgl buffer\r\n     */\r\n    public getBuffer(): Nullable<DataBuffer> {\r\n        return this._buffer;\r\n    }\r\n\r\n    /**\r\n     * std140 layout specifies how to align data within an UBO structure.\r\n     * See https://khronos.org/registry/OpenGL/specs/gl/glspec45.core.pdf#page=159\r\n     * for specs.\r\n     * @param size\r\n     */\r\n    private _fillAlignment(size: number) {\r\n        // This code has been simplified because we only use floats, vectors of 1, 2, 3, 4 components\r\n        // and 4x4 matrices\r\n        // TODO : change if other types are used\r\n\r\n        let alignment;\r\n        if (size <= 2) {\r\n            alignment = size;\r\n        } else {\r\n            alignment = 4;\r\n        }\r\n\r\n        if (this._uniformLocationPointer % alignment !== 0) {\r\n            const oldPointer = this._uniformLocationPointer;\r\n            this._uniformLocationPointer += alignment - (this._uniformLocationPointer % alignment);\r\n            const diff = this._uniformLocationPointer - oldPointer;\r\n\r\n            for (let i = 0; i < diff; i++) {\r\n                this._data.push(0);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds an uniform in the buffer.\r\n     * Warning : the subsequents calls of this function must be in the same order as declared in the shader\r\n     * for the layout to be correct ! The addUniform function only handles types like float, vec2, vec3, vec4, mat4,\r\n     * meaning size=1,2,3,4 or 16. It does not handle struct types.\r\n     * @param name Name of the uniform, as used in the uniform block in the shader.\r\n     * @param size Data size, or data directly.\r\n     * @param arraySize The number of elements in the array, 0 if not an array.\r\n     */\r\n    public addUniform(name: string, size: number | number[], arraySize = 0) {\r\n        if (this._noUBO) {\r\n            return;\r\n        }\r\n\r\n        if (this._uniformLocations[name] !== undefined) {\r\n            // Already existing uniform\r\n            return;\r\n        }\r\n        // This function must be called in the order of the shader layout !\r\n        // size can be the size of the uniform, or data directly\r\n        let data;\r\n\r\n        // std140 FTW...\r\n        if (arraySize > 0) {\r\n            if (size instanceof Array) {\r\n                // eslint-disable-next-line no-throw-literal\r\n                throw \"addUniform should not be use with Array in UBO: \" + name;\r\n            }\r\n\r\n            this._fillAlignment(4);\r\n\r\n            this._uniformArraySizes[name] = { strideSize: size, arraySize };\r\n            if (size == 16) {\r\n                size = size * arraySize;\r\n            } else {\r\n                const perElementPadding = 4 - size;\r\n                const totalPadding = perElementPadding * arraySize;\r\n                size = size * arraySize + totalPadding;\r\n            }\r\n\r\n            data = [];\r\n            // Fill with zeros\r\n            for (let i = 0; i < size; i++) {\r\n                data.push(0);\r\n            }\r\n        } else {\r\n            if (size instanceof Array) {\r\n                data = size;\r\n                size = data.length;\r\n            } else {\r\n                size = <number>size;\r\n                data = [];\r\n\r\n                // Fill with zeros\r\n                for (let i = 0; i < size; i++) {\r\n                    data.push(0);\r\n                }\r\n            }\r\n            this._fillAlignment(<number>size);\r\n        }\r\n\r\n        this._uniformSizes[name] = <number>size;\r\n        this._uniformLocations[name] = this._uniformLocationPointer;\r\n        this._uniformLocationPointer += <number>size;\r\n\r\n        for (let i = 0; i < size; i++) {\r\n            this._data.push(data[i]);\r\n        }\r\n\r\n        this._needSync = true;\r\n    }\r\n\r\n    /**\r\n     * Adds a Matrix 4x4 to the uniform buffer.\r\n     * @param name Name of the uniform, as used in the uniform block in the shader.\r\n     * @param mat A 4x4 matrix.\r\n     */\r\n    public addMatrix(name: string, mat: IMatrixLike) {\r\n        this.addUniform(name, Array.prototype.slice.call(mat.asArray()));\r\n    }\r\n\r\n    /**\r\n     * Adds a vec2 to the uniform buffer.\r\n     * @param name Name of the uniform, as used in the uniform block in the shader.\r\n     * @param x Define the x component value of the vec2\r\n     * @param y Define the y component value of the vec2\r\n     */\r\n    public addFloat2(name: string, x: number, y: number) {\r\n        const temp = [x, y];\r\n        this.addUniform(name, temp);\r\n    }\r\n\r\n    /**\r\n     * Adds a vec3 to the uniform buffer.\r\n     * @param name Name of the uniform, as used in the uniform block in the shader.\r\n     * @param x Define the x component value of the vec3\r\n     * @param y Define the y component value of the vec3\r\n     * @param z Define the z component value of the vec3\r\n     */\r\n    public addFloat3(name: string, x: number, y: number, z: number) {\r\n        const temp = [x, y, z];\r\n        this.addUniform(name, temp);\r\n    }\r\n\r\n    /**\r\n     * Adds a vec3 to the uniform buffer.\r\n     * @param name Name of the uniform, as used in the uniform block in the shader.\r\n     * @param color Define the vec3 from a Color\r\n     */\r\n    public addColor3(name: string, color: IColor3Like) {\r\n        const temp = [color.r, color.g, color.b];\r\n        this.addUniform(name, temp);\r\n    }\r\n\r\n    /**\r\n     * Adds a vec4 to the uniform buffer.\r\n     * @param name Name of the uniform, as used in the uniform block in the shader.\r\n     * @param color Define the rgb components from a Color\r\n     * @param alpha Define the a component of the vec4\r\n     */\r\n    public addColor4(name: string, color: IColor3Like, alpha: number) {\r\n        const temp = [color.r, color.g, color.b, alpha];\r\n        this.addUniform(name, temp);\r\n    }\r\n\r\n    /**\r\n     * Adds a vec3 to the uniform buffer.\r\n     * @param name Name of the uniform, as used in the uniform block in the shader.\r\n     * @param vector Define the vec3 components from a Vector\r\n     */\r\n    public addVector3(name: string, vector: IVector3Like) {\r\n        const temp = [vector.x, vector.y, vector.z];\r\n        this.addUniform(name, temp);\r\n    }\r\n\r\n    /**\r\n     * Adds a Matrix 3x3 to the uniform buffer.\r\n     * @param name Name of the uniform, as used in the uniform block in the shader.\r\n     */\r\n    public addMatrix3x3(name: string) {\r\n        this.addUniform(name, 12);\r\n    }\r\n\r\n    /**\r\n     * Adds a Matrix 2x2 to the uniform buffer.\r\n     * @param name Name of the uniform, as used in the uniform block in the shader.\r\n     */\r\n    public addMatrix2x2(name: string) {\r\n        this.addUniform(name, 8);\r\n    }\r\n\r\n    /**\r\n     * Effectively creates the WebGL Uniform Buffer, once layout is completed with `addUniform`.\r\n     */\r\n    public create(): void {\r\n        if (this._noUBO) {\r\n            return;\r\n        }\r\n        if (this._buffer) {\r\n            return; // nothing to do\r\n        }\r\n\r\n        // See spec, alignment must be filled as a vec4\r\n        this._fillAlignment(4);\r\n        this._bufferData = new Float32Array(this._data);\r\n\r\n        this._rebuild();\r\n\r\n        this._needSync = true;\r\n    }\r\n\r\n    // The result of this method is used for debugging purpose, as part of the buffer name\r\n    // It is meant to more easily know what this buffer is about when debugging\r\n    // Some buffers can have a lot of uniforms (several dozens), so the method only returns the first 10 of them\r\n    // (should be enough to understand what the buffer is for)\r\n    private _getNames() {\r\n        const names = [];\r\n        let i = 0;\r\n        for (const name in this._uniformLocations) {\r\n            names.push(name);\r\n            if (++i === 10) {\r\n                break;\r\n            }\r\n        }\r\n        return names.join(\",\");\r\n    }\r\n\r\n    /** @internal */\r\n    public _rebuild(): void {\r\n        if (this._noUBO || !this._bufferData) {\r\n            return;\r\n        }\r\n\r\n        if (this._dynamic) {\r\n            this._buffer = this._engine.createDynamicUniformBuffer(this._bufferData, this._name + \"_UniformList:\" + this._getNames());\r\n        } else {\r\n            this._buffer = this._engine.createUniformBuffer(this._bufferData, this._name + \"_UniformList:\" + this._getNames());\r\n        }\r\n\r\n        if (this._engine._features.trackUbosInFrame) {\r\n            this._buffers.push([this._buffer, this._engine._features.checkUbosContentBeforeUpload ? this._bufferData.slice() : undefined]);\r\n            this._bufferIndex = this._buffers.length - 1;\r\n            this._createBufferOnWrite = false;\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public _rebuildAfterContextLost(): void {\r\n        if (this._engine._features.trackUbosInFrame) {\r\n            this._buffers = [];\r\n            this._currentFrameId = 0;\r\n        }\r\n        this._rebuild();\r\n    }\r\n\r\n    /** @internal */\r\n    public get _numBuffers(): number {\r\n        return this._buffers.length;\r\n    }\r\n\r\n    /** @internal */\r\n    public get _indexBuffer(): number {\r\n        return this._bufferIndex;\r\n    }\r\n\r\n    /** Gets the name of this buffer */\r\n    public get name(): string {\r\n        return this._name;\r\n    }\r\n\r\n    /** Gets the current effect */\r\n    public get currentEffect(): Nullable<Effect> {\r\n        return this._currentEffect;\r\n    }\r\n\r\n    private _buffersEqual(buf1: Float32Array, buf2: Float32Array): boolean {\r\n        for (let i = 0; i < buf1.length; ++i) {\r\n            if (buf1[i] !== buf2[i]) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    private _copyBuffer(src: Float32Array, dst: Float32Array): void {\r\n        for (let i = 0; i < src.length; ++i) {\r\n            dst[i] = src[i];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Updates the WebGL Uniform Buffer on the GPU.\r\n     * If the `dynamic` flag is set to true, no cache comparison is done.\r\n     * Otherwise, the buffer will be updated only if the cache differs.\r\n     */\r\n    public update(): void {\r\n        if (this._noUBO) {\r\n            return;\r\n        }\r\n\r\n        this.bindUniformBuffer();\r\n\r\n        if (!this._buffer) {\r\n            this.create();\r\n            return;\r\n        }\r\n\r\n        if (!this._dynamic && !this._needSync) {\r\n            this._createBufferOnWrite = this._engine._features.trackUbosInFrame;\r\n            return;\r\n        }\r\n\r\n        if (this._buffers && this._buffers.length > 1 && this._buffers[this._bufferIndex][1]) {\r\n            if (this._buffersEqual(this._bufferData, this._buffers[this._bufferIndex][1]!)) {\r\n                this._needSync = false;\r\n                this._createBufferOnWrite = this._engine._features.trackUbosInFrame;\r\n                return;\r\n            } else {\r\n                this._copyBuffer(this._bufferData, this._buffers[this._bufferIndex][1]!);\r\n            }\r\n        }\r\n\r\n        this._engine.updateUniformBuffer(this._buffer, this._bufferData);\r\n\r\n        if (this._engine._features._collectUbosUpdatedInFrame) {\r\n            if (!UniformBuffer._UpdatedUbosInFrame[this._name]) {\r\n                UniformBuffer._UpdatedUbosInFrame[this._name] = 0;\r\n            }\r\n            UniformBuffer._UpdatedUbosInFrame[this._name]++;\r\n        }\r\n\r\n        this._needSync = false;\r\n        this._createBufferOnWrite = this._engine._features.trackUbosInFrame;\r\n    }\r\n\r\n    private _createNewBuffer() {\r\n        if (this._bufferIndex + 1 < this._buffers.length) {\r\n            this._bufferIndex++;\r\n            this._buffer = this._buffers[this._bufferIndex][0];\r\n            this._createBufferOnWrite = false;\r\n            this._needSync = true;\r\n        } else {\r\n            this._rebuild();\r\n        }\r\n    }\r\n\r\n    private _checkNewFrame(): void {\r\n        if (this._engine._features.trackUbosInFrame && this._currentFrameId !== this._engine.frameId) {\r\n            this._currentFrameId = this._engine.frameId;\r\n            this._createBufferOnWrite = false;\r\n            if (this._buffers && this._buffers.length > 0) {\r\n                this._needSync = this._bufferIndex !== 0;\r\n                this._bufferIndex = 0;\r\n                this._buffer = this._buffers[this._bufferIndex][0];\r\n            } else {\r\n                this._bufferIndex = -1;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Updates the value of an uniform. The `update` method must be called afterwards to make it effective in the GPU.\r\n     * @param uniformName Define the name of the uniform, as used in the uniform block in the shader.\r\n     * @param data Define the flattened data\r\n     * @param size Define the size of the data.\r\n     */\r\n    public updateUniform(uniformName: string, data: FloatArray, size: number) {\r\n        this._checkNewFrame();\r\n\r\n        let location = this._uniformLocations[uniformName];\r\n        if (location === undefined) {\r\n            if (this._buffer) {\r\n                // Cannot add an uniform if the buffer is already created\r\n                Logger.Error(\"Cannot add an uniform after UBO has been created. uniformName=\" + uniformName);\r\n                return;\r\n            }\r\n            this.addUniform(uniformName, size);\r\n            location = this._uniformLocations[uniformName];\r\n        }\r\n\r\n        if (!this._buffer) {\r\n            this.create();\r\n        }\r\n\r\n        if (!this._dynamic) {\r\n            // Cache for static uniform buffers\r\n            let changed = false;\r\n\r\n            for (let i = 0; i < size; i++) {\r\n                // We are checking the matrix cache before calling updateUniform so we do not need to check it here\r\n                // Hence the test for size === 16 to simply commit the matrix values\r\n                if ((size === 16 && !this._engine._features.uniformBufferHardCheckMatrix) || this._bufferData[location + i] !== Math.fround(data[i])) {\r\n                    changed = true;\r\n                    if (this._createBufferOnWrite) {\r\n                        this._createNewBuffer();\r\n                    }\r\n                    this._bufferData[location + i] = data[i];\r\n                }\r\n            }\r\n\r\n            this._needSync = this._needSync || changed;\r\n        } else {\r\n            // No cache for dynamic\r\n            for (let i = 0; i < size; i++) {\r\n                this._bufferData[location + i] = data[i];\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Updates the value of an uniform. The `update` method must be called afterwards to make it effective in the GPU.\r\n     * @param uniformName Define the name of the uniform, as used in the uniform block in the shader.\r\n     * @param data Define the flattened data\r\n     * @param size Define the size of the data.\r\n     */\r\n    public updateUniformArray(uniformName: string, data: FloatArray, size: number) {\r\n        this._checkNewFrame();\r\n\r\n        const location = this._uniformLocations[uniformName];\r\n        if (location === undefined) {\r\n            Logger.Error(\"Cannot add an uniform Array dynamically. Please, add it using addUniform and make sure that uniform buffers are supported by the current engine.\");\r\n            return;\r\n        }\r\n\r\n        if (!this._buffer) {\r\n            this.create();\r\n        }\r\n\r\n        const arraySizes = this._uniformArraySizes[uniformName];\r\n\r\n        if (!this._dynamic) {\r\n            // Cache for static uniform buffers\r\n            let changed = false;\r\n            let countToFour = 0;\r\n            let baseStride = 0;\r\n            for (let i = 0; i < size; i++) {\r\n                if (this._bufferData[location + baseStride * 4 + countToFour] !== Tools.FloatRound(data[i])) {\r\n                    changed = true;\r\n                    if (this._createBufferOnWrite) {\r\n                        this._createNewBuffer();\r\n                    }\r\n                    this._bufferData[location + baseStride * 4 + countToFour] = data[i];\r\n                }\r\n                countToFour++;\r\n                if (countToFour === arraySizes.strideSize) {\r\n                    for (; countToFour < 4; countToFour++) {\r\n                        this._bufferData[location + baseStride * 4 + countToFour] = 0;\r\n                    }\r\n                    countToFour = 0;\r\n                    baseStride++;\r\n                }\r\n            }\r\n\r\n            this._needSync = this._needSync || changed;\r\n        } else {\r\n            // No cache for dynamic\r\n            for (let i = 0; i < size; i++) {\r\n                this._bufferData[location + i] = data[i];\r\n            }\r\n        }\r\n    }\r\n\r\n    // Matrix cache\r\n    private _valueCache: { [key: string]: number } = {};\r\n    private _cacheMatrix(name: string, matrix: IMatrixLike): boolean {\r\n        this._checkNewFrame();\r\n\r\n        const cache = this._valueCache[name];\r\n        const flag = matrix.updateFlag;\r\n        if (cache !== undefined && cache === flag) {\r\n            return false;\r\n        }\r\n\r\n        this._valueCache[name] = flag;\r\n        return true;\r\n    }\r\n\r\n    // Update methods\r\n\r\n    private _updateMatrix3x3ForUniform(name: string, matrix: Float32Array): void {\r\n        // To match std140, matrix must be realigned\r\n        for (let i = 0; i < 3; i++) {\r\n            UniformBuffer._TempBuffer[i * 4] = matrix[i * 3];\r\n            UniformBuffer._TempBuffer[i * 4 + 1] = matrix[i * 3 + 1];\r\n            UniformBuffer._TempBuffer[i * 4 + 2] = matrix[i * 3 + 2];\r\n            UniformBuffer._TempBuffer[i * 4 + 3] = 0.0;\r\n        }\r\n\r\n        this.updateUniform(name, UniformBuffer._TempBuffer, 12);\r\n    }\r\n\r\n    private _updateMatrix3x3ForEffect(name: string, matrix: Float32Array): void {\r\n        this._currentEffect.setMatrix3x3(name, matrix);\r\n    }\r\n\r\n    private _updateMatrix2x2ForEffect(name: string, matrix: Float32Array): void {\r\n        this._currentEffect.setMatrix2x2(name, matrix);\r\n    }\r\n\r\n    private _updateMatrix2x2ForUniform(name: string, matrix: Float32Array): void {\r\n        // To match std140, matrix must be realigned\r\n        for (let i = 0; i < 2; i++) {\r\n            UniformBuffer._TempBuffer[i * 4] = matrix[i * 2];\r\n            UniformBuffer._TempBuffer[i * 4 + 1] = matrix[i * 2 + 1];\r\n            UniformBuffer._TempBuffer[i * 4 + 2] = 0.0;\r\n            UniformBuffer._TempBuffer[i * 4 + 3] = 0.0;\r\n        }\r\n\r\n        this.updateUniform(name, UniformBuffer._TempBuffer, 8);\r\n    }\r\n\r\n    private _updateFloatForEffect(name: string, x: number) {\r\n        this._currentEffect.setFloat(name, x);\r\n    }\r\n\r\n    private _updateFloatForUniform(name: string, x: number) {\r\n        UniformBuffer._TempBuffer[0] = x;\r\n        this.updateUniform(name, UniformBuffer._TempBuffer, 1);\r\n    }\r\n\r\n    private _updateFloat2ForEffect(name: string, x: number, y: number, suffix = \"\") {\r\n        this._currentEffect.setFloat2(name + suffix, x, y);\r\n    }\r\n\r\n    private _updateFloat2ForUniform(name: string, x: number, y: number) {\r\n        UniformBuffer._TempBuffer[0] = x;\r\n        UniformBuffer._TempBuffer[1] = y;\r\n        this.updateUniform(name, UniformBuffer._TempBuffer, 2);\r\n    }\r\n\r\n    private _updateFloat3ForEffect(name: string, x: number, y: number, z: number, suffix = \"\") {\r\n        this._currentEffect.setFloat3(name + suffix, x, y, z);\r\n    }\r\n\r\n    private _updateFloat3ForUniform(name: string, x: number, y: number, z: number) {\r\n        UniformBuffer._TempBuffer[0] = x;\r\n        UniformBuffer._TempBuffer[1] = y;\r\n        UniformBuffer._TempBuffer[2] = z;\r\n        this.updateUniform(name, UniformBuffer._TempBuffer, 3);\r\n    }\r\n\r\n    private _updateFloat4ForEffect(name: string, x: number, y: number, z: number, w: number, suffix = \"\") {\r\n        this._currentEffect.setFloat4(name + suffix, x, y, z, w);\r\n    }\r\n\r\n    private _updateFloat4ForUniform(name: string, x: number, y: number, z: number, w: number) {\r\n        UniformBuffer._TempBuffer[0] = x;\r\n        UniformBuffer._TempBuffer[1] = y;\r\n        UniformBuffer._TempBuffer[2] = z;\r\n        UniformBuffer._TempBuffer[3] = w;\r\n        this.updateUniform(name, UniformBuffer._TempBuffer, 4);\r\n    }\r\n\r\n    private _updateFloatArrayForEffect(name: string, array: Float32Array) {\r\n        this._currentEffect.setFloatArray(name, array);\r\n    }\r\n\r\n    private _updateFloatArrayForUniform(name: string, array: Float32Array) {\r\n        this.updateUniformArray(name, array, array.length);\r\n    }\r\n\r\n    private _updateArrayForEffect(name: string, array: number[]) {\r\n        this._currentEffect.setArray(name, array);\r\n    }\r\n\r\n    private _updateArrayForUniform(name: string, array: number[]) {\r\n        this.updateUniformArray(name, array, array.length);\r\n    }\r\n\r\n    private _updateIntArrayForEffect(name: string, array: Int32Array) {\r\n        this._currentEffect.setIntArray(name, array);\r\n    }\r\n\r\n    private _updateIntArrayForUniform(name: string, array: Int32Array) {\r\n        UniformBuffer._TempBufferInt32View.set(array);\r\n        this.updateUniformArray(name, UniformBuffer._TempBuffer, array.length);\r\n    }\r\n\r\n    private _updateUIntArrayForEffect(name: string, array: Uint32Array) {\r\n        this._currentEffect.setUIntArray(name, array);\r\n    }\r\n\r\n    private _updateUIntArrayForUniform(name: string, array: Uint32Array) {\r\n        UniformBuffer._TempBufferUInt32View.set(array);\r\n        this.updateUniformArray(name, UniformBuffer._TempBuffer, array.length);\r\n    }\r\n\r\n    private _updateMatrixForEffect(name: string, mat: IMatrixLike) {\r\n        this._currentEffect.setMatrix(name, mat);\r\n    }\r\n\r\n    private _updateMatrixForUniform(name: string, mat: IMatrixLike) {\r\n        if (this._cacheMatrix(name, mat)) {\r\n            this.updateUniform(name, <any>mat.asArray(), 16);\r\n        }\r\n    }\r\n\r\n    private _updateMatricesForEffect(name: string, mat: Float32Array) {\r\n        this._currentEffect.setMatrices(name, mat);\r\n    }\r\n\r\n    private _updateMatricesForUniform(name: string, mat: Float32Array) {\r\n        this.updateUniform(name, mat, mat.length);\r\n    }\r\n\r\n    private _updateVector3ForEffect(name: string, vector: IVector3Like) {\r\n        this._currentEffect.setVector3(name, vector);\r\n    }\r\n\r\n    private _updateVector3ForUniform(name: string, vector: IVector3Like) {\r\n        UniformBuffer._TempBuffer[0] = vector.x;\r\n        UniformBuffer._TempBuffer[1] = vector.y;\r\n        UniformBuffer._TempBuffer[2] = vector.z;\r\n        this.updateUniform(name, UniformBuffer._TempBuffer, 3);\r\n    }\r\n\r\n    private _updateVector4ForEffect(name: string, vector: IVector4Like) {\r\n        this._currentEffect.setVector4(name, vector);\r\n    }\r\n\r\n    private _updateVector4ForUniform(name: string, vector: IVector4Like) {\r\n        UniformBuffer._TempBuffer[0] = vector.x;\r\n        UniformBuffer._TempBuffer[1] = vector.y;\r\n        UniformBuffer._TempBuffer[2] = vector.z;\r\n        UniformBuffer._TempBuffer[3] = vector.w;\r\n        this.updateUniform(name, UniformBuffer._TempBuffer, 4);\r\n    }\r\n\r\n    private _updateColor3ForEffect(name: string, color: IColor3Like, suffix = \"\") {\r\n        this._currentEffect.setColor3(name + suffix, color);\r\n    }\r\n\r\n    private _updateColor3ForUniform(name: string, color: IColor3Like) {\r\n        UniformBuffer._TempBuffer[0] = color.r;\r\n        UniformBuffer._TempBuffer[1] = color.g;\r\n        UniformBuffer._TempBuffer[2] = color.b;\r\n        this.updateUniform(name, UniformBuffer._TempBuffer, 3);\r\n    }\r\n\r\n    private _updateColor4ForEffect(name: string, color: IColor3Like, alpha: number, suffix = \"\") {\r\n        this._currentEffect.setColor4(name + suffix, color, alpha);\r\n    }\r\n\r\n    private _updateDirectColor4ForEffect(name: string, color: IColor4Like, suffix = \"\") {\r\n        this._currentEffect.setDirectColor4(name + suffix, color);\r\n    }\r\n\r\n    private _updateColor4ForUniform(name: string, color: IColor3Like, alpha: number) {\r\n        UniformBuffer._TempBuffer[0] = color.r;\r\n        UniformBuffer._TempBuffer[1] = color.g;\r\n        UniformBuffer._TempBuffer[2] = color.b;\r\n        UniformBuffer._TempBuffer[3] = alpha;\r\n        this.updateUniform(name, UniformBuffer._TempBuffer, 4);\r\n    }\r\n\r\n    private _updateDirectColor4ForUniform(name: string, color: IColor4Like) {\r\n        UniformBuffer._TempBuffer[0] = color.r;\r\n        UniformBuffer._TempBuffer[1] = color.g;\r\n        UniformBuffer._TempBuffer[2] = color.b;\r\n        UniformBuffer._TempBuffer[3] = color.a;\r\n        this.updateUniform(name, UniformBuffer._TempBuffer, 4);\r\n    }\r\n\r\n    private _updateIntForEffect(name: string, x: number, suffix = \"\") {\r\n        this._currentEffect.setInt(name + suffix, x);\r\n    }\r\n\r\n    private _updateIntForUniform(name: string, x: number) {\r\n        UniformBuffer._TempBufferInt32View[0] = x;\r\n        this.updateUniform(name, UniformBuffer._TempBuffer, 1);\r\n    }\r\n\r\n    private _updateInt2ForEffect(name: string, x: number, y: number, suffix = \"\") {\r\n        this._currentEffect.setInt2(name + suffix, x, y);\r\n    }\r\n\r\n    private _updateInt2ForUniform(name: string, x: number, y: number) {\r\n        UniformBuffer._TempBufferInt32View[0] = x;\r\n        UniformBuffer._TempBufferInt32View[1] = y;\r\n        this.updateUniform(name, UniformBuffer._TempBuffer, 2);\r\n    }\r\n\r\n    private _updateInt3ForEffect(name: string, x: number, y: number, z: number, suffix = \"\") {\r\n        this._currentEffect.setInt3(name + suffix, x, y, z);\r\n    }\r\n\r\n    private _updateInt3ForUniform(name: string, x: number, y: number, z: number) {\r\n        UniformBuffer._TempBufferInt32View[0] = x;\r\n        UniformBuffer._TempBufferInt32View[1] = y;\r\n        UniformBuffer._TempBufferInt32View[2] = z;\r\n        this.updateUniform(name, UniformBuffer._TempBuffer, 3);\r\n    }\r\n\r\n    private _updateInt4ForEffect(name: string, x: number, y: number, z: number, w: number, suffix = \"\") {\r\n        this._currentEffect.setInt4(name + suffix, x, y, z, w);\r\n    }\r\n\r\n    private _updateInt4ForUniform(name: string, x: number, y: number, z: number, w: number) {\r\n        UniformBuffer._TempBufferInt32View[0] = x;\r\n        UniformBuffer._TempBufferInt32View[1] = y;\r\n        UniformBuffer._TempBufferInt32View[2] = z;\r\n        UniformBuffer._TempBufferInt32View[3] = w;\r\n        this.updateUniform(name, UniformBuffer._TempBuffer, 4);\r\n    }\r\n\r\n    private _updateUIntForEffect(name: string, x: number, suffix = \"\") {\r\n        this._currentEffect.setUInt(name + suffix, x);\r\n    }\r\n\r\n    private _updateUIntForUniform(name: string, x: number) {\r\n        UniformBuffer._TempBufferUInt32View[0] = x;\r\n        this.updateUniform(name, UniformBuffer._TempBuffer, 1);\r\n    }\r\n\r\n    private _updateUInt2ForEffect(name: string, x: number, y: number, suffix = \"\") {\r\n        this._currentEffect.setUInt2(name + suffix, x, y);\r\n    }\r\n\r\n    private _updateUInt2ForUniform(name: string, x: number, y: number) {\r\n        UniformBuffer._TempBufferUInt32View[0] = x;\r\n        UniformBuffer._TempBufferUInt32View[1] = y;\r\n        this.updateUniform(name, UniformBuffer._TempBuffer, 2);\r\n    }\r\n\r\n    private _updateUInt3ForEffect(name: string, x: number, y: number, z: number, suffix = \"\") {\r\n        this._currentEffect.setUInt3(name + suffix, x, y, z);\r\n    }\r\n\r\n    private _updateUInt3ForUniform(name: string, x: number, y: number, z: number) {\r\n        UniformBuffer._TempBufferUInt32View[0] = x;\r\n        UniformBuffer._TempBufferUInt32View[1] = y;\r\n        UniformBuffer._TempBufferUInt32View[2] = z;\r\n        this.updateUniform(name, UniformBuffer._TempBuffer, 3);\r\n    }\r\n\r\n    private _updateUInt4ForEffect(name: string, x: number, y: number, z: number, w: number, suffix = \"\") {\r\n        this._currentEffect.setUInt4(name + suffix, x, y, z, w);\r\n    }\r\n\r\n    private _updateUInt4ForUniform(name: string, x: number, y: number, z: number, w: number) {\r\n        UniformBuffer._TempBufferUInt32View[0] = x;\r\n        UniformBuffer._TempBufferUInt32View[1] = y;\r\n        UniformBuffer._TempBufferUInt32View[2] = z;\r\n        UniformBuffer._TempBufferUInt32View[3] = w;\r\n        this.updateUniform(name, UniformBuffer._TempBuffer, 4);\r\n    }\r\n\r\n    /**\r\n     * Sets a sampler uniform on the effect.\r\n     * @param name Define the name of the sampler.\r\n     * @param texture Define the texture to set in the sampler\r\n     */\r\n    public setTexture(name: string, texture: Nullable<ThinTexture>) {\r\n        this._currentEffect.setTexture(name, texture);\r\n    }\r\n\r\n    /**\r\n     * Sets an array of sampler uniforms on the effect.\r\n     * @param name Define the name of uniform.\r\n     * @param textures Define the textures to set in the array of samplers\r\n     */\r\n    public setTextureArray(name: string, textures: ThinTexture[]) {\r\n        this._currentEffect.setTextureArray(name, textures);\r\n    }\r\n    /**\r\n     * Sets a sampler uniform on the effect.\r\n     * @param name Define the name of the sampler.\r\n     * @param texture Define the (internal) texture to set in the sampler\r\n     */\r\n    public bindTexture(name: string, texture: Nullable<InternalTexture>) {\r\n        this._currentEffect._bindTexture(name, texture);\r\n    }\r\n\r\n    /**\r\n     * Directly updates the value of the uniform in the cache AND on the GPU.\r\n     * @param uniformName Define the name of the uniform, as used in the uniform block in the shader.\r\n     * @param data Define the flattened data\r\n     */\r\n    public updateUniformDirectly(uniformName: string, data: FloatArray) {\r\n        this.updateUniform(uniformName, data, data.length);\r\n\r\n        this.update();\r\n    }\r\n\r\n    /**\r\n     * Associates an effect to this uniform buffer\r\n     * @param effect Define the effect to associate the buffer to\r\n     * @param name Name of the uniform block in the shader.\r\n     */\r\n    public bindToEffect(effect: Effect, name: string): void {\r\n        this._currentEffect = effect;\r\n        this._currentEffectName = name;\r\n    }\r\n\r\n    /**\r\n     * Binds the current (GPU) buffer to the effect\r\n     */\r\n    public bindUniformBuffer(): void {\r\n        if (!this._noUBO && this._buffer && this._currentEffect) {\r\n            this._currentEffect.bindUniformBuffer(this._buffer, this._currentEffectName);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Dissociates the current effect from this uniform buffer\r\n     */\r\n    public unbindEffect(): void {\r\n        this._currentEffect = undefined as any;\r\n        this._currentEffectName = undefined as any;\r\n    }\r\n\r\n    /**\r\n     * Sets the current state of the class (_bufferIndex, _buffer) to point to the data buffer passed in parameter if this buffer is one of the buffers handled by the class (meaning if it can be found in the _buffers array)\r\n     * This method is meant to be able to update a buffer at any time: just call setDataBuffer to set the class in the right state, call some updateXXX methods and then call udpate() => that will update the GPU buffer on the graphic card\r\n     * @param dataBuffer buffer to look for\r\n     * @returns true if the buffer has been found and the class internal state points to it, else false\r\n     */\r\n    public setDataBuffer(dataBuffer: DataBuffer): boolean {\r\n        if (!this._buffers) {\r\n            return this._buffer === dataBuffer;\r\n        }\r\n\r\n        for (let b = 0; b < this._buffers.length; ++b) {\r\n            const buffer = this._buffers[b];\r\n            if (buffer[0] === dataBuffer) {\r\n                this._bufferIndex = b;\r\n                this._buffer = dataBuffer;\r\n                this._createBufferOnWrite = false;\r\n                this._currentEffect = undefined as any;\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Disposes the uniform buffer.\r\n     */\r\n    public dispose(): void {\r\n        if (this._noUBO) {\r\n            return;\r\n        }\r\n\r\n        const uniformBuffers = this._engine._uniformBuffers;\r\n        const index = uniformBuffers.indexOf(this);\r\n\r\n        if (index !== -1) {\r\n            uniformBuffers[index] = uniformBuffers[uniformBuffers.length - 1];\r\n            uniformBuffers.pop();\r\n        }\r\n\r\n        if (this._engine._features.trackUbosInFrame && this._buffers) {\r\n            for (let i = 0; i < this._buffers.length; ++i) {\r\n                const buffer = this._buffers[i][0];\r\n                this._engine._releaseBuffer(buffer!);\r\n            }\r\n        } else if (this._buffer && this._engine._releaseBuffer(this._buffer)) {\r\n            this._buffer = null;\r\n        }\r\n    }\r\n}\r\n", "import type { Nullable, FloatArray } from \"../types\";\r\nimport { Vector3, Vector2, TmpVectors } from \"../Maths/math.vector\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { TransformNode } from \"../Meshes/transformNode\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport type { Sprite } from \"../Sprites/sprite\";\r\n\r\nimport type { Ray } from \"../Culling/ray\";\r\n\r\n/**\r\n * Information about the result of picking within a scene\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/interactions/picking_collisions\r\n */\r\nexport class PickingInfo {\r\n    /**\r\n     * If the pick collided with an object\r\n     */\r\n    public hit = false;\r\n    /**\r\n     * Distance away where the pick collided\r\n     */\r\n    public distance = 0;\r\n    /**\r\n     * The location of pick collision\r\n     */\r\n    public pickedPoint: Nullable<Vector3> = null;\r\n    /**\r\n     * The mesh corresponding the pick collision\r\n     */\r\n    public pickedMesh: Nullable<AbstractMesh> = null;\r\n    /** (See getTextureCoordinates) The barycentric U coordinate that is used when calculating the texture coordinates of the collision.*/\r\n    public bu = 0;\r\n    /** (See getTextureCoordinates) The barycentric V coordinate that is used when calculating the texture coordinates of the collision.*/\r\n    public bv = 0;\r\n    /** The index of the face on the mesh that was picked, or the index of the Line if the picked Mesh is a LinesMesh */\r\n    public faceId = -1;\r\n    /** The index of the face on the subMesh that was picked, or the index of the Line if the picked Mesh is a LinesMesh */\r\n    public subMeshFaceId = -1;\r\n    /** Id of the submesh that was picked */\r\n    public subMeshId = 0;\r\n    /** If a sprite was picked, this will be the sprite the pick collided with */\r\n    public pickedSprite: Nullable<Sprite> = null;\r\n    /** If we are picking a mesh with thin instance, this will give you the picked thin instance */\r\n    public thinInstanceIndex = -1;\r\n    /**\r\n     * The ray that was used to perform the picking.\r\n     */\r\n    public ray: Nullable<Ray> = null;\r\n    /**\r\n     * If a mesh was used to do the picking (eg. 6dof controller) as a \"near interaction\", this will be populated.\r\n     */\r\n    public originMesh: Nullable<AbstractMesh> = null;\r\n    /**\r\n     * The aim-space transform of the input used for picking, if it is an XR input source.\r\n     */\r\n    public aimTransform: Nullable<TransformNode> = null;\r\n    /**\r\n     * The grip-space transform of the input used for picking, if it is an XR input source.\r\n     * Some XR sources, such as input coming from head mounted displays, do not have this.\r\n     */\r\n    public gripTransform: Nullable<TransformNode> = null;\r\n\r\n    /**\r\n     * Gets the normal corresponding to the face the pick collided with\r\n     * @param useWorldCoordinates If the resulting normal should be relative to the world (default: false)\r\n     * @param useVerticesNormals If the vertices normals should be used to calculate the normal instead of the normal map (default: true)\r\n     * @returns The normal corresponding to the face the pick collided with\r\n     * @remarks Note that the returned normal will always point towards the picking ray.\r\n     */\r\n    public getNormal(useWorldCoordinates = false, useVerticesNormals = true): Nullable<Vector3> {\r\n        if (!this.pickedMesh || (useVerticesNormals && !this.pickedMesh.isVerticesDataPresent(VertexBuffer.NormalKind))) {\r\n            return null;\r\n        }\r\n\r\n        let indices = this.pickedMesh.getIndices();\r\n\r\n        if (indices?.length === 0) {\r\n            indices = null;\r\n        }\r\n\r\n        let result: Vector3;\r\n\r\n        const tmp0 = TmpVectors.Vector3[0];\r\n        const tmp1 = TmpVectors.Vector3[1];\r\n        const tmp2 = TmpVectors.Vector3[2];\r\n\r\n        if (useVerticesNormals) {\r\n            const normals = <FloatArray>this.pickedMesh.getVerticesData(VertexBuffer.NormalKind);\r\n\r\n            let normal0 = indices\r\n                ? Vector3.FromArrayToRef(normals, indices[this.faceId * 3] * 3, tmp0)\r\n                : tmp0.copyFromFloats(normals[this.faceId * 3 * 3], normals[this.faceId * 3 * 3 + 1], normals[this.faceId * 3 * 3 + 2]);\r\n            let normal1 = indices\r\n                ? Vector3.FromArrayToRef(normals, indices[this.faceId * 3 + 1] * 3, tmp1)\r\n                : tmp1.copyFromFloats(normals[(this.faceId * 3 + 1) * 3], normals[(this.faceId * 3 + 1) * 3 + 1], normals[(this.faceId * 3 + 1) * 3 + 2]);\r\n            let normal2 = indices\r\n                ? Vector3.FromArrayToRef(normals, indices[this.faceId * 3 + 2] * 3, tmp2)\r\n                : tmp2.copyFromFloats(normals[(this.faceId * 3 + 2) * 3], normals[(this.faceId * 3 + 2) * 3 + 1], normals[(this.faceId * 3 + 2) * 3 + 2]);\r\n\r\n            normal0 = normal0.scale(this.bu);\r\n            normal1 = normal1.scale(this.bv);\r\n            normal2 = normal2.scale(1.0 - this.bu - this.bv);\r\n\r\n            result = new Vector3(normal0.x + normal1.x + normal2.x, normal0.y + normal1.y + normal2.y, normal0.z + normal1.z + normal2.z);\r\n        } else {\r\n            const positions = <FloatArray>this.pickedMesh.getVerticesData(VertexBuffer.PositionKind);\r\n\r\n            const vertex1 = indices\r\n                ? Vector3.FromArrayToRef(positions, indices[this.faceId * 3] * 3, tmp0)\r\n                : tmp0.copyFromFloats(positions[this.faceId * 3 * 3], positions[this.faceId * 3 * 3 + 1], positions[this.faceId * 3 * 3 + 2]);\r\n            const vertex2 = indices\r\n                ? Vector3.FromArrayToRef(positions, indices[this.faceId * 3 + 1] * 3, tmp1)\r\n                : tmp1.copyFromFloats(positions[(this.faceId * 3 + 1) * 3], positions[(this.faceId * 3 + 1) * 3 + 1], positions[(this.faceId * 3 + 1) * 3 + 2]);\r\n            const vertex3 = indices\r\n                ? Vector3.FromArrayToRef(positions, indices[this.faceId * 3 + 2] * 3, tmp2)\r\n                : tmp2.copyFromFloats(positions[(this.faceId * 3 + 2) * 3], positions[(this.faceId * 3 + 2) * 3 + 1], positions[(this.faceId * 3 + 2) * 3 + 2]);\r\n\r\n            const p1p2 = vertex1.subtract(vertex2);\r\n            const p3p2 = vertex3.subtract(vertex2);\r\n\r\n            result = Vector3.Cross(p1p2, p3p2);\r\n        }\r\n\r\n        const transformNormalToWorld = (pickedMesh: AbstractMesh, n: Vector3) => {\r\n            let wm = pickedMesh.getWorldMatrix();\r\n\r\n            if (pickedMesh.nonUniformScaling) {\r\n                TmpVectors.Matrix[0].copyFrom(wm);\r\n                wm = TmpVectors.Matrix[0];\r\n                wm.setTranslationFromFloats(0, 0, 0);\r\n                wm.invert();\r\n                wm.transposeToRef(TmpVectors.Matrix[1]);\r\n\r\n                wm = TmpVectors.Matrix[1];\r\n            }\r\n\r\n            Vector3.TransformNormalToRef(n, wm, n);\r\n        };\r\n\r\n        if (useWorldCoordinates) {\r\n            transformNormalToWorld(this.pickedMesh, result);\r\n        }\r\n\r\n        if (this.ray) {\r\n            const normalForDirectionChecking = TmpVectors.Vector3[0].copyFrom(result);\r\n\r\n            if (!useWorldCoordinates) {\r\n                // the normal has not been transformed to world space as part as the normal processing, so we must do it now\r\n                transformNormalToWorld(this.pickedMesh, normalForDirectionChecking);\r\n            }\r\n\r\n            // Flip the normal if the picking ray is in the same direction.\r\n            if (Vector3.Dot(normalForDirectionChecking, this.ray.direction) > 0) {\r\n                result.negateInPlace();\r\n            }\r\n        }\r\n\r\n        result.normalize();\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Gets the texture coordinates of where the pick occurred\r\n     * @param uvSet The UV set to use to calculate the texture coordinates (default: VertexBuffer.UVKind)\r\n     * @returns The vector containing the coordinates of the texture\r\n     */\r\n    public getTextureCoordinates(uvSet = VertexBuffer.UVKind): Nullable<Vector2> {\r\n        if (!this.pickedMesh || !this.pickedMesh.isVerticesDataPresent(uvSet)) {\r\n            return null;\r\n        }\r\n\r\n        const indices = this.pickedMesh.getIndices();\r\n        if (!indices) {\r\n            return null;\r\n        }\r\n\r\n        const uvs = this.pickedMesh.getVerticesData(uvSet);\r\n        if (!uvs) {\r\n            return null;\r\n        }\r\n\r\n        let uv0 = Vector2.FromArray(uvs, indices[this.faceId * 3] * 2);\r\n        let uv1 = Vector2.FromArray(uvs, indices[this.faceId * 3 + 1] * 2);\r\n        let uv2 = Vector2.FromArray(uvs, indices[this.faceId * 3 + 2] * 2);\r\n\r\n        uv0 = uv0.scale(this.bu);\r\n        uv1 = uv1.scale(this.bv);\r\n        uv2 = uv2.scale(1.0 - this.bu - this.bv);\r\n\r\n        return new Vector2(uv0.x + uv1.x + uv2.x, uv0.y + uv1.y + uv2.y);\r\n    }\r\n}\r\n", "import type { Scene } from \"./scene\";\r\nimport type { SmartArrayNoDuplicate } from \"./Misc/smartArray\";\r\nimport type { Nullable } from \"./types\";\r\nimport type { PickingInfo } from \"./Collisions/pickingInfo\";\r\nimport type { IPointerEvent } from \"./Events/deviceInputEvents\";\r\n\r\nimport type { Mesh } from \"./Meshes/mesh\";\r\nimport type { Effect } from \"./Materials/effect\";\r\nimport type { Camera } from \"./Cameras/camera\";\r\nimport type { AbstractMesh } from \"./Meshes/abstractMesh\";\r\nimport type { SubMesh } from \"./Meshes/subMesh\";\r\nimport type { RenderTargetTexture } from \"./Materials/Textures/renderTargetTexture\";\r\nimport type { IAssetContainer } from \"./IAssetContainer\";\r\n\r\n/**\r\n * Groups all the scene component constants in one place to ease maintenance.\r\n * @internal\r\n */\r\nexport class SceneComponentConstants {\r\n    public static readonly NAME_EFFECTLAYER = \"EffectLayer\";\r\n    public static readonly NAME_LAYER = \"Layer\";\r\n    public static readonly NAME_LENSFLARESYSTEM = \"LensFlareSystem\";\r\n    public static readonly NAME_BOUNDINGBOXRENDERER = \"BoundingBoxRenderer\";\r\n    public static readonly NAME_PARTICLESYSTEM = \"ParticleSystem\";\r\n    public static readonly NAME_GAMEPAD = \"Gamepad\";\r\n    public static readonly NAME_SIMPLIFICATIONQUEUE = \"SimplificationQueue\";\r\n    public static readonly NAME_GEOMETRYBUFFERRENDERER = \"GeometryBufferRenderer\";\r\n    public static readonly NAME_PREPASSRENDERER = \"PrePassRenderer\";\r\n    public static readonly NAME_DEPTHRENDERER = \"DepthRenderer\";\r\n    public static readonly NAME_DEPTHPEELINGRENDERER = \"DepthPeelingRenderer\";\r\n    public static readonly NAME_IBLSHADOWSRENDERER = \"IblShadowsRenderer\";\r\n    public static readonly NAME_POSTPROCESSRENDERPIPELINEMANAGER = \"PostProcessRenderPipelineManager\";\r\n    public static readonly NAME_SPRITE = \"Sprite\";\r\n    public static readonly NAME_SUBSURFACE = \"SubSurface\";\r\n    public static readonly NAME_OUTLINERENDERER = \"Outline\";\r\n    public static readonly NAME_PROCEDURALTEXTURE = \"ProceduralTexture\";\r\n    public static readonly NAME_SHADOWGENERATOR = \"ShadowGenerator\";\r\n    public static readonly NAME_OCTREE = \"Octree\";\r\n    public static readonly NAME_PHYSICSENGINE = \"PhysicsEngine\";\r\n    public static readonly NAME_AUDIO = \"Audio\";\r\n    public static readonly NAME_FLUIDRENDERER = \"FluidRenderer\";\r\n\r\n    public static readonly STEP_ISREADYFORMESH_EFFECTLAYER = 0;\r\n\r\n    public static readonly STEP_BEFOREEVALUATEACTIVEMESH_BOUNDINGBOXRENDERER = 0;\r\n\r\n    public static readonly STEP_EVALUATESUBMESH_BOUNDINGBOXRENDERER = 0;\r\n\r\n    public static readonly STEP_PREACTIVEMESH_BOUNDINGBOXRENDERER = 0;\r\n\r\n    public static readonly STEP_CAMERADRAWRENDERTARGET_EFFECTLAYER = 1;\r\n\r\n    public static readonly STEP_BEFORECAMERADRAW_PREPASS = 0;\r\n    public static readonly STEP_BEFORECAMERADRAW_EFFECTLAYER = 1;\r\n    public static readonly STEP_BEFORECAMERADRAW_LAYER = 2;\r\n\r\n    public static readonly STEP_BEFORERENDERTARGETDRAW_PREPASS = 0;\r\n    public static readonly STEP_BEFORERENDERTARGETDRAW_LAYER = 1;\r\n\r\n    public static readonly STEP_BEFORERENDERINGMESH_PREPASS = 0;\r\n    public static readonly STEP_BEFORERENDERINGMESH_OUTLINE = 1;\r\n\r\n    public static readonly STEP_AFTERRENDERINGMESH_PREPASS = 0;\r\n    public static readonly STEP_AFTERRENDERINGMESH_OUTLINE = 1;\r\n\r\n    public static readonly STEP_AFTERRENDERINGGROUPDRAW_EFFECTLAYER_DRAW = 0;\r\n    public static readonly STEP_AFTERRENDERINGGROUPDRAW_BOUNDINGBOXRENDERER = 1;\r\n\r\n    public static readonly STEP_BEFORECAMERAUPDATE_SIMPLIFICATIONQUEUE = 0;\r\n    public static readonly STEP_BEFORECAMERAUPDATE_GAMEPAD = 1;\r\n\r\n    public static readonly STEP_BEFORECLEAR_PROCEDURALTEXTURE = 0;\r\n    public static readonly STEP_BEFORECLEAR_PREPASS = 1;\r\n\r\n    public static readonly STEP_BEFORERENDERTARGETCLEAR_PREPASS = 0;\r\n\r\n    public static readonly STEP_AFTERRENDERTARGETDRAW_PREPASS = 0;\r\n    public static readonly STEP_AFTERRENDERTARGETDRAW_LAYER = 1;\r\n\r\n    public static readonly STEP_AFTERCAMERADRAW_PREPASS = 0;\r\n    public static readonly STEP_AFTERCAMERADRAW_EFFECTLAYER = 1;\r\n    public static readonly STEP_AFTERCAMERADRAW_LENSFLARESYSTEM = 2;\r\n    public static readonly STEP_AFTERCAMERADRAW_EFFECTLAYER_DRAW = 3;\r\n    public static readonly STEP_AFTERCAMERADRAW_LAYER = 4;\r\n    public static readonly STEP_AFTERCAMERADRAW_FLUIDRENDERER = 5;\r\n\r\n    public static readonly STEP_AFTERCAMERAPOSTPROCESS_LAYER = 0;\r\n\r\n    public static readonly STEP_AFTERRENDERTARGETPOSTPROCESS_LAYER = 0;\r\n\r\n    public static readonly STEP_AFTERRENDER_AUDIO = 0;\r\n\r\n    public static readonly STEP_GATHERRENDERTARGETS_DEPTHRENDERER = 0;\r\n    public static readonly STEP_GATHERRENDERTARGETS_GEOMETRYBUFFERRENDERER = 1;\r\n    public static readonly STEP_GATHERRENDERTARGETS_SHADOWGENERATOR = 2;\r\n    public static readonly STEP_GATHERRENDERTARGETS_POSTPROCESSRENDERPIPELINEMANAGER = 3;\r\n\r\n    public static readonly STEP_GATHERACTIVECAMERARENDERTARGETS_DEPTHRENDERER = 0;\r\n    public static readonly STEP_GATHERACTIVECAMERARENDERTARGETS_FLUIDRENDERER = 1;\r\n\r\n    public static readonly STEP_POINTERMOVE_SPRITE = 0;\r\n    public static readonly STEP_POINTERDOWN_SPRITE = 0;\r\n    public static readonly STEP_POINTERUP_SPRITE = 0;\r\n}\r\n\r\n/**\r\n * This represents a scene component.\r\n *\r\n * This is used to decouple the dependency the scene is having on the different workloads like\r\n * layers, post processes...\r\n */\r\nexport interface ISceneComponent {\r\n    /**\r\n     * The name of the component. Each component must have a unique name.\r\n     */\r\n    name: string;\r\n\r\n    /**\r\n     * The scene the component belongs to.\r\n     */\r\n    scene: Scene;\r\n\r\n    /**\r\n     * Register the component to one instance of a scene.\r\n     */\r\n    register(): void;\r\n\r\n    /**\r\n     * Rebuilds the elements related to this component in case of\r\n     * context lost for instance.\r\n     */\r\n    rebuild(): void;\r\n\r\n    /**\r\n     * Disposes the component and the associated ressources.\r\n     */\r\n    dispose(): void;\r\n}\r\n\r\n/**\r\n * This represents a SERIALIZABLE scene component.\r\n *\r\n * This extends Scene Component to add Serialization methods on top.\r\n */\r\nexport interface ISceneSerializableComponent extends ISceneComponent {\r\n    /**\r\n     * Adds all the elements from the container to the scene\r\n     * @param container the container holding the elements\r\n     */\r\n    addFromContainer(container: IAssetContainer): void;\r\n\r\n    /**\r\n     * Removes all the elements in the container from the scene\r\n     * @param container contains the elements to remove\r\n     * @param dispose if the removed element should be disposed (default: false)\r\n     */\r\n    removeFromContainer(container: IAssetContainer, dispose?: boolean): void;\r\n\r\n    /**\r\n     * Serializes the component data to the specified json object\r\n     * @param serializationObject The object to serialize to\r\n     */\r\n    serialize(serializationObject: any): void;\r\n}\r\n\r\n/**\r\n * Strong typing of a Mesh related stage step action\r\n */\r\nexport type MeshStageAction = (mesh: AbstractMesh, hardwareInstancedRendering: boolean) => boolean;\r\n\r\n/**\r\n * Strong typing of a Evaluate Sub Mesh related stage step action\r\n */\r\nexport type EvaluateSubMeshStageAction = (mesh: AbstractMesh, subMesh: SubMesh) => void;\r\n\r\n/**\r\n * Strong typing of a pre active Mesh related stage step action\r\n */\r\nexport type PreActiveMeshStageAction = (mesh: AbstractMesh) => void;\r\n\r\n/**\r\n * Strong typing of a Camera related stage step action\r\n */\r\nexport type CameraStageAction = (camera: Camera) => void;\r\n\r\n/**\r\n * Strong typing of a Camera Frame buffer related stage step action\r\n */\r\nexport type CameraStageFrameBufferAction = (camera: Camera) => boolean;\r\n\r\n/**\r\n * Strong typing of a Render Target related stage step action\r\n */\r\nexport type RenderTargetStageAction = (renderTarget: RenderTargetTexture, faceIndex?: number, layer?: number) => void;\r\n\r\n/**\r\n * Strong typing of a RenderingGroup related stage step action\r\n */\r\nexport type RenderingGroupStageAction = (renderingGroupId: number) => void;\r\n\r\n/**\r\n * Strong typing of a Mesh Render related stage step action\r\n */\r\nexport type RenderingMeshStageAction = (mesh: Mesh, subMesh: SubMesh, batch: any, effect: Nullable<Effect>) => void;\r\n\r\n/**\r\n * Strong typing of a simple stage step action\r\n */\r\nexport type SimpleStageAction = () => void;\r\n\r\n/**\r\n * Strong typing of a render target action.\r\n */\r\nexport type RenderTargetsStageAction = (renderTargets: SmartArrayNoDuplicate<RenderTargetTexture>) => void;\r\n\r\n/**\r\n * Strong typing of a pointer move action.\r\n */\r\nexport type PointerMoveStageAction = (\r\n    unTranslatedPointerX: number,\r\n    unTranslatedPointerY: number,\r\n    pickResult: Nullable<PickingInfo>,\r\n    isMeshPicked: boolean,\r\n    element: Nullable<HTMLElement>\r\n) => Nullable<PickingInfo>;\r\n\r\n/**\r\n * Strong typing of a pointer up/down action.\r\n */\r\nexport type PointerUpDownStageAction = (\r\n    unTranslatedPointerX: number,\r\n    unTranslatedPointerY: number,\r\n    pickResult: Nullable<PickingInfo>,\r\n    evt: IPointerEvent,\r\n    doubleClick: boolean\r\n) => Nullable<PickingInfo>;\r\n\r\n/**\r\n * Representation of a stage in the scene (Basically a list of ordered steps)\r\n * @internal\r\n */\r\nexport class Stage<T extends Function> extends Array<{ index: number; component: ISceneComponent; action: T }> {\r\n    /**\r\n     * Hide ctor from the rest of the world.\r\n     * @param items The items to add.\r\n     */\r\n    private constructor(items?: { index: number; component: ISceneComponent; action: T }[]) {\r\n        super(...(<any>items));\r\n    }\r\n\r\n    /**\r\n     * Creates a new Stage.\r\n     * @returns A new instance of a Stage\r\n     */\r\n    static Create<T extends Function>(): Stage<T> {\r\n        return Object.create(Stage.prototype);\r\n    }\r\n\r\n    /**\r\n     * Registers a step in an ordered way in the targeted stage.\r\n     * @param index Defines the position to register the step in\r\n     * @param component Defines the component attached to the step\r\n     * @param action Defines the action to launch during the step\r\n     */\r\n    public registerStep(index: number, component: ISceneComponent, action: T): void {\r\n        let i = 0;\r\n        let maxIndex = Number.MAX_VALUE;\r\n        for (; i < this.length; i++) {\r\n            const step = this[i];\r\n            maxIndex = step.index;\r\n            if (index < maxIndex) {\r\n                break;\r\n            }\r\n        }\r\n        this.splice(i, 0, { index, component, action: action.bind(component) });\r\n    }\r\n\r\n    /**\r\n     * Clears all the steps from the stage.\r\n     */\r\n    public clear(): void {\r\n        this.length = 0;\r\n    }\r\n}\r\n", "/** Defines the cross module constantsused by lights to avoid circular dependencies */\r\nexport class LightConstants {\r\n    /**\r\n     * Falloff Default: light is falling off following the material specification:\r\n     * standard material is using standard falloff whereas pbr material can request special falloff per materials.\r\n     */\r\n    public static readonly FALLOFF_DEFAULT = 0;\r\n\r\n    /**\r\n     * Falloff Physical: light is falling off following the inverse squared distance law.\r\n     */\r\n    public static readonly FALLOFF_PHYSICAL = 1;\r\n\r\n    /**\r\n     * Falloff gltf: light is falling off as described in the gltf moving to PBR document\r\n     * to enhance interoperability with other engines.\r\n     */\r\n    public static readonly FALLOFF_GLTF = 2;\r\n\r\n    /**\r\n     * Falloff Standard: light is falling off like in the standard material\r\n     * to enhance interoperability with other materials.\r\n     */\r\n    public static readonly FALLOFF_STANDARD = 3;\r\n\r\n    //lightmapMode Consts\r\n    /**\r\n     * If every light affecting the material is in this lightmapMode,\r\n     * material.lightmapTexture adds or multiplies\r\n     * (depends on material.useLightmapAsShadowmap)\r\n     * after every other light calculations.\r\n     */\r\n    public static readonly LIGHTMAP_DEFAULT = 0;\r\n    /**\r\n     * material.lightmapTexture as only diffuse lighting from this light\r\n     * adds only specular lighting from this light\r\n     * adds dynamic shadows\r\n     */\r\n    public static readonly LIGHTMAP_SPECULAR = 1;\r\n    /**\r\n     * material.lightmapTexture as only lighting\r\n     * no light calculation from this light\r\n     * only adds dynamic shadows from this light\r\n     */\r\n    public static readonly LIGHTMAP_SHADOWSONLY = 2;\r\n\r\n    // Intensity Mode Consts\r\n    /**\r\n     * Each light type uses the default quantity according to its type:\r\n     *      point/spot lights use luminous intensity\r\n     *      directional lights use illuminance\r\n     */\r\n    public static readonly INTENSITYMODE_AUTOMATIC = 0;\r\n    /**\r\n     * lumen (lm)\r\n     */\r\n    public static readonly INTENSITYMODE_LUMINOUSPOWER = 1;\r\n    /**\r\n     * candela (lm/sr)\r\n     */\r\n    public static readonly INTENSITYMODE_LUMINOUSINTENSITY = 2;\r\n    /**\r\n     * lux (lm/m^2)\r\n     */\r\n    public static readonly INTENSITYMODE_ILLUMINANCE = 3;\r\n    /**\r\n     * nit (cd/m^2)\r\n     */\r\n    public static readonly INTENSITYMODE_LUMINANCE = 4;\r\n\r\n    // Light types ids const.\r\n    /**\r\n     * Light type const id of the point light.\r\n     */\r\n    public static readonly LIGHTTYPEID_POINTLIGHT = 0;\r\n    /**\r\n     * Light type const id of the directional light.\r\n     */\r\n    public static readonly LIGHTTYPEID_DIRECTIONALLIGHT = 1;\r\n    /**\r\n     * Light type const id of the spot light.\r\n     */\r\n    public static readonly LIGHTTYPEID_SPOTLIGHT = 2;\r\n    /**\r\n     * Light type const id of the hemispheric light.\r\n     */\r\n    public static readonly LIGHTTYPEID_HEMISPHERICLIGHT = 3;\r\n\r\n    /**\r\n     * Sort function to order lights for rendering.\r\n     * @param a First Light object to compare to second.\r\n     * @param b Second Light object to compare first.\r\n     * @returns -1 to reduce's a's index relative to be, 0 for no change, 1 to increase a's index relative to b.\r\n     */\r\n    public static CompareLightsPriority(a: ISortableLight, b: ISortableLight): number {\r\n        //shadow-casting lights have priority over non-shadow-casting lights\r\n        //the renderPriority is a secondary sort criterion\r\n        if (a.shadowEnabled !== b.shadowEnabled) {\r\n            return (b.shadowEnabled ? 1 : 0) - (a.shadowEnabled ? 1 : 0);\r\n        }\r\n        return b.renderPriority - a.renderPriority;\r\n    }\r\n}\r\n\r\n/**\r\n * Defines the common interface of sortable lights\r\n */\r\nexport interface ISortableLight {\r\n    /**\r\n     * Gets or sets whether or not the shadows are enabled for this light. This can help turning off/on shadow without detaching\r\n     * the current shadow generator.\r\n     */\r\n    shadowEnabled: boolean;\r\n    /**\r\n     * Defines the rendering priority of the lights. It can help in case of fallback or number of lights\r\n     * exceeding the number allowed of the materials.\r\n     */\r\n    renderPriority: number;\r\n}\r\n"],
  "mappings": "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",
  "names": []
}

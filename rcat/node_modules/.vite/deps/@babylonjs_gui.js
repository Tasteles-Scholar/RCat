import {
  AnimationGroup
} from "./chunk-XYB2D7ZW.js";
import {
  AdvancedDynamicTexture,
  AdvancedDynamicTextureInstrumentation,
  BaseGradient,
  BaseSlider,
  Button,
  Checkbox,
  CheckboxGroup,
  ColorPicker,
  Container,
  Control,
  DisplayGrid,
  Ellipse,
  FocusableButton,
  Grid,
  Image,
  ImageBasedSlider,
  ImageScrollBar,
  InputPassword,
  InputText,
  InputTextArea,
  KeyPropertySet,
  Line,
  LinearGradient,
  MathTools,
  Matrix2D,
  Measure,
  MultiLine,
  MultiLinePoint,
  RadialGradient,
  RadioButton,
  RadioGroup,
  Rectangle,
  ScrollBar,
  ScrollViewer,
  SelectionPanel,
  SelectorGroup,
  Slider,
  SliderGroup,
  StackPanel,
  Style,
  TextBlock,
  TextWrapper,
  TextWrapping,
  ToggleButton,
  ValueAndUnit,
  Vector2WithInfo,
  VirtualKeyboard,
  XmlLoader,
  name
} from "./chunk-7LILRRKJ.js";
import {
  Camera,
  EffectFallbacks,
  HemisphericLight,
  Light,
  MaterialDefines,
  Mesh,
  PushMaterial,
  SceneLoader,
  ShaderMaterial,
  StandardMaterial
} from "./chunk-6HH2D6LO.js";
import {
  Animation
} from "./chunk-I3YHYNYZ.js";
import {
  Scene,
  _ImportHelper
} from "./chunk-PTDD4D5F.js";
import "./chunk-ZIPDFSO3.js";
import "./chunk-2GNVGG7Y.js";
import {
  AbstractMesh,
  Constants,
  HandleFallbacksForShadows,
  IntersectionInfo,
  PrepareAttributesForInstances,
  PrepareDefinesForAttributes,
  PrepareUniformsAndSamplersList,
  TransformNode,
  VertexData
} from "./chunk-7B3NOU5L.js";
import "./chunk-K5B76N6P.js";
import {
  PickingInfo,
  PointerEventTypes,
  PointerInfo
} from "./chunk-LFQOBB3N.js";
import {
  Axis
} from "./chunk-WATMMEI5.js";
import {
  Texture,
  useOpenGLOrientationForUV
} from "./chunk-AHMKO7Z3.js";
import {
  Color3,
  Color4,
  SerializationHelper,
  TmpColors,
  __decorate,
  expandToProperty,
  serialize,
  serializeAsColor3,
  serializeAsColor4,
  serializeAsTexture,
  serializeAsVector3
} from "./chunk-LJWPR2K5.js";
import {
  BuildArray,
  Epsilon,
  Matrix,
  Quaternion,
  TmpVectors,
  Vector2,
  Vector3,
  Vector4
} from "./chunk-GCXGXOND.js";
import {
  Viewport
} from "./chunk-NSQCR3LX.js";
import {
  VertexBuffer
} from "./chunk-MX32RALM.js";
import {
  Tools
} from "./chunk-J3DITW5F.js";
import {
  Clamp,
  HighestCommonFactor,
  math_scalar_functions_exports
} from "./chunk-537VGFRK.js";
import "./chunk-BSZFQJN6.js";
import {
  RegisterClass
} from "./chunk-4LFNXJGH.js";
import "./chunk-X5MC4FCF.js";
import "./chunk-I2PO3XEU.js";
import {
  IsDocumentAvailable
} from "./chunk-ULQUZGBY.js";
import {
  EngineStore,
  Observable
} from "./chunk-TS7CPY6B.js";
import {
  Logger
} from "./chunk-RP2ILEGM.js";
import {
  ShaderStore
} from "./chunk-FX6MN5HL.js";
import "./chunk-HKJ2B2AA.js";

// node_modules/@babylonjs/gui/3D/vector3WithInfo.js
var Vector3WithInfo = class extends Vector3 {
  /**
   * Creates a new Vector3WithInfo
   * @param source defines the vector3 data to transport
   * @param buttonIndex defines the current mouse button index
   */
  constructor(source, buttonIndex = 0) {
    super(source.x, source.y, source.z);
    this.buttonIndex = buttonIndex;
  }
};

// node_modules/@babylonjs/gui/3D/controls/control3D.js
var Control3D = class {
  /** Gets or sets the control position in world space */
  get position() {
    if (!this._node) {
      this._position = this._position || Vector3.Zero();
      return this._position;
    }
    return this._node.position;
  }
  set position(value) {
    this._position = value;
    if (!this._node) {
      return;
    }
    this._node.position = this._position;
  }
  /** Gets or sets the control scaling in world space */
  get scaling() {
    if (!this._node) {
      this._scaling = this.scaling || new Vector3(1, 1, 1);
      return this._scaling;
    }
    return this._node.scaling;
  }
  set scaling(value) {
    this._scaling = value;
    if (!this._node) {
      return;
    }
    this._isScaledByManager = false;
    this._node.scaling = this._scaling;
  }
  /**
   * Gets the list of attached behaviors
   * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors
   */
  get behaviors() {
    return this._behaviors;
  }
  /**
   * Attach a behavior to the control
   * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors
   * @param behavior defines the behavior to attach
   * @returns the current control
   */
  addBehavior(behavior) {
    const index = this._behaviors.indexOf(behavior);
    if (index !== -1) {
      return this;
    }
    behavior.init();
    const scene = this._host.scene;
    if (scene.isLoading) {
      scene.onDataLoadedObservable.addOnce(() => {
        behavior.attach(this);
      });
    } else {
      behavior.attach(this);
    }
    this._behaviors.push(behavior);
    return this;
  }
  /**
   * Remove an attached behavior
   * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors
   * @param behavior defines the behavior to attach
   * @returns the current control
   */
  removeBehavior(behavior) {
    const index = this._behaviors.indexOf(behavior);
    if (index === -1) {
      return this;
    }
    this._behaviors[index].detach();
    this._behaviors.splice(index, 1);
    return this;
  }
  /**
   * Gets an attached behavior by name
   * @param name defines the name of the behavior to look for
   * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors
   * @returns null if behavior was not found else the requested behavior
   */
  getBehaviorByName(name22) {
    for (const behavior of this._behaviors) {
      if (behavior.name === name22) {
        return behavior;
      }
    }
    return null;
  }
  /** Gets or sets a boolean indicating if the control is visible */
  get isVisible() {
    return this._isVisible;
  }
  set isVisible(value) {
    if (this._isVisible === value) {
      return;
    }
    this._isVisible = value;
    const mesh = this.mesh;
    if (mesh) {
      mesh.setEnabled(value);
    }
  }
  /**
   * Creates a new control
   * @param name defines the control name
   */
  constructor(name22) {
    this.name = name22;
    this._downCount = 0;
    this._enterCount = -1;
    this._downPointerIds = {};
    this._isVisible = true;
    this._isScaledByManager = false;
    this.onPointerMoveObservable = new Observable();
    this.onPointerOutObservable = new Observable();
    this.onPointerDownObservable = new Observable();
    this.onPointerUpObservable = new Observable();
    this.onPointerClickObservable = new Observable();
    this.onPointerEnterObservable = new Observable();
    this._behaviors = new Array();
  }
  /**
   * Gets a string representing the class name
   */
  get typeName() {
    return this._getTypeName();
  }
  /**
   * Get the current class name of the control.
   * @returns current class name
   */
  getClassName() {
    return this._getTypeName();
  }
  _getTypeName() {
    return "Control3D";
  }
  /**
   * Gets the transform node used by this control
   */
  get node() {
    return this._node;
  }
  /**
   * Gets the mesh used to render this control
   */
  get mesh() {
    if (this._node instanceof AbstractMesh) {
      return this._node;
    }
    return null;
  }
  /**
   * Link the control as child of the given node
   * @param node defines the node to link to. Use null to unlink the control
   * @returns the current control
   */
  linkToTransformNode(node) {
    if (this._node) {
      this._node.parent = node;
    }
    return this;
  }
  /**
   * @internal
   */
  _prepareNode(scene) {
    if (!this._node) {
      this._node = this._createNode(scene);
      if (!this.node) {
        return;
      }
      if (this._position) {
        this.node.position = this._position;
      }
      if (this._scaling) {
        this.node.scaling = this._scaling;
      }
      this._injectGUI3DReservedDataStore(this.node).control = this;
      const mesh = this.mesh;
      if (mesh) {
        mesh.isPickable = true;
        this._affectMaterial(mesh);
      }
    }
  }
  _injectGUI3DReservedDataStore(node) {
    node.reservedDataStore = node.reservedDataStore ?? {};
    node.reservedDataStore.GUI3D = node.reservedDataStore.GUI3D ?? {};
    return node.reservedDataStore.GUI3D;
  }
  /**
   * Node creation.
   * Can be overriden by children
   * @param scene defines the scene where the node must be attached
   * @returns the attached node or null if none. Must return a Mesh or AbstractMesh if there is an attached visible object
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _createNode(scene) {
    return null;
  }
  /**
   * Affect a material to the given mesh
   * @param mesh defines the mesh which will represent the control
   */
  _affectMaterial(mesh) {
    mesh.material = null;
  }
  _isTouchButton3D(control) {
    return control._generatePointerEventType !== void 0;
  }
  // Pointers
  /**
   * @internal
   */
  _onPointerMove(target, coordinates) {
    this.onPointerMoveObservable.notifyObservers(coordinates, -1, target, this);
  }
  /**
   * @internal
   */
  _onPointerEnter(target) {
    if (this._enterCount === -1) {
      this._enterCount = 0;
    }
    this._enterCount++;
    if (this._enterCount > 1) {
      return false;
    }
    this.onPointerEnterObservable.notifyObservers(this, -1, target, this);
    if (this.pointerEnterAnimation) {
      this.pointerEnterAnimation();
    }
    return true;
  }
  /**
   * @internal
   */
  _onPointerOut(target) {
    this._enterCount--;
    if (this._enterCount > 0) {
      return;
    }
    this._enterCount = 0;
    this.onPointerOutObservable.notifyObservers(this, -1, target, this);
    if (this.pointerOutAnimation) {
      this.pointerOutAnimation();
    }
  }
  /**
   * @internal
   */
  _onPointerDown(target, coordinates, pointerId, buttonIndex) {
    this._downCount++;
    this._downPointerIds[pointerId] = this._downPointerIds[pointerId] + 1 || 1;
    if (this._downCount !== 1) {
      return false;
    }
    this.onPointerDownObservable.notifyObservers(new Vector3WithInfo(coordinates, buttonIndex), -1, target, this);
    if (this.pointerDownAnimation) {
      this.pointerDownAnimation();
    }
    return true;
  }
  /**
   * @internal
   */
  _onPointerUp(target, coordinates, pointerId, buttonIndex, notifyClick) {
    this._downCount--;
    this._downPointerIds[pointerId]--;
    if (this._downPointerIds[pointerId] <= 0) {
      delete this._downPointerIds[pointerId];
    }
    if (this._downCount < 0) {
      this._downCount = 0;
      return;
    }
    if (this._downCount == 0) {
      if (notifyClick && (this._enterCount > 0 || this._enterCount === -1)) {
        this.onPointerClickObservable.notifyObservers(new Vector3WithInfo(coordinates, buttonIndex), -1, target, this);
      }
      this.onPointerUpObservable.notifyObservers(new Vector3WithInfo(coordinates, buttonIndex), -1, target, this);
      if (this.pointerUpAnimation) {
        this.pointerUpAnimation();
      }
    }
  }
  /**
   * @internal
   */
  forcePointerUp(pointerId = null) {
    if (pointerId !== null) {
      this._onPointerUp(this, Vector3.Zero(), pointerId, 0, true);
    } else {
      for (const key in this._downPointerIds) {
        this._onPointerUp(this, Vector3.Zero(), +key, 0, true);
      }
      if (this._downCount > 0) {
        this._downCount = 1;
        this._onPointerUp(this, Vector3.Zero(), 0, 0, true);
      }
    }
  }
  /**
   * @internal
   */
  _processObservables(type, pickedPoint, originMeshPosition, pointerId, buttonIndex) {
    if (this._isTouchButton3D(this) && originMeshPosition) {
      type = this._generatePointerEventType(type, originMeshPosition, this._downCount);
    }
    if (type === PointerEventTypes.POINTERMOVE) {
      this._onPointerMove(this, pickedPoint);
      const previousControlOver = this._host._lastControlOver[pointerId];
      if (previousControlOver && previousControlOver !== this) {
        previousControlOver._onPointerOut(this);
      }
      if (previousControlOver !== this) {
        this._onPointerEnter(this);
      }
      this._host._lastControlOver[pointerId] = this;
      return true;
    }
    if (type === PointerEventTypes.POINTERDOWN) {
      this._onPointerDown(this, pickedPoint, pointerId, buttonIndex);
      this._host._lastControlDown[pointerId] = this;
      this._host._lastPickedControl = this;
      return true;
    }
    if (type === PointerEventTypes.POINTERUP || type === PointerEventTypes.POINTERDOUBLETAP) {
      if (this._host._lastControlDown[pointerId]) {
        this._host._lastControlDown[pointerId]._onPointerUp(this, pickedPoint, pointerId, buttonIndex, true);
      }
      delete this._host._lastControlDown[pointerId];
      return true;
    }
    return false;
  }
  /** @internal */
  _disposeNode() {
    if (this._node) {
      this._node.dispose();
      this._node = null;
    }
  }
  /**
   * Releases all associated resources
   */
  dispose() {
    this.onPointerDownObservable.clear();
    this.onPointerEnterObservable.clear();
    this.onPointerMoveObservable.clear();
    this.onPointerOutObservable.clear();
    this.onPointerUpObservable.clear();
    this.onPointerClickObservable.clear();
    this._disposeNode();
    for (const behavior of this._behaviors) {
      behavior.detach();
    }
  }
};

// node_modules/@babylonjs/gui/3D/controls/contentDisplay3D.js
var ContentDisplay3D = class extends Control3D {
  constructor() {
    super(...arguments);
    this._contentResolution = 512;
    this._contentScaleRatio = 2;
  }
  /**
   * Gets or sets the GUI 2D content used to display the button's facade
   */
  get content() {
    return this._content;
  }
  set content(value) {
    this._content = value;
    if (!value || !this._host || !this._host.utilityLayer) {
      return;
    }
    if (!this._facadeTexture) {
      const width = typeof this._contentResolution === "number" ? this._contentResolution : this._contentResolution.width;
      const height = typeof this._contentResolution === "number" ? this._contentResolution : this._contentResolution.height;
      this._facadeTexture = new AdvancedDynamicTexture("Facade", width, height, this._host.utilityLayer.utilityLayerScene, true, Texture.TRILINEAR_SAMPLINGMODE);
      this._setFacadeTextureScaling();
      this._facadeTexture.premulAlpha = true;
    } else {
      this._facadeTexture.rootContainer.clearControls();
    }
    this._facadeTexture.addControl(value);
    this._applyFacade(this._facadeTexture);
  }
  _setFacadeTextureScaling() {
    if (this._facadeTexture) {
      if (typeof this._contentResolution !== "number") {
        this._contentScaleRatioY = this._contentResolution.height / this._contentResolution.width * this._contentScaleRatio;
      }
      this._facadeTexture.rootContainer.scaleX = this._contentScaleRatio;
      this._facadeTexture.rootContainer.scaleY = this._contentScaleRatioY ?? this._contentScaleRatio;
    }
  }
  /**
   * Gets or sets the texture resolution used to render content (512 by default)
   */
  get contentResolution() {
    return this._contentResolution;
  }
  set contentResolution(value) {
    const incomingWidth = typeof value === "number" ? value : value.width;
    const incomingHeight = typeof value === "number" ? value : value.height;
    const currentWidth = typeof this._contentResolution === "number" ? this._contentResolution : this._contentResolution.width;
    const currentHeight = typeof this._contentResolution === "number" ? this._contentResolution : this._contentResolution.height;
    if (incomingWidth === currentWidth && incomingHeight === currentHeight) {
      return;
    }
    this._contentResolution = value;
    this._resetContent();
  }
  _disposeFacadeTexture() {
    if (this._facadeTexture) {
      this._facadeTexture.dispose();
      this._facadeTexture = null;
    }
  }
  _resetContent() {
    this._disposeFacadeTexture();
    this.content = this._content;
  }
  /**
   * Apply the facade texture (created from the content property).
   * This function can be overloaded by child classes
   * @param facadeTexture defines the AdvancedDynamicTexture to use
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _applyFacade(facadeTexture) {
  }
};

// node_modules/@babylonjs/gui/3D/controls/abstractButton3D.js
var AbstractButton3D = class extends ContentDisplay3D {
  /**
   * Creates a new button
   * @param name defines the control name
   */
  constructor(name22) {
    super(name22);
  }
  _getTypeName() {
    return "AbstractButton3D";
  }
  // Mesh association
  _createNode(scene) {
    return new TransformNode("button" + this.name, scene);
  }
};

// node_modules/@babylonjs/core/Meshes/groundMesh.js
Mesh._GroundMeshParser = (parsedMesh, scene) => {
  return GroundMesh.Parse(parsedMesh, scene);
};
var GroundMesh = class _GroundMesh extends Mesh {
  constructor(name22, scene) {
    super(name22, scene);
    this.generateOctree = false;
  }
  /**
   * "GroundMesh"
   * @returns "GroundMesh"
   */
  getClassName() {
    return "GroundMesh";
  }
  /**
   * The minimum of x and y subdivisions
   */
  get subdivisions() {
    return Math.min(this._subdivisionsX, this._subdivisionsY);
  }
  /**
   * X subdivisions
   */
  get subdivisionsX() {
    return this._subdivisionsX;
  }
  /**
   * Y subdivisions
   */
  get subdivisionsY() {
    return this._subdivisionsY;
  }
  /**
   * This function will divide the mesh into submeshes and update an octree to help to select the right submeshes
   * for rendering, picking and collision computations. Please note that you must have a decent number of submeshes
   * to get performance improvements when using an octree.
   * @param chunksCount the number of submeshes the mesh will be divided into
   * @param octreeBlocksSize the maximum size of the octree blocks (Default: 32)
   */
  optimize(chunksCount, octreeBlocksSize = 32) {
    this._subdivisionsX = chunksCount;
    this._subdivisionsY = chunksCount;
    this.subdivide(chunksCount);
    const thisAsAny = this;
    if (thisAsAny.createOrUpdateSubmeshesOctree) {
      thisAsAny.createOrUpdateSubmeshesOctree(octreeBlocksSize);
    }
  }
  /**
   * Returns a height (y) value in the World system :
   * the ground altitude at the coordinates (x, z) expressed in the World system.
   * @param x x coordinate
   * @param z z coordinate
   * @returns the ground y position if (x, z) are outside the ground surface.
   */
  getHeightAtCoordinates(x, z) {
    const world = this.getWorldMatrix();
    const invMat = TmpVectors.Matrix[5];
    world.invertToRef(invMat);
    const tmpVect = TmpVectors.Vector3[8];
    Vector3.TransformCoordinatesFromFloatsToRef(x, 0, z, invMat, tmpVect);
    x = tmpVect.x;
    z = tmpVect.z;
    if (x < this._minX || x >= this._maxX || z <= this._minZ || z > this._maxZ) {
      return this.position.y;
    }
    if (!this._heightQuads || this._heightQuads.length == 0) {
      this._initHeightQuads();
      this._computeHeightQuads();
    }
    const facet = this._getFacetAt(x, z);
    const y = -(facet.x * x + facet.z * z + facet.w) / facet.y;
    Vector3.TransformCoordinatesFromFloatsToRef(0, y, 0, world, tmpVect);
    return tmpVect.y;
  }
  /**
   * Returns a normalized vector (Vector3) orthogonal to the ground
   * at the ground coordinates (x, z) expressed in the World system.
   * @param x x coordinate
   * @param z z coordinate
   * @returns Vector3(0.0, 1.0, 0.0) if (x, z) are outside the ground surface.
   */
  getNormalAtCoordinates(x, z) {
    const normal = new Vector3(0, 1, 0);
    this.getNormalAtCoordinatesToRef(x, z, normal);
    return normal;
  }
  /**
   * Updates the Vector3 passed a reference with a normalized vector orthogonal to the ground
   * at the ground coordinates (x, z) expressed in the World system.
   * Doesn't update the reference Vector3 if (x, z) are outside the ground surface.
   * @param x x coordinate
   * @param z z coordinate
   * @param ref vector to store the result
   * @returns the GroundMesh.
   */
  getNormalAtCoordinatesToRef(x, z, ref) {
    const world = this.getWorldMatrix();
    const tmpMat = TmpVectors.Matrix[5];
    world.invertToRef(tmpMat);
    const tmpVect = TmpVectors.Vector3[8];
    Vector3.TransformCoordinatesFromFloatsToRef(x, 0, z, tmpMat, tmpVect);
    x = tmpVect.x;
    z = tmpVect.z;
    if (x < this._minX || x > this._maxX || z < this._minZ || z > this._maxZ) {
      return this;
    }
    if (!this._heightQuads || this._heightQuads.length == 0) {
      this._initHeightQuads();
      this._computeHeightQuads();
    }
    const facet = this._getFacetAt(x, z);
    Vector3.TransformNormalFromFloatsToRef(facet.x, facet.y, facet.z, world, ref);
    return this;
  }
  /**
   * Force the heights to be recomputed for getHeightAtCoordinates() or getNormalAtCoordinates()
   * if the ground has been updated.
   * This can be used in the render loop.
   * @returns the GroundMesh.
   */
  updateCoordinateHeights() {
    if (!this._heightQuads || this._heightQuads.length == 0) {
      this._initHeightQuads();
    }
    this._computeHeightQuads();
    return this;
  }
  // Returns the element "facet" from the heightQuads array relative to (x, z) local coordinates
  _getFacetAt(x, z) {
    const col = Math.floor((x + this._maxX) * this._subdivisionsX / this._width);
    const row = Math.floor(-(z + this._maxZ) * this._subdivisionsY / this._height + this._subdivisionsY);
    const quad = this._heightQuads[row * this._subdivisionsX + col];
    let facet;
    if (z < quad.slope.x * x + quad.slope.y) {
      facet = quad.facet1;
    } else {
      facet = quad.facet2;
    }
    return facet;
  }
  //  Creates and populates the heightMap array with "facet" elements :
  // a quad is two triangular facets separated by a slope, so a "facet" element is 1 slope + 2 facets
  // slope : Vector2(c, h) = 2D diagonal line equation setting apart two triangular facets in a quad : z = cx + h
  // facet1 : Vector4(a, b, c, d) = first facet 3D plane equation : ax + by + cz + d = 0
  // facet2 :  Vector4(a, b, c, d) = second facet 3D plane equation : ax + by + cz + d = 0
  // Returns the GroundMesh.
  _initHeightQuads() {
    const subdivisionsX = this._subdivisionsX;
    const subdivisionsY = this._subdivisionsY;
    this._heightQuads = new Array();
    for (let row = 0; row < subdivisionsY; row++) {
      for (let col = 0; col < subdivisionsX; col++) {
        const quad = { slope: Vector2.Zero(), facet1: new Vector4(0, 0, 0, 0), facet2: new Vector4(0, 0, 0, 0) };
        this._heightQuads[row * subdivisionsX + col] = quad;
      }
    }
    return this;
  }
  // Compute each quad element values and update the heightMap array :
  // slope : Vector2(c, h) = 2D diagonal line equation setting apart two triangular facets in a quad : z = cx + h
  // facet1 : Vector4(a, b, c, d) = first facet 3D plane equation : ax + by + cz + d = 0
  // facet2 :  Vector4(a, b, c, d) = second facet 3D plane equation : ax + by + cz + d = 0
  // Returns the GroundMesh.
  _computeHeightQuads() {
    const positions = this.getVerticesData(VertexBuffer.PositionKind);
    if (!positions) {
      return this;
    }
    const v1 = TmpVectors.Vector3[3];
    const v2 = TmpVectors.Vector3[2];
    const v3 = TmpVectors.Vector3[1];
    const v4 = TmpVectors.Vector3[0];
    const v1v2 = TmpVectors.Vector3[4];
    const v1v3 = TmpVectors.Vector3[5];
    const v1v4 = TmpVectors.Vector3[6];
    const norm1 = TmpVectors.Vector3[7];
    const norm2 = TmpVectors.Vector3[8];
    let i = 0;
    let j = 0;
    let k = 0;
    let cd = 0;
    let h = 0;
    let d1 = 0;
    let d2 = 0;
    const subdivisionsX = this._subdivisionsX;
    const subdivisionsY = this._subdivisionsY;
    for (let row = 0; row < subdivisionsY; row++) {
      for (let col = 0; col < subdivisionsX; col++) {
        i = col * 3;
        j = row * (subdivisionsX + 1) * 3;
        k = (row + 1) * (subdivisionsX + 1) * 3;
        v1.x = positions[j + i];
        v1.y = positions[j + i + 1];
        v1.z = positions[j + i + 2];
        v2.x = positions[j + i + 3];
        v2.y = positions[j + i + 4];
        v2.z = positions[j + i + 5];
        v3.x = positions[k + i];
        v3.y = positions[k + i + 1];
        v3.z = positions[k + i + 2];
        v4.x = positions[k + i + 3];
        v4.y = positions[k + i + 4];
        v4.z = positions[k + i + 5];
        cd = (v4.z - v1.z) / (v4.x - v1.x);
        h = v1.z - cd * v1.x;
        v2.subtractToRef(v1, v1v2);
        v3.subtractToRef(v1, v1v3);
        v4.subtractToRef(v1, v1v4);
        Vector3.CrossToRef(v1v4, v1v3, norm1);
        Vector3.CrossToRef(v1v2, v1v4, norm2);
        norm1.normalize();
        norm2.normalize();
        d1 = -(norm1.x * v1.x + norm1.y * v1.y + norm1.z * v1.z);
        d2 = -(norm2.x * v2.x + norm2.y * v2.y + norm2.z * v2.z);
        const quad = this._heightQuads[row * subdivisionsX + col];
        quad.slope.copyFromFloats(cd, h);
        quad.facet1.copyFromFloats(norm1.x, norm1.y, norm1.z, d1);
        quad.facet2.copyFromFloats(norm2.x, norm2.y, norm2.z, d2);
      }
    }
    return this;
  }
  /**
   * Serializes this ground mesh
   * @param serializationObject object to write serialization to
   */
  serialize(serializationObject) {
    super.serialize(serializationObject);
    serializationObject.subdivisionsX = this._subdivisionsX;
    serializationObject.subdivisionsY = this._subdivisionsY;
    serializationObject.minX = this._minX;
    serializationObject.maxX = this._maxX;
    serializationObject.minZ = this._minZ;
    serializationObject.maxZ = this._maxZ;
    serializationObject.width = this._width;
    serializationObject.height = this._height;
  }
  /**
   * Parses a serialized ground mesh
   * @param parsedMesh the serialized mesh
   * @param scene the scene to create the ground mesh in
   * @returns the created ground mesh
   */
  static Parse(parsedMesh, scene) {
    const result = new _GroundMesh(parsedMesh.name, scene);
    result._subdivisionsX = parsedMesh.subdivisionsX || 1;
    result._subdivisionsY = parsedMesh.subdivisionsY || 1;
    result._minX = parsedMesh.minX;
    result._maxX = parsedMesh.maxX;
    result._minZ = parsedMesh.minZ;
    result._maxZ = parsedMesh.maxZ;
    result._width = parsedMesh.width;
    result._height = parsedMesh.height;
    return result;
  }
};

// node_modules/@babylonjs/core/Meshes/Builders/groundBuilder.js
function CreateGroundVertexData(options) {
  const indices = [];
  const positions = [];
  const normals = [];
  const uvs = [];
  let row, col;
  const width = options.width || options.size || 1;
  const height = options.height || options.size || 1;
  const subdivisionsX = (options.subdivisionsX || options.subdivisions || 1) | 0;
  const subdivisionsY = (options.subdivisionsY || options.subdivisions || 1) | 0;
  for (row = 0; row <= subdivisionsY; row++) {
    for (col = 0; col <= subdivisionsX; col++) {
      const position = new Vector3(col * width / subdivisionsX - width / 2, 0, (subdivisionsY - row) * height / subdivisionsY - height / 2);
      const normal = new Vector3(0, 1, 0);
      positions.push(position.x, position.y, position.z);
      normals.push(normal.x, normal.y, normal.z);
      uvs.push(col / subdivisionsX, useOpenGLOrientationForUV ? row / subdivisionsY : 1 - row / subdivisionsY);
    }
  }
  for (row = 0; row < subdivisionsY; row++) {
    for (col = 0; col < subdivisionsX; col++) {
      indices.push(col + 1 + (row + 1) * (subdivisionsX + 1));
      indices.push(col + 1 + row * (subdivisionsX + 1));
      indices.push(col + row * (subdivisionsX + 1));
      indices.push(col + (row + 1) * (subdivisionsX + 1));
      indices.push(col + 1 + (row + 1) * (subdivisionsX + 1));
      indices.push(col + row * (subdivisionsX + 1));
    }
  }
  const vertexData = new VertexData();
  vertexData.indices = indices;
  vertexData.positions = positions;
  vertexData.normals = normals;
  vertexData.uvs = uvs;
  return vertexData;
}
function CreateTiledGroundVertexData(options) {
  const xmin = options.xmin !== void 0 && options.xmin !== null ? options.xmin : -1;
  const zmin = options.zmin !== void 0 && options.zmin !== null ? options.zmin : -1;
  const xmax = options.xmax !== void 0 && options.xmax !== null ? options.xmax : 1;
  const zmax = options.zmax !== void 0 && options.zmax !== null ? options.zmax : 1;
  const subdivisions = options.subdivisions || { w: 1, h: 1 };
  const precision = options.precision || { w: 1, h: 1 };
  const indices = [];
  const positions = [];
  const normals = [];
  const uvs = [];
  let row, col, tileRow, tileCol;
  subdivisions.h = subdivisions.h < 1 ? 1 : subdivisions.h;
  subdivisions.w = subdivisions.w < 1 ? 1 : subdivisions.w;
  precision.w = precision.w < 1 ? 1 : precision.w;
  precision.h = precision.h < 1 ? 1 : precision.h;
  const tileSize = {
    w: (xmax - xmin) / subdivisions.w,
    h: (zmax - zmin) / subdivisions.h
  };
  function applyTile(xTileMin, zTileMin, xTileMax, zTileMax) {
    const base = positions.length / 3;
    const rowLength = precision.w + 1;
    for (row = 0; row < precision.h; row++) {
      for (col = 0; col < precision.w; col++) {
        const square = [base + col + row * rowLength, base + (col + 1) + row * rowLength, base + (col + 1) + (row + 1) * rowLength, base + col + (row + 1) * rowLength];
        indices.push(square[1]);
        indices.push(square[2]);
        indices.push(square[3]);
        indices.push(square[0]);
        indices.push(square[1]);
        indices.push(square[3]);
      }
    }
    const position = Vector3.Zero();
    const normal = new Vector3(0, 1, 0);
    for (row = 0; row <= precision.h; row++) {
      position.z = row * (zTileMax - zTileMin) / precision.h + zTileMin;
      for (col = 0; col <= precision.w; col++) {
        position.x = col * (xTileMax - xTileMin) / precision.w + xTileMin;
        position.y = 0;
        positions.push(position.x, position.y, position.z);
        normals.push(normal.x, normal.y, normal.z);
        uvs.push(col / precision.w, row / precision.h);
      }
    }
  }
  for (tileRow = 0; tileRow < subdivisions.h; tileRow++) {
    for (tileCol = 0; tileCol < subdivisions.w; tileCol++) {
      applyTile(xmin + tileCol * tileSize.w, zmin + tileRow * tileSize.h, xmin + (tileCol + 1) * tileSize.w, zmin + (tileRow + 1) * tileSize.h);
    }
  }
  const vertexData = new VertexData();
  vertexData.indices = indices;
  vertexData.positions = positions;
  vertexData.normals = normals;
  vertexData.uvs = uvs;
  return vertexData;
}
function CreateGroundFromHeightMapVertexData(options) {
  const indices = [];
  const positions = [];
  const normals = [];
  const uvs = [];
  let row, col;
  const filter = options.colorFilter || new Color3(0.3, 0.59, 0.11);
  const alphaFilter = options.alphaFilter || 0;
  let invert = false;
  if (options.minHeight > options.maxHeight) {
    invert = true;
    const temp = options.maxHeight;
    options.maxHeight = options.minHeight;
    options.minHeight = temp;
  }
  for (row = 0; row <= options.subdivisions; row++) {
    for (col = 0; col <= options.subdivisions; col++) {
      const position = new Vector3(col * options.width / options.subdivisions - options.width / 2, 0, (options.subdivisions - row) * options.height / options.subdivisions - options.height / 2);
      const heightMapX = (position.x + options.width / 2) / options.width * (options.bufferWidth - 1) | 0;
      const heightMapY = (1 - (position.z + options.height / 2) / options.height) * (options.bufferHeight - 1) | 0;
      const pos = (heightMapX + heightMapY * options.bufferWidth) * 4;
      let r = options.buffer[pos] / 255;
      let g = options.buffer[pos + 1] / 255;
      let b = options.buffer[pos + 2] / 255;
      const a = options.buffer[pos + 3] / 255;
      if (invert) {
        r = 1 - r;
        g = 1 - g;
        b = 1 - b;
      }
      const gradient = r * filter.r + g * filter.g + b * filter.b;
      if (a >= alphaFilter) {
        position.y = options.minHeight + (options.maxHeight - options.minHeight) * gradient;
      } else {
        position.y = options.minHeight - Epsilon;
      }
      if (options.heightBuffer) {
        options.heightBuffer[row * (options.subdivisions + 1) + col] = position.y;
      }
      positions.push(position.x, position.y, position.z);
      normals.push(0, 0, 0);
      uvs.push(col / options.subdivisions, 1 - row / options.subdivisions);
    }
  }
  for (row = 0; row < options.subdivisions; row++) {
    for (col = 0; col < options.subdivisions; col++) {
      const idx1 = col + 1 + (row + 1) * (options.subdivisions + 1);
      const idx2 = col + 1 + row * (options.subdivisions + 1);
      const idx3 = col + row * (options.subdivisions + 1);
      const idx4 = col + (row + 1) * (options.subdivisions + 1);
      const isVisibleIdx1 = positions[idx1 * 3 + 1] >= options.minHeight;
      const isVisibleIdx2 = positions[idx2 * 3 + 1] >= options.minHeight;
      const isVisibleIdx3 = positions[idx3 * 3 + 1] >= options.minHeight;
      if (isVisibleIdx1 && isVisibleIdx2 && isVisibleIdx3) {
        indices.push(idx1);
        indices.push(idx2);
        indices.push(idx3);
      }
      const isVisibleIdx4 = positions[idx4 * 3 + 1] >= options.minHeight;
      if (isVisibleIdx4 && isVisibleIdx1 && isVisibleIdx3) {
        indices.push(idx4);
        indices.push(idx1);
        indices.push(idx3);
      }
    }
  }
  VertexData.ComputeNormals(positions, indices, normals);
  const vertexData = new VertexData();
  vertexData.indices = indices;
  vertexData.positions = positions;
  vertexData.normals = normals;
  vertexData.uvs = uvs;
  return vertexData;
}
function CreateGround(name22, options = {}, scene) {
  const ground = new GroundMesh(name22, scene);
  ground._setReady(false);
  ground._subdivisionsX = options.subdivisionsX || options.subdivisions || 1;
  ground._subdivisionsY = options.subdivisionsY || options.subdivisions || 1;
  ground._width = options.width || 1;
  ground._height = options.height || 1;
  ground._maxX = ground._width / 2;
  ground._maxZ = ground._height / 2;
  ground._minX = -ground._maxX;
  ground._minZ = -ground._maxZ;
  const vertexData = CreateGroundVertexData(options);
  vertexData.applyToMesh(ground, options.updatable);
  ground._setReady(true);
  return ground;
}
function CreateTiledGround(name22, options, scene = null) {
  const tiledGround = new Mesh(name22, scene);
  const vertexData = CreateTiledGroundVertexData(options);
  vertexData.applyToMesh(tiledGround, options.updatable);
  return tiledGround;
}
function CreateGroundFromHeightMap(name22, url, options = {}, scene = null) {
  const width = options.width || 10;
  const height = options.height || 10;
  const subdivisions = options.subdivisions || 1 | 0;
  const minHeight = options.minHeight || 0;
  const maxHeight = options.maxHeight || 1;
  const filter = options.colorFilter || new Color3(0.3, 0.59, 0.11);
  const alphaFilter = options.alphaFilter || 0;
  const updatable = options.updatable;
  const onReady = options.onReady;
  scene = scene || EngineStore.LastCreatedScene;
  const ground = new GroundMesh(name22, scene);
  ground._subdivisionsX = subdivisions;
  ground._subdivisionsY = subdivisions;
  ground._width = width;
  ground._height = height;
  ground._maxX = ground._width / 2;
  ground._maxZ = ground._height / 2;
  ground._minX = -ground._maxX;
  ground._minZ = -ground._maxZ;
  ground._setReady(false);
  let heightBuffer;
  if (options.passHeightBufferInCallback) {
    heightBuffer = new Float32Array((subdivisions + 1) * (subdivisions + 1));
  }
  const onBufferLoaded = (buffer, bufferWidth, bufferHeight) => {
    const vertexData = CreateGroundFromHeightMapVertexData({
      width,
      height,
      subdivisions,
      minHeight,
      maxHeight,
      colorFilter: filter,
      buffer,
      bufferWidth,
      bufferHeight,
      alphaFilter,
      heightBuffer
    });
    vertexData.applyToMesh(ground, updatable);
    if (onReady) {
      onReady(ground, heightBuffer);
    }
    ground._setReady(true);
  };
  if (typeof url === "string") {
    const onload = (img) => {
      const bufferWidth = img.width;
      const bufferHeight = img.height;
      if (scene.isDisposed) {
        return;
      }
      const buffer = scene == null ? void 0 : scene.getEngine().resizeImageBitmap(img, bufferWidth, bufferHeight);
      onBufferLoaded(buffer, bufferWidth, bufferHeight);
    };
    Tools.LoadImage(url, onload, options.onError ? options.onError : () => {
    }, scene.offlineProvider);
  } else {
    onBufferLoaded(url.data, url.width, url.height);
  }
  return ground;
}
VertexData.CreateGround = CreateGroundVertexData;
VertexData.CreateTiledGround = CreateTiledGroundVertexData;
VertexData.CreateGroundFromHeightMap = CreateGroundFromHeightMapVertexData;
Mesh.CreateGround = (name22, width, height, subdivisions, scene, updatable) => {
  const options = {
    width,
    height,
    subdivisions,
    updatable
  };
  return CreateGround(name22, options, scene);
};
Mesh.CreateTiledGround = (name22, xmin, zmin, xmax, zmax, subdivisions, precision, scene, updatable) => {
  const options = {
    xmin,
    zmin,
    xmax,
    zmax,
    subdivisions,
    precision,
    updatable
  };
  return CreateTiledGround(name22, options, scene);
};
Mesh.CreateGroundFromHeightMap = (name22, url, width, height, subdivisions, minHeight, maxHeight, scene, updatable, onReady, alphaFilter) => {
  const options = {
    width,
    height,
    subdivisions,
    minHeight,
    maxHeight,
    updatable,
    onReady,
    alphaFilter
  };
  return CreateGroundFromHeightMap(name22, url, options, scene);
};

// node_modules/@babylonjs/core/Meshes/Builders/boxBuilder.js
function CreateBoxVertexData(options) {
  const nbFaces = 6;
  let indices = [0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23];
  const normals = [
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    1,
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    0,
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    0
  ];
  const uvs = [];
  let positions = [];
  const width = options.width || options.size || 1;
  const height = options.height || options.size || 1;
  const depth = options.depth || options.size || 1;
  const wrap = options.wrap || false;
  let topBaseAt = options.topBaseAt === void 0 ? 1 : options.topBaseAt;
  let bottomBaseAt = options.bottomBaseAt === void 0 ? 0 : options.bottomBaseAt;
  topBaseAt = (topBaseAt + 4) % 4;
  bottomBaseAt = (bottomBaseAt + 4) % 4;
  const topOrder = [2, 0, 3, 1];
  const bottomOrder = [2, 0, 1, 3];
  let topIndex = topOrder[topBaseAt];
  let bottomIndex = bottomOrder[bottomBaseAt];
  let basePositions = [
    1,
    -1,
    1,
    -1,
    -1,
    1,
    -1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    -1,
    -1,
    1,
    -1,
    -1,
    -1,
    -1,
    1,
    -1,
    -1,
    1,
    1,
    -1,
    1,
    -1,
    -1,
    1,
    -1,
    1,
    1,
    1,
    1,
    -1,
    1,
    1,
    -1,
    -1,
    1,
    -1,
    -1,
    -1,
    -1,
    1,
    -1,
    -1,
    1,
    1,
    -1,
    1,
    -1,
    1,
    1,
    -1,
    1,
    1,
    1,
    1,
    -1,
    1,
    1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1
  ];
  if (wrap) {
    indices = [2, 3, 0, 2, 0, 1, 4, 5, 6, 4, 6, 7, 9, 10, 11, 9, 11, 8, 12, 14, 15, 12, 13, 14];
    basePositions = [
      -1,
      1,
      1,
      1,
      1,
      1,
      1,
      -1,
      1,
      -1,
      -1,
      1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      -1,
      -1,
      -1,
      1,
      -1,
      -1,
      1,
      1,
      1,
      1,
      1,
      -1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      -1,
      1,
      -1,
      -1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      -1,
      -1
    ];
    let topFaceBase = [
      [1, 1, 1],
      [-1, 1, 1],
      [-1, 1, -1],
      [1, 1, -1]
    ];
    let bottomFaceBase = [
      [-1, -1, 1],
      [1, -1, 1],
      [1, -1, -1],
      [-1, -1, -1]
    ];
    const topFaceOrder = [17, 18, 19, 16];
    const bottomFaceOrder = [22, 23, 20, 21];
    while (topIndex > 0) {
      topFaceBase.unshift(topFaceBase.pop());
      topFaceOrder.unshift(topFaceOrder.pop());
      topIndex--;
    }
    while (bottomIndex > 0) {
      bottomFaceBase.unshift(bottomFaceBase.pop());
      bottomFaceOrder.unshift(bottomFaceOrder.pop());
      bottomIndex--;
    }
    topFaceBase = topFaceBase.flat();
    bottomFaceBase = bottomFaceBase.flat();
    basePositions = basePositions.concat(topFaceBase).concat(bottomFaceBase);
    indices.push(topFaceOrder[0], topFaceOrder[2], topFaceOrder[3], topFaceOrder[0], topFaceOrder[1], topFaceOrder[2]);
    indices.push(bottomFaceOrder[0], bottomFaceOrder[2], bottomFaceOrder[3], bottomFaceOrder[0], bottomFaceOrder[1], bottomFaceOrder[2]);
  }
  const scaleArray = [width / 2, height / 2, depth / 2];
  positions = basePositions.reduce((accumulator, currentValue, currentIndex) => accumulator.concat(currentValue * scaleArray[currentIndex % 3]), []);
  const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;
  const faceUV = options.faceUV || new Array(6);
  const faceColors = options.faceColors;
  const colors = [];
  for (let f = 0; f < 6; f++) {
    if (faceUV[f] === void 0) {
      faceUV[f] = new Vector4(0, 0, 1, 1);
    }
    if (faceColors && faceColors[f] === void 0) {
      faceColors[f] = new Color4(1, 1, 1, 1);
    }
  }
  for (let index = 0; index < nbFaces; index++) {
    uvs.push(faceUV[index].z, useOpenGLOrientationForUV ? 1 - faceUV[index].w : faceUV[index].w);
    uvs.push(faceUV[index].x, useOpenGLOrientationForUV ? 1 - faceUV[index].w : faceUV[index].w);
    uvs.push(faceUV[index].x, useOpenGLOrientationForUV ? 1 - faceUV[index].y : faceUV[index].y);
    uvs.push(faceUV[index].z, useOpenGLOrientationForUV ? 1 - faceUV[index].y : faceUV[index].y);
    if (faceColors) {
      for (let c = 0; c < 4; c++) {
        colors.push(faceColors[index].r, faceColors[index].g, faceColors[index].b, faceColors[index].a);
      }
    }
  }
  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);
  const vertexData = new VertexData();
  vertexData.indices = indices;
  vertexData.positions = positions;
  vertexData.normals = normals;
  vertexData.uvs = uvs;
  if (faceColors) {
    const totalColors = sideOrientation === VertexData.DOUBLESIDE ? colors.concat(colors) : colors;
    vertexData.colors = totalColors;
  }
  return vertexData;
}
function CreateBox(name22, options = {}, scene = null) {
  const box = new Mesh(name22, scene);
  options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);
  box._originalBuilderSideOrientation = options.sideOrientation;
  const vertexData = CreateBoxVertexData(options);
  vertexData.applyToMesh(box, options.updatable);
  return box;
}
VertexData.CreateBox = CreateBoxVertexData;
Mesh.CreateBox = (name22, size, scene = null, updatable, sideOrientation) => {
  const options = {
    size,
    sideOrientation,
    updatable
  };
  return CreateBox(name22, options, scene);
};

// node_modules/@babylonjs/gui/3D/controls/button3D.js
var Button3D = class extends AbstractButton3D {
  /**
   * Creates a new button
   * @param name defines the control name
   * @param options defines the options used to create the button
   */
  constructor(name22, options) {
    super(name22);
    this._options = {
      width: 1,
      height: 1,
      depth: 0.08,
      ...options
    };
    this.pointerEnterAnimation = () => {
      if (!this.mesh) {
        return;
      }
      this._currentMaterial.emissiveColor = Color3.Red();
    };
    this.pointerOutAnimation = () => {
      this._currentMaterial.emissiveColor = Color3.Black();
    };
    this.pointerDownAnimation = () => {
      if (!this.mesh) {
        return;
      }
      this.mesh.scaling.scaleInPlace(0.95);
    };
    this.pointerUpAnimation = () => {
      if (!this.mesh) {
        return;
      }
      this.mesh.scaling.scaleInPlace(1 / 0.95);
    };
  }
  /**
   * Apply the facade texture (created from the content property).
   * @param facadeTexture defines the AdvancedDynamicTexture to use
   */
  _applyFacade(facadeTexture) {
    this._currentMaterial.emissiveTexture = facadeTexture;
  }
  _getTypeName() {
    return "Button3D";
  }
  // Mesh association
  _createNode(scene) {
    const faceUV = new Array(6);
    for (let i = 0; i < 6; i++) {
      faceUV[i] = new Vector4(0, 0, 0, 0);
    }
    if (scene.useRightHandedSystem) {
      faceUV[0].copyFromFloats(1, 0, 0, 1);
    } else {
      faceUV[1].copyFromFloats(0, 0, 1, 1);
    }
    const mesh = CreateBox(this.name + "_rootMesh", {
      width: this._options.width,
      height: this._options.height,
      depth: this._options.depth,
      faceUV,
      wrap: true
    }, scene);
    this._contentScaleRatioY = this._contentScaleRatio * this._options.width / this._options.height;
    this._setFacadeTextureScaling();
    return mesh;
  }
  _affectMaterial(mesh) {
    const material = new StandardMaterial(this.name + "Material", mesh.getScene());
    material.specularColor = Color3.Black();
    mesh.material = material;
    this._currentMaterial = material;
    this._resetContent();
  }
  /**
   * Releases all associated resources
   */
  dispose() {
    super.dispose();
    this._disposeFacadeTexture();
    if (this._currentMaterial) {
      this._currentMaterial.dispose();
    }
  }
};

// node_modules/@babylonjs/gui/3D/controls/container3D.js
var Container3D = class extends Control3D {
  /**
   * Gets the list of child controls
   */
  get children() {
    return this._children;
  }
  /**
   * Gets or sets a boolean indicating if the layout must be blocked (default is false).
   * This is helpful to optimize layout operation when adding multiple children in a row
   */
  get blockLayout() {
    return this._blockLayout;
  }
  set blockLayout(value) {
    if (this._blockLayout === value) {
      return;
    }
    this._blockLayout = value;
    if (!this._blockLayout) {
      this._arrangeChildren();
    }
  }
  /**
   * Creates a new container
   * @param name defines the container name
   */
  constructor(name22) {
    super(name22);
    this._blockLayout = false;
    this._children = new Array();
  }
  /**
   * Force the container to update the layout. Please note that it will not take blockLayout property in account
   * @returns the current container
   */
  updateLayout() {
    this._arrangeChildren();
    return this;
  }
  /**
   * Gets a boolean indicating if the given control is in the children of this control
   * @param control defines the control to check
   * @returns true if the control is in the child list
   */
  containsControl(control) {
    return this._children.indexOf(control) !== -1;
  }
  /**
   * Adds a control to the children of this control
   * @param control defines the control to add
   * @returns the current container
   */
  addControl(control) {
    const index = this._children.indexOf(control);
    if (index !== -1) {
      return this;
    }
    control.parent = this;
    control._host = this._host;
    this._children.push(control);
    if (this._host.utilityLayer) {
      control._prepareNode(this._host.utilityLayer.utilityLayerScene);
      if (control.node) {
        control.node.parent = this.node;
      }
      if (!this.blockLayout) {
        this._arrangeChildren();
      }
    }
    return this;
  }
  /**
   * This function will be called everytime a new control is added
   */
  _arrangeChildren() {
  }
  _createNode(scene) {
    return new TransformNode("ContainerNode", scene);
  }
  /**
   * Removes a control from the children of this control
   * @param control defines the control to remove
   * @returns the current container
   */
  removeControl(control) {
    const index = this._children.indexOf(control);
    if (index !== -1) {
      this._children.splice(index, 1);
      control.parent = null;
      control._disposeNode();
    }
    return this;
  }
  _getTypeName() {
    return "Container3D";
  }
  /**
   * Releases all associated resources
   */
  dispose() {
    for (const control of this._children) {
      control.dispose();
    }
    this._children.length = 0;
    super.dispose();
  }
};
Container3D.UNSET_ORIENTATION = 0;
Container3D.FACEORIGIN_ORIENTATION = 1;
Container3D.FACEORIGINREVERSED_ORIENTATION = 2;
Container3D.FACEFORWARD_ORIENTATION = 3;
Container3D.FACEFORWARDREVERSED_ORIENTATION = 4;

// node_modules/@babylonjs/gui/3D/controls/volumeBasedPanel.js
var VolumeBasedPanel = class extends Container3D {
  /**
   * Gets or sets the orientation to apply to all controls (BABYLON.Container3D.FaceOriginReversedOrientation by default)
   * | Value | Type                                | Description |
   * | ----- | ----------------------------------- | ----------- |
   * | 0     | UNSET_ORIENTATION                   |  Control rotation will remain unchanged |
   * | 1     | FACEORIGIN_ORIENTATION              |  Control will rotate to make it look at sphere central axis |
   * | 2     | FACEORIGINREVERSED_ORIENTATION      |  Control will rotate to make it look back at sphere central axis |
   * | 3     | FACEFORWARD_ORIENTATION             |  Control will rotate to look at z axis (0, 0, 1) |
   * | 4     | FACEFORWARDREVERSED_ORIENTATION     |  Control will rotate to look at negative z axis (0, 0, -1) |
   */
  get orientation() {
    return this._orientation;
  }
  set orientation(value) {
    if (this._orientation === value) {
      return;
    }
    this._orientation = value;
    Tools.SetImmediate(() => {
      this._arrangeChildren();
    });
  }
  /**
   * Gets or sets the number of columns requested (10 by default).
   * The panel will automatically compute the number of rows based on number of child controls.
   */
  get columns() {
    return this._columns;
  }
  set columns(value) {
    if (this._columns === value) {
      return;
    }
    this._columns = value;
    this._rowThenColum = true;
    Tools.SetImmediate(() => {
      this._arrangeChildren();
    });
  }
  /**
   * Gets or sets a the number of rows requested.
   * The panel will automatically compute the number of columns based on number of child controls.
   */
  get rows() {
    return this._rows;
  }
  set rows(value) {
    if (this._rows === value) {
      return;
    }
    this._rows = value;
    this._rowThenColum = false;
    Tools.SetImmediate(() => {
      this._arrangeChildren();
    });
  }
  /**
   * Creates new VolumeBasedPanel
   * @param name
   */
  constructor(name22) {
    super(name22);
    this._columns = 10;
    this._rows = 0;
    this._rowThenColum = true;
    this._orientation = Container3D.FACEORIGIN_ORIENTATION;
    this.margin = 0;
  }
  _arrangeChildren() {
    this._cellWidth = 0;
    this._cellHeight = 0;
    let rows = 0;
    let columns = 0;
    let controlCount = 0;
    for (const child of this._children) {
      if (!child.mesh) {
        continue;
      }
      controlCount++;
      child.mesh.computeWorldMatrix(true);
      const extendSize = child.mesh.getBoundingInfo().boundingBox.extendSize;
      const descendants = child.mesh.getDescendants(false);
      for (const descendant of descendants) {
        descendant.computeWorldMatrix(true);
        const casted = descendant;
        if (typeof casted.getBoundingInfo === "function") {
          const extendSizeChild = casted.getBoundingInfo().boundingBox.extendSize;
          extendSize.x = Math.max(extendSize.x, extendSizeChild.x);
          extendSize.y = Math.max(extendSize.y, extendSizeChild.y);
          extendSize.z = Math.max(extendSize.z, extendSizeChild.z);
        }
      }
      this._cellWidth = Math.max(this._cellWidth, extendSize.x * 2);
      this._cellHeight = Math.max(this._cellHeight, extendSize.y * 2);
    }
    this._cellWidth += this.margin * 2;
    this._cellHeight += this.margin * 2;
    if (this._rowThenColum) {
      columns = this._columns;
      rows = Math.ceil(controlCount / this._columns);
    } else {
      rows = this._rows;
      columns = Math.ceil(controlCount / this._rows);
    }
    const startOffsetX = columns * 0.5 * this._cellWidth;
    const startOffsetY = rows * 0.5 * this._cellHeight;
    const nodeGrid = [];
    let cellCounter = 0;
    if (this._rowThenColum) {
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < columns; c++) {
          nodeGrid.push(new Vector3(c * this._cellWidth - startOffsetX + this._cellWidth / 2, r * this._cellHeight - startOffsetY + this._cellHeight / 2, 0));
          cellCounter++;
          if (cellCounter > controlCount) {
            break;
          }
        }
      }
    } else {
      for (let c = 0; c < columns; c++) {
        for (let r = 0; r < rows; r++) {
          nodeGrid.push(new Vector3(c * this._cellWidth - startOffsetX + this._cellWidth / 2, r * this._cellHeight - startOffsetY + this._cellHeight / 2, 0));
          cellCounter++;
          if (cellCounter > controlCount) {
            break;
          }
        }
      }
    }
    cellCounter = 0;
    for (const child of this._children) {
      if (!child.mesh) {
        continue;
      }
      this._mapGridNode(child, nodeGrid[cellCounter]);
      cellCounter++;
    }
    this._finalProcessing();
  }
  /** Child classes can implement this function to provide additional processing */
  _finalProcessing() {
  }
};

// node_modules/@babylonjs/gui/3D/controls/cylinderPanel.js
var CylinderPanel = class extends VolumeBasedPanel {
  constructor() {
    super(...arguments);
    this._radius = 5;
  }
  /**
   * Gets or sets the radius of the cylinder where to project controls (5 by default)
   */
  get radius() {
    return this._radius;
  }
  set radius(value) {
    if (this._radius === value) {
      return;
    }
    this._radius = value;
    Tools.SetImmediate(() => {
      this._arrangeChildren();
    });
  }
  _mapGridNode(control, nodePosition) {
    const mesh = control.mesh;
    if (!mesh) {
      return;
    }
    const newPos = this._cylindricalMapping(nodePosition);
    control.position = newPos;
    switch (this.orientation) {
      case Container3D.FACEORIGIN_ORIENTATION:
        mesh.lookAt(new Vector3(2 * newPos.x, newPos.y, 2 * newPos.z));
        break;
      case Container3D.FACEORIGINREVERSED_ORIENTATION:
        mesh.lookAt(new Vector3(-newPos.x, newPos.y, -newPos.z));
        break;
      case Container3D.FACEFORWARD_ORIENTATION:
        break;
      case Container3D.FACEFORWARDREVERSED_ORIENTATION:
        mesh.rotate(
          Axis.Y,
          Math.PI,
          0
          /* Space.LOCAL */
        );
        break;
    }
  }
  _cylindricalMapping(source) {
    const newPos = new Vector3(0, source.y, this._radius);
    const yAngle = source.x / this._radius;
    Matrix.RotationYawPitchRollToRef(yAngle, 0, 0, TmpVectors.Matrix[0]);
    return Vector3.TransformNormal(newPos, TmpVectors.Matrix[0]);
  }
};

// node_modules/@babylonjs/gui/3D/materials/fluent/shaders/fluent.vertex.js
var name2 = "fluentVertexShader";
var shader = `precision highp float;attribute vec3 position;attribute vec3 normal;attribute vec2 uv;uniform mat4 world;uniform mat4 viewProjection;varying vec2 vUV;
#ifdef BORDER
varying vec2 scaleInfo;uniform float borderWidth;uniform vec3 scaleFactor;
#endif
#ifdef HOVERLIGHT
varying vec3 worldPosition;
#endif
void main(void) {vUV=uv;
#ifdef BORDER
vec3 scale=scaleFactor;float minScale=min(min(scale.x,scale.y),scale.z);float maxScale=max(max(scale.x,scale.y),scale.z);float minOverMiddleScale=minScale/(scale.x+scale.y+scale.z-minScale-maxScale);float areaYZ=scale.y*scale.z;float areaXZ=scale.x*scale.z;float areaXY=scale.x*scale.y;float scaledBorderWidth=borderWidth; 
if (abs(normal.x)==1.0) 
{scale.x=scale.y;scale.y=scale.z;if (areaYZ>areaXZ && areaYZ>areaXY)
{scaledBorderWidth*=minOverMiddleScale;}}
else if (abs(normal.y)==1.0) 
{scale.x=scale.z;if (areaXZ>areaXY && areaXZ>areaYZ)
{scaledBorderWidth*=minOverMiddleScale;}}
else 
{if (areaXY>areaYZ && areaXY>areaXZ)
{scaledBorderWidth*=minOverMiddleScale;}}
float scaleRatio=min(scale.x,scale.y)/max(scale.x,scale.y);if (scale.x>scale.y)
{scaleInfo.x=1.0-(scaledBorderWidth*scaleRatio);scaleInfo.y=1.0-scaledBorderWidth;}
else
{scaleInfo.x=1.0-scaledBorderWidth;scaleInfo.y=1.0-(scaledBorderWidth*scaleRatio);} 
#endif 
vec4 worldPos=world*vec4(position,1.0);
#ifdef HOVERLIGHT
worldPosition=worldPos.xyz;
#endif
gl_Position=viewProjection*worldPos;}
`;
ShaderStore.ShadersStore[name2] = shader;

// node_modules/@babylonjs/gui/3D/materials/fluent/shaders/fluent.fragment.js
var name3 = "fluentPixelShader";
var shader2 = `precision highp float;varying vec2 vUV;uniform vec4 albedoColor;
#ifdef INNERGLOW
uniform vec4 innerGlowColor;
#endif
#ifdef BORDER
varying vec2 scaleInfo;uniform float edgeSmoothingValue;uniform float borderMinValue;
#endif
#ifdef HOVERLIGHT
varying vec3 worldPosition;uniform vec3 hoverPosition;uniform vec4 hoverColor;uniform float hoverRadius;
#endif
#ifdef TEXTURE
uniform sampler2D albedoSampler;uniform mat4 textureMatrix;vec2 finalUV;
#endif
void main(void) {vec3 albedo=albedoColor.rgb;float alpha=albedoColor.a;
#ifdef TEXTURE
finalUV=vec2(textureMatrix*vec4(vUV,1.0,0.0));albedo=texture2D(albedoSampler,finalUV).rgb;
#endif
#ifdef HOVERLIGHT
float pointToHover=(1.0-clamp(length(hoverPosition-worldPosition)/hoverRadius,0.,1.))*hoverColor.a;albedo=clamp(albedo+hoverColor.rgb*pointToHover,0.,1.);
#else
float pointToHover=1.0;
#endif
#ifdef BORDER 
float borderPower=10.0;float inverseBorderPower=1.0/borderPower;vec3 borderColor=albedo*borderPower;vec2 distanceToEdge;distanceToEdge.x=abs(vUV.x-0.5)*2.0;distanceToEdge.y=abs(vUV.y-0.5)*2.0;float borderValue=max(smoothstep(scaleInfo.x-edgeSmoothingValue,scaleInfo.x+edgeSmoothingValue,distanceToEdge.x),
smoothstep(scaleInfo.y-edgeSmoothingValue,scaleInfo.y+edgeSmoothingValue,distanceToEdge.y));borderColor=borderColor*borderValue*max(borderMinValue*inverseBorderPower,pointToHover); 
albedo+=borderColor;alpha=max(alpha,borderValue);
#endif
#ifdef INNERGLOW
vec2 uvGlow=(vUV-vec2(0.5,0.5))*(innerGlowColor.a*2.0);uvGlow=uvGlow*uvGlow;uvGlow=uvGlow*uvGlow;albedo+=mix(vec3(0.0,0.0,0.0),innerGlowColor.rgb,uvGlow.x+uvGlow.y); 
#endif
gl_FragColor=vec4(albedo,alpha);}`;
ShaderStore.ShadersStore[name3] = shader2;

// node_modules/@babylonjs/gui/3D/materials/fluent/fluentMaterial.js
var FluentMaterialDefines = class extends MaterialDefines {
  constructor() {
    super();
    this.INNERGLOW = false;
    this.BORDER = false;
    this.HOVERLIGHT = false;
    this.TEXTURE = false;
    this.rebuild();
  }
};
var FluentMaterial = class _FluentMaterial extends PushMaterial {
  /**
   * Creates a new Fluent material
   * @param name defines the name of the material
   * @param scene defines the hosting scene
   */
  constructor(name22, scene) {
    super(name22, scene);
    this.innerGlowColorIntensity = 0.5;
    this.innerGlowColor = new Color3(1, 1, 1);
    this.albedoColor = new Color3(0.3, 0.35, 0.4);
    this.renderBorders = false;
    this.borderWidth = 0.5;
    this.edgeSmoothingValue = 0.02;
    this.borderMinValue = 0.1;
    this.renderHoverLight = false;
    this.hoverRadius = 0.01;
    this.hoverColor = new Color4(0.3, 0.3, 0.3, 1);
    this.hoverPosition = Vector3.Zero();
  }
  needAlphaBlending() {
    return this.alpha !== 1;
  }
  needAlphaTesting() {
    return false;
  }
  getAlphaTestTexture() {
    return null;
  }
  isReadyForSubMesh(mesh, subMesh) {
    const drawWrapper = subMesh._drawWrapper;
    if (this.isFrozen) {
      if (drawWrapper.effect && drawWrapper._wasPreviouslyReady) {
        return true;
      }
    }
    if (!subMesh.materialDefines) {
      subMesh.materialDefines = new FluentMaterialDefines();
    }
    const scene = this.getScene();
    const defines = subMesh.materialDefines;
    if (!this.checkReadyOnEveryCall && subMesh.effect) {
      if (defines._renderId === scene.getRenderId()) {
        return true;
      }
    }
    if (defines._areTexturesDirty) {
      defines.INNERGLOW = this.innerGlowColorIntensity > 0;
      defines.BORDER = this.renderBorders;
      defines.HOVERLIGHT = this.renderHoverLight;
      if (this._albedoTexture) {
        if (!this._albedoTexture.isReadyOrNotBlocking()) {
          return false;
        } else {
          defines.TEXTURE = true;
        }
      } else {
        defines.TEXTURE = false;
      }
    }
    const engine = scene.getEngine();
    if (defines.isDirty) {
      defines.markAsProcessed();
      scene.resetCachedMaterial();
      const attribs = [VertexBuffer.PositionKind];
      attribs.push(VertexBuffer.NormalKind);
      attribs.push(VertexBuffer.UVKind);
      const shaderName = "fluent";
      const uniforms = [
        "world",
        "viewProjection",
        "innerGlowColor",
        "albedoColor",
        "borderWidth",
        "edgeSmoothingValue",
        "scaleFactor",
        "borderMinValue",
        "hoverColor",
        "hoverPosition",
        "hoverRadius",
        "textureMatrix"
      ];
      const samplers = ["albedoSampler"];
      const uniformBuffers = [];
      PrepareUniformsAndSamplersList({
        uniformsNames: uniforms,
        uniformBuffersNames: uniformBuffers,
        samplers,
        defines,
        maxSimultaneousLights: 4
      });
      const join = defines.toString();
      subMesh.setEffect(scene.getEngine().createEffect(shaderName, {
        attributes: attribs,
        uniformsNames: uniforms,
        uniformBuffersNames: uniformBuffers,
        samplers,
        defines: join,
        fallbacks: null,
        onCompiled: this.onCompiled,
        onError: this.onError,
        indexParameters: { maxSimultaneousLights: 4 }
      }, engine), defines, this._materialContext);
    }
    if (!subMesh.effect || !subMesh.effect.isReady()) {
      return false;
    }
    defines._renderId = scene.getRenderId();
    drawWrapper._wasPreviouslyReady = true;
    return true;
  }
  bindForSubMesh(world, mesh, subMesh) {
    const scene = this.getScene();
    const defines = subMesh.materialDefines;
    if (!defines) {
      return;
    }
    const effect = subMesh.effect;
    if (!effect) {
      return;
    }
    this._activeEffect = effect;
    this.bindOnlyWorldMatrix(world);
    this._activeEffect.setMatrix("viewProjection", scene.getTransformMatrix());
    if (this._mustRebind(scene, effect, subMesh)) {
      this._activeEffect.setColor4("albedoColor", this.albedoColor, this.alpha);
      if (defines.INNERGLOW) {
        this._activeEffect.setColor4("innerGlowColor", this.innerGlowColor, this.innerGlowColorIntensity);
      }
      if (defines.BORDER) {
        this._activeEffect.setFloat("borderWidth", this.borderWidth);
        this._activeEffect.setFloat("edgeSmoothingValue", this.edgeSmoothingValue);
        this._activeEffect.setFloat("borderMinValue", this.borderMinValue);
        mesh.getBoundingInfo().boundingBox.extendSize.multiplyToRef(mesh.scaling, TmpVectors.Vector3[0]);
        this._activeEffect.setVector3("scaleFactor", TmpVectors.Vector3[0]);
      }
      if (defines.HOVERLIGHT) {
        this._activeEffect.setDirectColor4("hoverColor", this.hoverColor);
        this._activeEffect.setFloat("hoverRadius", this.hoverRadius);
        this._activeEffect.setVector3("hoverPosition", this.hoverPosition);
      }
      if (defines.TEXTURE && this._albedoTexture) {
        this._activeEffect.setTexture("albedoSampler", this._albedoTexture);
        const matrix = this._albedoTexture.getTextureMatrix();
        this._activeEffect.setMatrix("textureMatrix", matrix);
      }
    }
    this._afterBind(mesh, this._activeEffect, subMesh);
  }
  getActiveTextures() {
    const activeTextures = super.getActiveTextures();
    return activeTextures;
  }
  hasTexture(texture) {
    if (super.hasTexture(texture)) {
      return true;
    }
    return false;
  }
  dispose(forceDisposeEffect) {
    super.dispose(forceDisposeEffect);
  }
  clone(name22) {
    return SerializationHelper.Clone(() => new _FluentMaterial(name22, this.getScene()), this);
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.customType = "BABYLON.GUI.FluentMaterial";
    return serializationObject;
  }
  getClassName() {
    return "FluentMaterial";
  }
  // Statics
  static Parse(source, scene, rootUrl) {
    return SerializationHelper.Parse(() => new _FluentMaterial(source.name, scene), source, scene, rootUrl);
  }
};
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], FluentMaterial.prototype, "innerGlowColorIntensity", void 0);
__decorate([
  serializeAsColor3()
], FluentMaterial.prototype, "innerGlowColor", void 0);
__decorate([
  serializeAsColor3()
], FluentMaterial.prototype, "albedoColor", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], FluentMaterial.prototype, "renderBorders", void 0);
__decorate([
  serialize()
], FluentMaterial.prototype, "borderWidth", void 0);
__decorate([
  serialize()
], FluentMaterial.prototype, "edgeSmoothingValue", void 0);
__decorate([
  serialize()
], FluentMaterial.prototype, "borderMinValue", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], FluentMaterial.prototype, "renderHoverLight", void 0);
__decorate([
  serialize()
], FluentMaterial.prototype, "hoverRadius", void 0);
__decorate([
  serializeAsColor4()
], FluentMaterial.prototype, "hoverColor", void 0);
__decorate([
  serializeAsVector3()
], FluentMaterial.prototype, "hoverPosition", void 0);
__decorate([
  serializeAsTexture("albedoTexture")
], FluentMaterial.prototype, "_albedoTexture", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesAndMiscDirty")
], FluentMaterial.prototype, "albedoTexture", void 0);
RegisterClass("BABYLON.GUI.FluentMaterial", FluentMaterial);

// node_modules/@babylonjs/gui/3D/controls/touchHolographicMenu.js
var TouchHolographicMenu = class _TouchHolographicMenu extends VolumeBasedPanel {
  /**
   * Gets or sets the margin size of the backplate in button size units.
   * Setting this to 1, will make the backPlate margin the size of 1 button
   */
  get backPlateMargin() {
    return this._backPlateMargin;
  }
  set backPlateMargin(value) {
    this._backPlateMargin = value;
    if (this._children.length >= 1) {
      this.children.forEach((control) => {
        this._updateCurrentMinMax(control.position);
      });
      this._updateMargins();
    }
  }
  _createNode(scene) {
    const node = new Mesh(`menu_${this.name}`, scene);
    this._backPlate = CreateBox("backPlate" + this.name, { size: 1 }, scene);
    this._backPlate.parent = node;
    return node;
  }
  _affectMaterial(mesh) {
    this._backPlateMaterial = new FluentMaterial(this.name + "backPlateMaterial", mesh.getScene());
    this._backPlateMaterial.albedoColor = new Color3(0.08, 0.15, 0.55);
    this._backPlateMaterial.renderBorders = true;
    this._backPlateMaterial.renderHoverLight = true;
    this._pickedPointObserver = this._host.onPickedPointChangedObservable.add((pickedPoint) => {
      if (pickedPoint) {
        this._backPlateMaterial.hoverPosition = pickedPoint;
        this._backPlateMaterial.hoverColor.a = 1;
      } else {
        this._backPlateMaterial.hoverColor.a = 0;
      }
    });
    this._backPlate.material = this._backPlateMaterial;
  }
  _mapGridNode(control, nodePosition) {
    const mesh = control.mesh;
    if (!mesh) {
      return;
    }
    control.position = nodePosition.clone();
    this._updateCurrentMinMax(nodePosition);
  }
  _finalProcessing() {
    this._updateMargins();
  }
  _updateCurrentMinMax(nodePosition) {
    if (!this._currentMin) {
      this._currentMin = nodePosition.clone();
      this._currentMax = nodePosition.clone();
    }
    this._currentMin.minimizeInPlace(nodePosition);
    this._currentMax.maximizeInPlace(nodePosition);
  }
  _updateMargins() {
    if (this._children.length > 0) {
      this._currentMin.addInPlaceFromFloats(-this._cellWidth / 2, -this._cellHeight / 2, 0);
      this._currentMax.addInPlaceFromFloats(this._cellWidth / 2, this._cellHeight / 2, 0);
      const extendSize = this._currentMax.subtract(this._currentMin);
      this._backPlate.scaling.x = extendSize.x + this._cellWidth * this.backPlateMargin;
      this._backPlate.scaling.y = extendSize.y + this._cellHeight * this.backPlateMargin;
      this._backPlate.scaling.z = 1e-3;
      for (let i = 0; i < this._children.length; i++) {
        this._children[i].position.subtractInPlace(this._currentMin).subtractInPlace(extendSize.scale(0.5));
        this._children[i].position.z -= 0.01;
      }
    }
    this._currentMin = null;
    this._currentMax = null;
  }
  /**
   * Creates a holographic menu GUI 3D control
   * @param name name of the menu
   */
  constructor(name22) {
    super(name22);
    this._backPlateMargin = 1.25;
  }
  /**
   * Adds a button to the menu.
   * Please note that the back material of the button will be set to transparent as it is attached to the menu.
   *
   * @param button Button to add
   * @returns This menu
   */
  addButton(button) {
    const wasLayoutBlocked = this.blockLayout;
    if (!wasLayoutBlocked) {
      this.blockLayout = true;
    }
    super.addControl(button);
    button.isBackplateVisible = false;
    button.scaling.scaleInPlace(_TouchHolographicMenu.MENU_BUTTON_SCALE);
    if (!wasLayoutBlocked) {
      this.blockLayout = false;
    }
    return this;
  }
  /**
   * This method should not be used directly. It is inherited from `Container3D`.
   * Please use `addButton` instead.
   * @param _control the control to add
   * @returns the current container
   */
  addControl(_control) {
    Logger.Warn("TouchHolographicMenu can only contain buttons. Please use the method `addButton` instead.");
    return this;
  }
  /**
   * Disposes the menu
   */
  dispose() {
    super.dispose();
    this._host.onPickedPointChangedObservable.remove(this._pickedPointObserver);
  }
};
TouchHolographicMenu.MENU_BUTTON_SCALE = 1;

// node_modules/@babylonjs/core/XR/webXRFeaturesManager.js
var WebXRFeatureName = class {
};
WebXRFeatureName.ANCHOR_SYSTEM = "xr-anchor-system";
WebXRFeatureName.BACKGROUND_REMOVER = "xr-background-remover";
WebXRFeatureName.HIT_TEST = "xr-hit-test";
WebXRFeatureName.MESH_DETECTION = "xr-mesh-detection";
WebXRFeatureName.PHYSICS_CONTROLLERS = "xr-physics-controller";
WebXRFeatureName.PLANE_DETECTION = "xr-plane-detection";
WebXRFeatureName.POINTER_SELECTION = "xr-controller-pointer-selection";
WebXRFeatureName.TELEPORTATION = "xr-controller-teleportation";
WebXRFeatureName.FEATURE_POINTS = "xr-feature-points";
WebXRFeatureName.HAND_TRACKING = "xr-hand-tracking";
WebXRFeatureName.IMAGE_TRACKING = "xr-image-tracking";
WebXRFeatureName.NEAR_INTERACTION = "xr-near-interaction";
WebXRFeatureName.DOM_OVERLAY = "xr-dom-overlay";
WebXRFeatureName.MOVEMENT = "xr-controller-movement";
WebXRFeatureName.LIGHT_ESTIMATION = "xr-light-estimation";
WebXRFeatureName.EYE_TRACKING = "xr-eye-tracking";
WebXRFeatureName.WALKING_LOCOMOTION = "xr-walking-locomotion";
WebXRFeatureName.LAYERS = "xr-layers";
WebXRFeatureName.DEPTH_SENSING = "xr-depth-sensing";
WebXRFeatureName.SPACE_WARP = "xr-space-warp";
WebXRFeatureName.RAW_CAMERA_ACCESS = "xr-raw-camera-access";
var WebXRFeaturesManager = class _WebXRFeaturesManager {
  /**
   * constructs a new features manages.
   *
   * @param _xrSessionManager an instance of WebXRSessionManager
   */
  constructor(_xrSessionManager) {
    this._xrSessionManager = _xrSessionManager;
    this._features = {};
    this._xrSessionManager.onXRSessionInit.add(() => {
      this.getEnabledFeatures().forEach((featureName) => {
        const feature = this._features[featureName];
        if (feature.enabled && !feature.featureImplementation.attached && !feature.featureImplementation.disableAutoAttach) {
          this.attachFeature(featureName);
        }
      });
    });
    this._xrSessionManager.onXRSessionEnded.add(() => {
      this.getEnabledFeatures().forEach((featureName) => {
        const feature = this._features[featureName];
        if (feature.enabled && feature.featureImplementation.attached) {
          this.detachFeature(featureName);
        }
      });
    });
  }
  /**
   * Used to register a module. After calling this function a developer can use this feature in the scene.
   * Mainly used internally.
   *
   * @param featureName the name of the feature to register
   * @param constructorFunction the function used to construct the module
   * @param version the (babylon) version of the module
   * @param stable is that a stable version of this module
   */
  static AddWebXRFeature(featureName, constructorFunction, version = 1, stable = false) {
    this._AvailableFeatures[featureName] = this._AvailableFeatures[featureName] || { latest: version };
    if (version > this._AvailableFeatures[featureName].latest) {
      this._AvailableFeatures[featureName].latest = version;
    }
    if (stable) {
      this._AvailableFeatures[featureName].stable = version;
    }
    this._AvailableFeatures[featureName][version] = constructorFunction;
  }
  /**
   * Returns a constructor of a specific feature.
   *
   * @param featureName the name of the feature to construct
   * @param version the version of the feature to load
   * @param xrSessionManager the xrSessionManager. Used to construct the module
   * @param options optional options provided to the module.
   * @returns a function that, when called, will return a new instance of this feature
   */
  static ConstructFeature(featureName, version = 1, xrSessionManager, options) {
    const constructorFunction = this._AvailableFeatures[featureName][version];
    if (!constructorFunction) {
      throw new Error("feature not found");
    }
    return constructorFunction(xrSessionManager, options);
  }
  /**
   * Can be used to return the list of features currently registered
   *
   * @returns an Array of available features
   */
  static GetAvailableFeatures() {
    return Object.keys(this._AvailableFeatures);
  }
  /**
   * Gets the versions available for a specific feature
   * @param featureName the name of the feature
   * @returns an array with the available versions
   */
  static GetAvailableVersions(featureName) {
    return Object.keys(this._AvailableFeatures[featureName]);
  }
  /**
   * Return the latest unstable version of this feature
   * @param featureName the name of the feature to search
   * @returns the version number. if not found will return -1
   */
  static GetLatestVersionOfFeature(featureName) {
    return this._AvailableFeatures[featureName] && this._AvailableFeatures[featureName].latest || -1;
  }
  /**
   * Return the latest stable version of this feature
   * @param featureName the name of the feature to search
   * @returns the version number. if not found will return -1
   */
  static GetStableVersionOfFeature(featureName) {
    return this._AvailableFeatures[featureName] && this._AvailableFeatures[featureName].stable || -1;
  }
  /**
   * Attach a feature to the current session. Mainly used when session started to start the feature effect.
   * Can be used during a session to start a feature
   * @param featureName the name of feature to attach
   */
  attachFeature(featureName) {
    const feature = this._features[featureName];
    if (feature && feature.enabled && !feature.featureImplementation.attached) {
      const attached = feature.featureImplementation.attach();
      if (!attached) {
        Tools.Warn(`Feature ${featureName} failed to attach`);
      }
    }
  }
  /**
   * Can be used inside a session or when the session ends to detach a specific feature
   * @param featureName the name of the feature to detach
   */
  detachFeature(featureName) {
    const feature = this._features[featureName];
    if (feature && feature.featureImplementation.attached) {
      const detached = feature.featureImplementation.detach();
      if (!detached) {
        Tools.Warn(`Feature ${featureName} failed to detach`);
      }
    }
  }
  /**
   * Used to disable an already-enabled feature
   * The feature will be disposed and will be recreated once enabled.
   * @param featureName the feature to disable
   * @returns true if disable was successful
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  disableFeature(featureName) {
    const name22 = typeof featureName === "string" ? featureName : featureName.Name;
    const feature = this._features[name22];
    if (feature && feature.enabled) {
      feature.enabled = false;
      this.detachFeature(name22);
      feature.featureImplementation.dispose();
      delete this._features[name22];
      return true;
    }
    return false;
  }
  /**
   * dispose this features manager
   */
  dispose() {
    this.getEnabledFeatures().forEach((feature) => {
      this.disableFeature(feature);
    });
  }
  /**
   * Enable a feature using its name and a version. This will enable it in the scene, and will be responsible to attach it when the session starts.
   * If used twice, the old version will be disposed and a new one will be constructed. This way you can re-enable with different configuration.
   *
   * @param featureName the name of the feature to load or the class of the feature
   * @param version optional version to load. if not provided the latest version will be enabled
   * @param moduleOptions options provided to the module. Ses the module documentation / constructor
   * @param attachIfPossible if set to true (default) the feature will be automatically attached, if it is currently possible
   * @param required is this feature required to the app. If set to true the session init will fail if the feature is not available.
   * @returns a new constructed feature or throws an error if feature not found or conflicts with another enabled feature.
   */
  enableFeature(featureName, version = "latest", moduleOptions = {}, attachIfPossible = true, required = true) {
    const name22 = typeof featureName === "string" ? featureName : featureName.Name;
    let versionToLoad = 0;
    if (typeof version === "string") {
      if (!version) {
        throw new Error(`Error in provided version - ${name22} (${version})`);
      }
      if (version === "stable") {
        versionToLoad = _WebXRFeaturesManager.GetStableVersionOfFeature(name22);
      } else if (version === "latest") {
        versionToLoad = _WebXRFeaturesManager.GetLatestVersionOfFeature(name22);
      } else {
        versionToLoad = +version;
      }
      if (versionToLoad === -1 || isNaN(versionToLoad)) {
        throw new Error(`feature not found - ${name22} (${version})`);
      }
    } else {
      versionToLoad = version;
    }
    const conflictingFeature = _WebXRFeaturesManager._ConflictingFeatures[name22];
    if (conflictingFeature !== void 0 && this.getEnabledFeatures().indexOf(conflictingFeature) !== -1) {
      throw new Error(`Feature ${name22} cannot be enabled while ${conflictingFeature} is enabled.`);
    }
    const feature = this._features[name22];
    const constructFunction = _WebXRFeaturesManager.ConstructFeature(name22, versionToLoad, this._xrSessionManager, moduleOptions);
    if (!constructFunction) {
      throw new Error(`feature not found - ${name22}`);
    }
    if (feature) {
      this.disableFeature(name22);
    }
    const constructed = constructFunction();
    if (constructed.dependsOn) {
      const dependentsFound = constructed.dependsOn.every((featureName2) => !!this._features[featureName2]);
      if (!dependentsFound) {
        throw new Error(`Dependant features missing. Make sure the following features are enabled - ${constructed.dependsOn.join(", ")}`);
      }
    }
    if (constructed.isCompatible()) {
      this._features[name22] = {
        featureImplementation: constructed,
        enabled: true,
        version: versionToLoad,
        required
      };
      if (attachIfPossible) {
        if (this._xrSessionManager.session && !this._features[name22].featureImplementation.attached) {
          this.attachFeature(name22);
        }
      } else {
        this._features[name22].featureImplementation.disableAutoAttach = true;
      }
      return this._features[name22].featureImplementation;
    } else {
      if (required) {
        throw new Error("required feature not compatible");
      } else {
        Tools.Warn(`Feature ${name22} not compatible with the current environment/browser and was not enabled.`);
        return constructed;
      }
    }
  }
  /**
   * get the implementation of an enabled feature.
   * @param featureName the name of the feature to load
   * @returns the feature class, if found
   */
  getEnabledFeature(featureName) {
    return this._features[featureName] && this._features[featureName].featureImplementation;
  }
  /**
   * Get the list of enabled features
   * @returns an array of enabled features
   */
  getEnabledFeatures() {
    return Object.keys(this._features);
  }
  /**
   * This function will extend the session creation configuration object with enabled features.
   * If, for example, the anchors feature is enabled, it will be automatically added to the optional or required features list,
   * according to the defined "required" variable, provided during enableFeature call
   * @param xrSessionInit the xr Session init object to extend
   *
   * @returns an extended XRSessionInit object
   */
  async _extendXRSessionInitObject(xrSessionInit) {
    const enabledFeatures = this.getEnabledFeatures();
    for (const featureName of enabledFeatures) {
      const feature = this._features[featureName];
      const nativeName = feature.featureImplementation.xrNativeFeatureName;
      if (nativeName) {
        if (feature.required) {
          xrSessionInit.requiredFeatures = xrSessionInit.requiredFeatures || [];
          if (xrSessionInit.requiredFeatures.indexOf(nativeName) === -1) {
            xrSessionInit.requiredFeatures.push(nativeName);
          }
        } else {
          xrSessionInit.optionalFeatures = xrSessionInit.optionalFeatures || [];
          if (xrSessionInit.optionalFeatures.indexOf(nativeName) === -1) {
            xrSessionInit.optionalFeatures.push(nativeName);
          }
        }
      }
      if (feature.featureImplementation.getXRSessionInitExtension) {
        const extended = await feature.featureImplementation.getXRSessionInitExtension();
        xrSessionInit = {
          ...xrSessionInit,
          ...extended
        };
      }
    }
    return xrSessionInit;
  }
};
WebXRFeaturesManager._AvailableFeatures = {};
WebXRFeaturesManager._ConflictingFeatures = {
  [WebXRFeatureName.TELEPORTATION]: WebXRFeatureName.MOVEMENT,
  [WebXRFeatureName.MOVEMENT]: WebXRFeatureName.TELEPORTATION
};

// node_modules/@babylonjs/core/Behaviors/Meshes/handConstraintBehavior.js
var HandConstraintZone;
(function(HandConstraintZone2) {
  HandConstraintZone2[HandConstraintZone2["ABOVE_FINGER_TIPS"] = 0] = "ABOVE_FINGER_TIPS";
  HandConstraintZone2[HandConstraintZone2["RADIAL_SIDE"] = 1] = "RADIAL_SIDE";
  HandConstraintZone2[HandConstraintZone2["ULNAR_SIDE"] = 2] = "ULNAR_SIDE";
  HandConstraintZone2[HandConstraintZone2["BELOW_WRIST"] = 3] = "BELOW_WRIST";
})(HandConstraintZone || (HandConstraintZone = {}));
var HandConstraintOrientation;
(function(HandConstraintOrientation2) {
  HandConstraintOrientation2[HandConstraintOrientation2["LOOK_AT_CAMERA"] = 0] = "LOOK_AT_CAMERA";
  HandConstraintOrientation2[HandConstraintOrientation2["HAND_ROTATION"] = 1] = "HAND_ROTATION";
})(HandConstraintOrientation || (HandConstraintOrientation = {}));
var HandConstraintVisibility;
(function(HandConstraintVisibility2) {
  HandConstraintVisibility2[HandConstraintVisibility2["ALWAYS_VISIBLE"] = 0] = "ALWAYS_VISIBLE";
  HandConstraintVisibility2[HandConstraintVisibility2["PALM_UP"] = 1] = "PALM_UP";
  HandConstraintVisibility2[HandConstraintVisibility2["GAZE_FOCUS"] = 2] = "GAZE_FOCUS";
  HandConstraintVisibility2[HandConstraintVisibility2["PALM_AND_GAZE"] = 3] = "PALM_AND_GAZE";
})(HandConstraintVisibility || (HandConstraintVisibility = {}));
var HandConstraintBehavior = class {
  /**
   * Builds a hand constraint behavior
   */
  constructor() {
    this._sceneRenderObserver = null;
    this._zoneAxis = {};
    this.handConstraintVisibility = 3;
    this.palmUpStrictness = 0.95;
    this.gazeProximityRadius = 0.15;
    this.targetOffset = 0.1;
    this.targetZone = 2;
    this.zoneOrientationMode = 1;
    this.nodeOrientationMode = 1;
    this.handedness = "none";
    this.lerpTime = 100;
    this._zoneAxis[
      0
      /* HandConstraintZone.ABOVE_FINGER_TIPS */
    ] = new Vector3(0, 1, 0);
    this._zoneAxis[
      1
      /* HandConstraintZone.RADIAL_SIDE */
    ] = new Vector3(-1, 0, 0);
    this._zoneAxis[
      2
      /* HandConstraintZone.ULNAR_SIDE */
    ] = new Vector3(1, 0, 0);
    this._zoneAxis[
      3
      /* HandConstraintZone.BELOW_WRIST */
    ] = new Vector3(0, -1, 0);
  }
  /** gets or sets behavior's name */
  get name() {
    return "HandConstraint";
  }
  /** Enable the behavior */
  enable() {
    this._node.setEnabled(true);
  }
  /** Disable the behavior */
  disable() {
    this._node.setEnabled(false);
  }
  _getHandPose() {
    if (!this._handTracking) {
      return null;
    }
    let hand;
    if (this.handedness === "none") {
      hand = this._handTracking.getHandByHandedness("left") || this._handTracking.getHandByHandedness("right");
    } else {
      hand = this._handTracking.getHandByHandedness(this.handedness);
    }
    if (hand) {
      const pinkyMetacarpal = hand.getJointMesh(
        "pinky-finger-metacarpal"
        /* WebXRHandJoint.PINKY_FINGER_METACARPAL */
      );
      const middleMetacarpal = hand.getJointMesh(
        "middle-finger-metacarpal"
        /* WebXRHandJoint.MIDDLE_FINGER_METACARPAL */
      );
      const wrist = hand.getJointMesh(
        "wrist"
        /* WebXRHandJoint.WRIST */
      );
      if (wrist && middleMetacarpal && pinkyMetacarpal) {
        const handPose = { position: middleMetacarpal.absolutePosition, quaternion: new Quaternion(), id: hand.xrController.uniqueId };
        const up = TmpVectors.Vector3[0];
        const forward = TmpVectors.Vector3[1];
        const left = TmpVectors.Vector3[2];
        up.copyFrom(middleMetacarpal.absolutePosition).subtractInPlace(wrist.absolutePosition).normalize();
        forward.copyFrom(pinkyMetacarpal.absolutePosition).subtractInPlace(middleMetacarpal.absolutePosition).normalize();
        Vector3.CrossToRef(up, forward, forward);
        Vector3.CrossToRef(forward, up, left);
        Quaternion.FromLookDirectionLHToRef(forward, up, handPose.quaternion);
        return handPose;
      }
    }
    return null;
  }
  /**
   * Initializes the hand constraint behavior
   */
  init() {
  }
  /**
   * Attaches the hand constraint to a `TransformNode`
   * @param node defines the node to attach the behavior to
   */
  attach(node) {
    this._node = node;
    this._scene = node.getScene();
    if (!this._node.rotationQuaternion) {
      this._node.rotationQuaternion = Quaternion.RotationYawPitchRoll(this._node.rotation.y, this._node.rotation.x, this._node.rotation.z);
    }
    let lastTick = Date.now();
    this._sceneRenderObserver = this._scene.onBeforeRenderObservable.add(() => {
      const pose = this._getHandPose();
      this._node.reservedDataStore = this._node.reservedDataStore || {};
      this._node.reservedDataStore.nearInteraction = this._node.reservedDataStore.nearInteraction || {};
      this._node.reservedDataStore.nearInteraction.excludedControllerId = null;
      if (pose) {
        const zoneOffset = TmpVectors.Vector3[0];
        const camera = this._scene.activeCamera;
        zoneOffset.copyFrom(this._zoneAxis[this.targetZone]);
        const cameraLookAtQuaternion = TmpVectors.Quaternion[0];
        if (camera && (this.zoneOrientationMode === 0 || this.nodeOrientationMode === 0)) {
          const toCamera = TmpVectors.Vector3[1];
          toCamera.copyFrom(camera.position).subtractInPlace(pose.position).normalize();
          if (this._scene.useRightHandedSystem) {
            Quaternion.FromLookDirectionRHToRef(toCamera, Vector3.UpReadOnly, cameraLookAtQuaternion);
          } else {
            Quaternion.FromLookDirectionLHToRef(toCamera, Vector3.UpReadOnly, cameraLookAtQuaternion);
          }
        }
        if (this.zoneOrientationMode === 1) {
          pose.quaternion.toRotationMatrix(TmpVectors.Matrix[0]);
        } else {
          cameraLookAtQuaternion.toRotationMatrix(TmpVectors.Matrix[0]);
        }
        Vector3.TransformNormalToRef(zoneOffset, TmpVectors.Matrix[0], zoneOffset);
        zoneOffset.scaleInPlace(this.targetOffset);
        const targetPosition = TmpVectors.Vector3[2];
        const targetRotation = TmpVectors.Quaternion[1];
        targetPosition.copyFrom(pose.position).addInPlace(zoneOffset);
        if (this.nodeOrientationMode === 1) {
          targetRotation.copyFrom(pose.quaternion);
        } else {
          targetRotation.copyFrom(cameraLookAtQuaternion);
        }
        const elapsed = Date.now() - lastTick;
        Vector3.SmoothToRef(this._node.position, targetPosition, elapsed, this.lerpTime, this._node.position);
        Quaternion.SmoothToRef(this._node.rotationQuaternion, targetRotation, elapsed, this.lerpTime, this._node.rotationQuaternion);
        this._node.reservedDataStore.nearInteraction.excludedControllerId = pose.id;
      }
      this._setVisibility(pose);
      lastTick = Date.now();
    });
  }
  _setVisibility(pose) {
    let palmVisible = true;
    let gazeVisible = true;
    const camera = this._scene.activeCamera;
    if (camera) {
      const cameraForward = camera.getForwardRay();
      if (this.handConstraintVisibility === 2 || this.handConstraintVisibility === 3) {
        gazeVisible = false;
        let gaze;
        if (this._eyeTracking) {
          gaze = this._eyeTracking.getEyeGaze();
        }
        gaze = gaze || cameraForward;
        const gazeToBehavior = TmpVectors.Vector3[0];
        if (pose) {
          pose.position.subtractToRef(gaze.origin, gazeToBehavior);
        } else {
          this._node.getAbsolutePosition().subtractToRef(gaze.origin, gazeToBehavior);
        }
        const projectedDistance = Vector3.Dot(gazeToBehavior, gaze.direction);
        const projectedSquared = projectedDistance * projectedDistance;
        if (projectedDistance > 0) {
          const radiusSquared = gazeToBehavior.lengthSquared() - projectedSquared;
          if (radiusSquared < this.gazeProximityRadius * this.gazeProximityRadius) {
            gazeVisible = true;
          }
        }
      }
      if (this.handConstraintVisibility === 1 || this.handConstraintVisibility === 3) {
        palmVisible = false;
        if (pose) {
          const palmDirection = TmpVectors.Vector3[0];
          Vector3.LeftHandedForwardReadOnly.rotateByQuaternionToRef(pose.quaternion, palmDirection);
          if (Vector3.Dot(palmDirection, cameraForward.direction) > this.palmUpStrictness * 2 - 1) {
            palmVisible = true;
          }
        }
      }
    }
    this._node.setEnabled(palmVisible && gazeVisible);
  }
  /**
   * Detaches the behavior from the `TransformNode`
   */
  detach() {
    this._scene.onBeforeRenderObservable.remove(this._sceneRenderObserver);
  }
  /**
   * Links the behavior to the XR experience in which to retrieve hand transform information.
   * @param xr xr experience
   */
  linkToXRExperience(xr) {
    const featuresManager = xr.featuresManager ? xr.featuresManager : xr;
    if (!featuresManager) {
      Tools.Error("XR features manager must be available or provided directly for the Hand Menu to work");
    } else {
      try {
        this._eyeTracking = featuresManager.getEnabledFeature(WebXRFeatureName.EYE_TRACKING);
      } catch {
      }
      try {
        this._handTracking = featuresManager.getEnabledFeature(WebXRFeatureName.HAND_TRACKING);
      } catch {
        Tools.Error("Hand tracking must be enabled for the Hand Menu to work");
      }
    }
  }
};

// node_modules/@babylonjs/gui/3D/controls/handMenu.js
var HandMenu = class extends TouchHolographicMenu {
  /**
   * The hand constraint behavior setting the transformation of this node
   */
  get handConstraintBehavior() {
    return this._handConstraintBehavior;
  }
  _createNode(scene) {
    const node = super._createNode(scene);
    this._handConstraintBehavior.attach(node);
    return node;
  }
  /**
   * Creates a hand menu GUI 3D control
   * @param xr the WebXRExperienceHelper used to link this control to the enabled WebXRHandTracking feature
   * @param name name of the hand menu
   */
  constructor(xr, name22) {
    super(name22);
    this._handConstraintBehavior = new HandConstraintBehavior();
    this._handConstraintBehavior.linkToXRExperience(xr);
    this.backPlateMargin = 0.15;
    this.rows = 3;
  }
  /**
   * Disposes the hand menu
   */
  dispose() {
    super.dispose();
    this._handConstraintBehavior.detach();
  }
};

// node_modules/@babylonjs/gui/3D/materials/fluentBackplate/shaders/fluentBackplate.fragment.js
var name4 = "fluentBackplatePixelShader";
var shader3 = `uniform vec3 cameraPosition;varying vec3 vPosition;varying vec3 vNormal;varying vec2 vUV;varying vec3 vTangent;varying vec3 vBinormal;varying vec4 vColor;varying vec4 vExtra1;varying vec4 vExtra2;varying vec4 vExtra3;uniform float _Radius_;uniform float _Line_Width_;uniform bool _Absolute_Sizes_;uniform float _Filter_Width_;uniform vec4 _Base_Color_;uniform vec4 _Line_Color_;uniform float _Radius_Top_Left_;uniform float _Radius_Top_Right_;uniform float _Radius_Bottom_Left_;uniform float _Radius_Bottom_Right_;uniform vec3 _Blob_Position_;uniform float _Blob_Intensity_;uniform float _Blob_Near_Size_;uniform float _Blob_Far_Size_;uniform float _Blob_Near_Distance_;uniform float _Blob_Far_Distance_;uniform float _Blob_Fade_Length_;uniform float _Blob_Pulse_;uniform float _Blob_Fade_;uniform sampler2D _Blob_Texture_;uniform vec3 _Blob_Position_2_;uniform float _Blob_Near_Size_2_;uniform float _Blob_Pulse_2_;uniform float _Blob_Fade_2_;uniform float _Rate_;uniform vec4 _Highlight_Color_;uniform float _Highlight_Width_;uniform vec4 _Highlight_Transform_;uniform float _Highlight_;uniform float _Iridescence_Intensity_;uniform float _Iridescence_Edge_Intensity_;uniform float _Angle_;uniform float _Fade_Out_;uniform bool _Reflected_;uniform float _Frequency_;uniform float _Vertical_Offset_;uniform sampler2D _Iridescent_Map_;uniform bool _Use_Global_Left_Index_;uniform bool _Use_Global_Right_Index_;uniform vec4 Global_Left_Index_Tip_Position;uniform vec4 Global_Right_Index_Tip_Position;void Round_Rect_Fragment_B31(
float Radius,
float Line_Width,
vec4 Line_Color,
float Filter_Width,
vec2 UV,
float Line_Visibility,
vec4 Rect_Parms,
vec4 Fill_Color,
out vec4 Color)
{float d=length(max(abs(UV)-Rect_Parms.xy,0.0));float dx=max(fwidth(d)*Filter_Width,0.00001);float g=min(Rect_Parms.z,Rect_Parms.w);float dgrad=max(fwidth(g)*Filter_Width,0.00001);float Inside_Rect=clamp(g/dgrad,0.0,1.0);float inner=clamp((d+dx*0.5-max(Radius-Line_Width,d-dx*0.5))/dx,0.0,1.0);Color=clamp(mix(Fill_Color,Line_Color,inner),0.0,1.0)*Inside_Rect;}
void Blob_Fragment_B71(
sampler2D Blob_Texture,
vec4 Blob_Info1,
vec4 Blob_Info2,
out vec4 Blob_Color)
{float k1=dot(Blob_Info1.xy,Blob_Info1.xy);float k2=dot(Blob_Info2.xy,Blob_Info2.xy);vec3 closer=k1<k2 ? vec3(k1,Blob_Info1.z,Blob_Info1.w) : vec3(k2,Blob_Info2.z,Blob_Info2.w);Blob_Color=closer.z*texture(Blob_Texture,vec2(vec2(sqrt(closer.x),closer.y).x,1.0-vec2(sqrt(closer.x),closer.y).y))*clamp(1.0-closer.x,0.0,1.0);}
void Line_Fragment_B48(
vec4 Base_Color,
vec4 Highlight_Color,
float Highlight_Width,
vec3 Line_Vertex,
float Highlight,
out vec4 Line_Color)
{float k2=1.0-clamp(abs(Line_Vertex.y/Highlight_Width),0.0,1.0);Line_Color=mix(Base_Color,Highlight_Color,Highlight*k2);}
void Scale_RGB_B54(
vec4 Color,
float Scalar,
out vec4 Result)
{Result=vec4(Scalar,Scalar,Scalar,1)*Color;}
void Conditional_Float_B38(
bool Which,
float If_True,
float If_False,
out float Result)
{Result=Which ? If_True : If_False;}
void main()
{float R_Q72;float G_Q72;float B_Q72;float A_Q72;R_Q72=vColor.r; G_Q72=vColor.g; B_Q72=vColor.b; A_Q72=vColor.a;vec4 Blob_Color_Q71;
#if BLOB_ENABLE
float k1=dot(vExtra2.xy,vExtra2.xy);float k2=dot(vExtra3.xy,vExtra3.xy);vec3 closer=k1<k2 ? vec3(k1,vExtra2.z,vExtra2.w) : vec3(k2,vExtra3.z,vExtra3.w);Blob_Color_Q71=closer.z*texture(_Blob_Texture_,vec2(vec2(sqrt(closer.x),closer.y).x,1.0-vec2(sqrt(closer.x),closer.y).y))*clamp(1.0-closer.x,0.0,1.0);
#else
Blob_Color_Q71=vec4(0,0,0,0);
#endif
vec4 Line_Color_Q48;Line_Fragment_B48(_Line_Color_,_Highlight_Color_,_Highlight_Width_,vTangent,_Highlight_,Line_Color_Q48);float X_Q67;float Y_Q67;X_Q67=vUV.x;Y_Q67=vUV.y;vec3 Incident_Q66=normalize(vPosition-cameraPosition);vec3 Reflected_Q60=reflect(Incident_Q66,vBinormal);float Product_Q63=Y_Q67*_Vertical_Offset_;float Dot_Q68=dot(Incident_Q66, Reflected_Q60);float Dot_Q57=dot(vNormal, Incident_Q66);float Result_Q38;Conditional_Float_B38(_Reflected_,Dot_Q68,Dot_Q57,Result_Q38);float Product_Q64=Result_Q38*_Frequency_;float Sum_Q69=Product_Q64+1.0;float Product_Q70=Sum_Q69*0.5;float Sum_Q62=Product_Q63+Product_Q70;float FractF_Q59=fract(Sum_Q62);vec2 Vec2_Q65=vec2(FractF_Q59,0.5);vec4 Color_Q58;
#if IRIDESCENT_MAP_ENABLE
Color_Q58=texture(_Iridescent_Map_,Vec2_Q65);
#else
Color_Q58=vec4(0,0,0,0);
#endif
vec4 Result_Q54;Scale_RGB_B54(Color_Q58,_Iridescence_Edge_Intensity_,Result_Q54);vec4 Result_Q55;Scale_RGB_B54(Color_Q58,_Iridescence_Intensity_,Result_Q55);vec4 Base_And_Iridescent_Q53;Base_And_Iridescent_Q53=Line_Color_Q48+vec4(Result_Q54.rgb,0.0);vec4 Base_And_Iridescent_Q56;Base_And_Iridescent_Q56=_Base_Color_+vec4(Result_Q55.rgb,0.0);vec4 Result_Q52=Base_And_Iridescent_Q53; Result_Q52.a=1.0;vec4 Result_Q35=Blob_Color_Q71+(1.0-Blob_Color_Q71.a)*Base_And_Iridescent_Q56;vec4 Color_Q31;Round_Rect_Fragment_B31(R_Q72,G_Q72,Result_Q52,_Filter_Width_,vUV,1.0,vExtra1,Result_Q35,Color_Q31);vec4 Result_Q47=_Fade_Out_*Color_Q31;vec4 Out_Color=Result_Q47;float Clip_Threshold=0.001;bool To_sRGB=false;gl_FragColor=Out_Color;}`;
ShaderStore.ShadersStore[name4] = shader3;

// node_modules/@babylonjs/gui/3D/materials/fluentBackplate/shaders/fluentBackplate.vertex.js
var name5 = "fluentBackplateVertexShader";
var shader4 = `uniform mat4 world;uniform mat4 viewProjection;uniform vec3 cameraPosition;attribute vec3 position;attribute vec3 normal;
#ifdef TANGENT
attribute vec3 tangent;
#else
const vec3 tangent=vec3(0.);
#endif
uniform float _Radius_;uniform float _Line_Width_;uniform bool _Absolute_Sizes_;uniform float _Filter_Width_;uniform vec4 _Base_Color_;uniform vec4 _Line_Color_;uniform float _Radius_Top_Left_;uniform float _Radius_Top_Right_;uniform float _Radius_Bottom_Left_;uniform float _Radius_Bottom_Right_;uniform vec3 _Blob_Position_;uniform float _Blob_Intensity_;uniform float _Blob_Near_Size_;uniform float _Blob_Far_Size_;uniform float _Blob_Near_Distance_;uniform float _Blob_Far_Distance_;uniform float _Blob_Fade_Length_;uniform float _Blob_Pulse_;uniform float _Blob_Fade_;uniform sampler2D _Blob_Texture_;uniform vec3 _Blob_Position_2_;uniform float _Blob_Near_Size_2_;uniform float _Blob_Pulse_2_;uniform float _Blob_Fade_2_;uniform float _Rate_;uniform vec4 _Highlight_Color_;uniform float _Highlight_Width_;uniform vec4 _Highlight_Transform_;uniform float _Highlight_;uniform float _Iridescence_Intensity_;uniform float _Iridescence_Edge_Intensity_;uniform float _Angle_;uniform float _Fade_Out_;uniform bool _Reflected_;uniform float _Frequency_;uniform float _Vertical_Offset_;uniform sampler2D _Iridescent_Map_;uniform bool _Use_Global_Left_Index_;uniform bool _Use_Global_Right_Index_;uniform vec4 Global_Left_Index_Tip_Position;uniform vec4 Global_Right_Index_Tip_Position;varying vec3 vPosition;varying vec3 vNormal;varying vec2 vUV;varying vec3 vTangent;varying vec3 vBinormal;varying vec4 vColor;varying vec4 vExtra1;varying vec4 vExtra2;varying vec4 vExtra3;void Object_To_World_Pos_B115(
vec3 Pos_Object,
out vec3 Pos_World)
{Pos_World=(world*vec4(Pos_Object,1.0)).xyz;}
void PickDir_B140(
float Degrees,
vec3 DirX,
vec3 DirY,
out vec3 Dir)
{float a=Degrees*3.14159/180.0;Dir=cos(a)*DirX+sin(a)*DirY;}
void Round_Rect_Vertex_B139(
vec2 UV,
float Radius,
float Margin,
float Anisotropy,
float Gradient1,
float Gradient2,
out vec2 Rect_UV,
out vec4 Rect_Parms,
out vec2 Scale_XY,
out vec2 Line_UV)
{Scale_XY=vec2(Anisotropy,1.0);Line_UV=(UV-vec2(0.5,0.5));Rect_UV=Line_UV*Scale_XY;Rect_Parms.xy=Scale_XY*0.5-vec2(Radius,Radius)-vec2(Margin,Margin);Rect_Parms.z=Gradient1; 
Rect_Parms.w=Gradient2;}
void Line_Vertex_B135(
vec2 Scale_XY,
vec2 UV,
float Time,
float Rate,
vec4 Highlight_Transform,
out vec3 Line_Vertex)
{float angle2=(Rate*Time)*2.0*3.1416;float sinAngle2=sin(angle2);float cosAngle2=cos(angle2);vec2 xformUV=UV*Highlight_Transform.xy+Highlight_Transform.zw;Line_Vertex.x=0.0;Line_Vertex.y=cosAngle2*xformUV.x-sinAngle2*xformUV.y;Line_Vertex.z=0.0; }
void Blob_Vertex_B180(
vec3 Position,
vec3 Normal,
vec3 Tangent,
vec3 Bitangent,
vec3 Blob_Position,
float Intensity,
float Blob_Near_Size,
float Blob_Far_Size,
float Blob_Near_Distance,
float Blob_Far_Distance,
float Blob_Fade_Length,
float Blob_Pulse,
float Blob_Fade,
out vec4 Blob_Info)
{vec3 blob=Blob_Position;vec3 delta=blob-Position;float dist=dot(Normal,delta);float lerpValue=clamp((abs(dist)-Blob_Near_Distance)/(Blob_Far_Distance-Blob_Near_Distance),0.0,1.0);float fadeValue=1.0-clamp((abs(dist)-Blob_Far_Distance)/Blob_Fade_Length,0.0,1.0);float size=Blob_Near_Size+(Blob_Far_Size-Blob_Near_Size)*lerpValue;vec2 blobXY=vec2(dot(delta,Tangent),dot(delta,Bitangent))/(0.0001+size);float Fade=fadeValue*Intensity*Blob_Fade;float Distance=(lerpValue*0.5+0.5)*(1.0-Blob_Pulse);Blob_Info=vec4(blobXY.x,blobXY.y,Distance,Fade);}
void Move_Verts_B129(
float Anisotropy,
vec3 P,
float Radius,
out vec3 New_P,
out vec2 New_UV,
out float Radial_Gradient,
out vec3 Radial_Dir)
{vec2 UV=P.xy*2.0+0.5;vec2 center=clamp(UV,0.0,1.0);vec2 delta=UV-center;vec2 r2=2.0*vec2(Radius/Anisotropy,Radius);New_UV=center+r2*(UV-2.0*center+0.5);New_P=vec3(New_UV-0.5,P.z);Radial_Gradient=1.0-length(delta)*2.0;Radial_Dir=vec3(delta*r2,0.0);}
void Object_To_World_Dir_B132(
vec3 Dir_Object,
out vec3 Binormal_World,
out vec3 Binormal_World_N,
out float Binormal_Length)
{Binormal_World=(world*vec4(Dir_Object,0.0)).xyz;Binormal_Length=length(Binormal_World);Binormal_World_N=Binormal_World/Binormal_Length;}
void RelativeOrAbsoluteDetail_B147(
float Nominal_Radius,
float Nominal_LineWidth,
bool Absolute_Measurements,
float Height,
out float Radius,
out float Line_Width)
{float scale=Absolute_Measurements ? 1.0/Height : 1.0;Radius=Nominal_Radius*scale;Line_Width=Nominal_LineWidth*scale;}
void Edge_AA_Vertex_B130(
vec3 Position_World,
vec3 Position_Object,
vec3 Normal_Object,
vec3 Eye,
float Radial_Gradient,
vec3 Radial_Dir,
vec3 Tangent,
out float Gradient1,
out float Gradient2)
{vec3 I=(Eye-Position_World);vec3 T=(world* vec4(Tangent,0.0)).xyz;float g=(dot(T,I)<0.0) ? 0.0 : 1.0;if (Normal_Object.z==0.0) { 
Gradient1=Position_Object.z>0.0 ? g : 1.0;Gradient2=Position_Object.z>0.0 ? 1.0 : g;} else {Gradient1=g+(1.0-g)*(Radial_Gradient);Gradient2=1.0;}}
void Pick_Radius_B144(
float Radius,
float Radius_Top_Left,
float Radius_Top_Right,
float Radius_Bottom_Left,
float Radius_Bottom_Right,
vec3 Position,
out float Result)
{bool whichY=Position.y>0.0;Result=Position.x<0.0 ? (whichY ? Radius_Top_Left : Radius_Bottom_Left) : (whichY ? Radius_Top_Right : Radius_Bottom_Right);Result*=Radius;}
void main()
{vec3 Nrm_World_Q128;Nrm_World_Q128=normalize((world*vec4(normal,0.0)).xyz);vec3 Tangent_World_Q131;vec3 Tangent_World_N_Q131;float Tangent_Length_Q131;Tangent_World_Q131=(world*vec4(vec3(1,0,0),0.0)).xyz;Tangent_Length_Q131=length(Tangent_World_Q131);Tangent_World_N_Q131=Tangent_World_Q131/Tangent_Length_Q131;vec3 Binormal_World_Q132;vec3 Binormal_World_N_Q132;float Binormal_Length_Q132;Object_To_World_Dir_B132(vec3(0,1,0),Binormal_World_Q132,Binormal_World_N_Q132,Binormal_Length_Q132);float Anisotropy_Q133=Tangent_Length_Q131/Binormal_Length_Q132;vec3 Result_Q177;Result_Q177=mix(_Blob_Position_,Global_Left_Index_Tip_Position.xyz,float(_Use_Global_Left_Index_));vec3 Result_Q178;Result_Q178=mix(_Blob_Position_2_,Global_Right_Index_Tip_Position.xyz,float(_Use_Global_Right_Index_));float Result_Q144;Pick_Radius_B144(_Radius_,_Radius_Top_Left_,_Radius_Top_Right_,_Radius_Bottom_Left_,_Radius_Bottom_Right_,position,Result_Q144);vec3 Dir_Q140;PickDir_B140(_Angle_,Tangent_World_N_Q131,Binormal_World_N_Q132,Dir_Q140);float Radius_Q147;float Line_Width_Q147;RelativeOrAbsoluteDetail_B147(Result_Q144,_Line_Width_,_Absolute_Sizes_,Binormal_Length_Q132,Radius_Q147,Line_Width_Q147);vec4 Out_Color_Q145=vec4(Radius_Q147,Line_Width_Q147,0,1);vec3 New_P_Q129;vec2 New_UV_Q129;float Radial_Gradient_Q129;vec3 Radial_Dir_Q129;Move_Verts_B129(Anisotropy_Q133,position,Radius_Q147,New_P_Q129,New_UV_Q129,Radial_Gradient_Q129,Radial_Dir_Q129);vec3 Pos_World_Q115;Object_To_World_Pos_B115(New_P_Q129,Pos_World_Q115);vec4 Blob_Info_Q180;
#if BLOB_ENABLE
Blob_Vertex_B180(Pos_World_Q115,Nrm_World_Q128,Tangent_World_N_Q131,Binormal_World_N_Q132,Result_Q177,_Blob_Intensity_,_Blob_Near_Size_,_Blob_Far_Size_,_Blob_Near_Distance_,_Blob_Far_Distance_,_Blob_Fade_Length_,_Blob_Pulse_,_Blob_Fade_,Blob_Info_Q180);
#else
Blob_Info_Q180=vec4(0,0,0,0);
#endif
vec4 Blob_Info_Q181;
#if BLOB_ENABLE_2
Blob_Vertex_B180(Pos_World_Q115,Nrm_World_Q128,Tangent_World_N_Q131,Binormal_World_N_Q132,Result_Q178,_Blob_Intensity_,_Blob_Near_Size_2_,_Blob_Far_Size_,_Blob_Near_Distance_,_Blob_Far_Distance_,_Blob_Fade_Length_,_Blob_Pulse_2_,_Blob_Fade_2_,Blob_Info_Q181);
#else
Blob_Info_Q181=vec4(0,0,0,0);
#endif
float Gradient1_Q130;float Gradient2_Q130;
#if SMOOTH_EDGES
Edge_AA_Vertex_B130(Pos_World_Q115,position,normal,cameraPosition,Radial_Gradient_Q129,Radial_Dir_Q129,tangent,Gradient1_Q130,Gradient2_Q130);
#else
Gradient1_Q130=1.0;Gradient2_Q130=1.0;
#endif
vec2 Rect_UV_Q139;vec4 Rect_Parms_Q139;vec2 Scale_XY_Q139;vec2 Line_UV_Q139;Round_Rect_Vertex_B139(New_UV_Q129,Radius_Q147,0.0,Anisotropy_Q133,Gradient1_Q130,Gradient2_Q130,Rect_UV_Q139,Rect_Parms_Q139,Scale_XY_Q139,Line_UV_Q139);vec3 Line_Vertex_Q135;Line_Vertex_B135(Scale_XY_Q139,Line_UV_Q139,0.0,_Rate_,_Highlight_Transform_,Line_Vertex_Q135);vec3 Position=Pos_World_Q115;vec3 Normal=Dir_Q140;vec2 UV=Rect_UV_Q139;vec3 Tangent=Line_Vertex_Q135;vec3 Binormal=Nrm_World_Q128;vec4 Color=Out_Color_Q145;vec4 Extra1=Rect_Parms_Q139;vec4 Extra2=Blob_Info_Q180;vec4 Extra3=Blob_Info_Q181;gl_Position=viewProjection*vec4(Position,1);vPosition=Position;vNormal=Normal;vUV=UV;vTangent=Tangent;vBinormal=Binormal;vColor=Color;vExtra1=Extra1;vExtra2=Extra2;vExtra3=Extra3;}`;
ShaderStore.ShadersStore[name5] = shader4;

// node_modules/@babylonjs/gui/3D/materials/fluentBackplate/fluentBackplateMaterial.js
var FluentBackplateMaterialDefines = class extends MaterialDefines {
  constructor() {
    super();
    this.BLOB_ENABLE = true;
    this.BLOB_ENABLE_2 = true;
    this.SMOOTH_EDGES = true;
    this.IRIDESCENT_MAP_ENABLE = true;
    this._needNormals = true;
    this.rebuild();
  }
};
var FluentBackplateMaterial = class _FluentBackplateMaterial extends PushMaterial {
  constructor(name22, scene) {
    super(name22, scene);
    this.radius = 0.03;
    this.lineWidth = 0.01;
    this.absoluteSizes = false;
    this._filterWidth = 1;
    this.baseColor = new Color4(0.0392157, 0.0666667, 0.207843, 1);
    this.lineColor = new Color4(0.14902, 0.133333, 0.384314, 1);
    this.blobIntensity = 0.98;
    this.blobFarSize = 0.04;
    this.blobNearDistance = 0;
    this.blobFarDistance = 0.08;
    this.blobFadeLength = 0.08;
    this.blobNearSize = 0.22;
    this.blobPulse = 0;
    this.blobFade = 0;
    this.blobNearSize2 = 0.22;
    this.blobPulse2 = 0;
    this.blobFade2 = 0;
    this._rate = 0.135;
    this.highlightColor = new Color4(0.98, 0.98, 0.98, 1);
    this.highlightWidth = 0.25;
    this._highlightTransform = new Vector4(1, 1, 0, 0);
    this._highlight = 1;
    this.iridescenceIntensity = 0;
    this.iridescenceEdgeIntensity = 1;
    this._angle = -45;
    this.fadeOut = 1;
    this._reflected = true;
    this._frequency = 1;
    this._verticalOffset = 0;
    this.globalLeftIndexTipPosition = Vector3.Zero();
    this._globalLeftIndexTipPosition4 = Vector4.Zero();
    this.globalRightIndexTipPosition = Vector3.Zero();
    this._globalRightIndexTipPosition4 = Vector4.Zero();
    this.alphaMode = Constants.ALPHA_DISABLE;
    this.backFaceCulling = false;
    this._blobTexture = new Texture(_FluentBackplateMaterial.BLOB_TEXTURE_URL, this.getScene(), true, false, Texture.NEAREST_SAMPLINGMODE);
    this._iridescentMap = new Texture(_FluentBackplateMaterial.IM_TEXTURE_URL, this.getScene(), true, false, Texture.NEAREST_SAMPLINGMODE);
  }
  needAlphaBlending() {
    return false;
  }
  needAlphaTesting() {
    return false;
  }
  getAlphaTestTexture() {
    return null;
  }
  isReadyForSubMesh(mesh, subMesh) {
    const drawWrapper = subMesh._drawWrapper;
    if (this.isFrozen) {
      if (drawWrapper.effect && drawWrapper._wasPreviouslyReady) {
        return true;
      }
    }
    if (!subMesh.materialDefines) {
      subMesh.materialDefines = new FluentBackplateMaterialDefines();
    }
    const defines = subMesh.materialDefines;
    const scene = this.getScene();
    if (this._isReadyForSubMesh(subMesh)) {
      return true;
    }
    const engine = scene.getEngine();
    PrepareDefinesForAttributes(mesh, defines, false, false);
    if (defines.isDirty) {
      defines.markAsProcessed();
      scene.resetCachedMaterial();
      const fallbacks = new EffectFallbacks();
      if (defines.FOG) {
        fallbacks.addFallback(1, "FOG");
      }
      HandleFallbacksForShadows(defines, fallbacks);
      defines.IMAGEPROCESSINGPOSTPROCESS = scene.imageProcessingConfiguration.applyByPostProcess;
      const attribs = [VertexBuffer.PositionKind];
      if (defines.NORMAL) {
        attribs.push(VertexBuffer.NormalKind);
      }
      if (defines.UV1) {
        attribs.push(VertexBuffer.UVKind);
      }
      if (defines.UV2) {
        attribs.push(VertexBuffer.UV2Kind);
      }
      if (defines.VERTEXCOLOR) {
        attribs.push(VertexBuffer.ColorKind);
      }
      if (defines.TANGENT) {
        attribs.push(VertexBuffer.TangentKind);
      }
      PrepareAttributesForInstances(attribs, defines);
      const shaderName = "fluentBackplate";
      const join = defines.toString();
      const uniforms = [
        "world",
        "viewProjection",
        "cameraPosition",
        "_Radius_",
        "_Line_Width_",
        "_Absolute_Sizes_",
        "_Filter_Width_",
        "_Base_Color_",
        "_Line_Color_",
        "_Radius_Top_Left_",
        "_Radius_Top_Right_",
        "_Radius_Bottom_Left_",
        "_Radius_Bottom_Right_",
        "_Blob_Position_",
        "_Blob_Intensity_",
        "_Blob_Near_Size_",
        "_Blob_Far_Size_",
        "_Blob_Near_Distance_",
        "_Blob_Far_Distance_",
        "_Blob_Fade_Length_",
        "_Blob_Pulse_",
        "_Blob_Fade_",
        "_Blob_Texture_",
        "_Blob_Position_2_",
        "_Blob_Near_Size_2_",
        "_Blob_Pulse_2_",
        "_Blob_Fade_2_",
        "_Rate_",
        "_Highlight_Color_",
        "_Highlight_Width_",
        "_Highlight_Transform_",
        "_Highlight_",
        "_Iridescence_Intensity_",
        "_Iridescence_Edge_Intensity_",
        "_Angle_",
        "_Fade_Out_",
        "_Reflected_",
        "_Frequency_",
        "_Vertical_Offset_",
        "_Iridescent_Map_",
        "_Use_Global_Left_Index_",
        "_Use_Global_Right_Index_",
        "Global_Left_Index_Tip_Position",
        "Global_Right_Index_Tip_Position"
      ];
      const samplers = ["_Blob_Texture_", "_Iridescent_Map_"];
      const uniformBuffers = [];
      PrepareUniformsAndSamplersList({
        uniformsNames: uniforms,
        uniformBuffersNames: uniformBuffers,
        samplers,
        defines,
        maxSimultaneousLights: 4
      });
      subMesh.setEffect(scene.getEngine().createEffect(shaderName, {
        attributes: attribs,
        uniformsNames: uniforms,
        uniformBuffersNames: uniformBuffers,
        samplers,
        defines: join,
        fallbacks,
        onCompiled: this.onCompiled,
        onError: this.onError,
        indexParameters: { maxSimultaneousLights: 4 }
      }, engine), defines, this._materialContext);
    }
    if (!subMesh.effect || !subMesh.effect.isReady()) {
      return false;
    }
    defines._renderId = scene.getRenderId();
    drawWrapper._wasPreviouslyReady = true;
    return true;
  }
  bindForSubMesh(world, mesh, subMesh) {
    var _a;
    const defines = subMesh.materialDefines;
    if (!defines) {
      return;
    }
    const effect = subMesh.effect;
    if (!effect) {
      return;
    }
    this._activeEffect = effect;
    this.bindOnlyWorldMatrix(world);
    this._activeEffect.setMatrix("viewProjection", this.getScene().getTransformMatrix());
    this._activeEffect.setVector3("cameraPosition", ((_a = this.getScene().activeCamera) == null ? void 0 : _a.position) ?? Vector3.ZeroReadOnly);
    this._activeEffect.setFloat("_Radius_", this.radius);
    this._activeEffect.setFloat("_Line_Width_", this.lineWidth);
    this._activeEffect.setFloat("_Absolute_Sizes_", this.absoluteSizes ? 1 : 0);
    this._activeEffect.setFloat("_Filter_Width_", this._filterWidth);
    this._activeEffect.setDirectColor4("_Base_Color_", this.baseColor);
    this._activeEffect.setDirectColor4("_Line_Color_", this.lineColor);
    this._activeEffect.setFloat("_Radius_Top_Left_", 1);
    this._activeEffect.setFloat("_Radius_Top_Right_", 1);
    this._activeEffect.setFloat("_Radius_Bottom_Left_", 1);
    this._activeEffect.setFloat("_Radius_Bottom_Right_", 1);
    this._activeEffect.setFloat("_Blob_Intensity_", this.blobIntensity);
    this._activeEffect.setFloat("_Blob_Near_Size_", this.blobNearSize);
    this._activeEffect.setFloat("_Blob_Far_Size_", this.blobFarSize);
    this._activeEffect.setFloat("_Blob_Near_Distance_", this.blobNearDistance);
    this._activeEffect.setFloat("_Blob_Far_Distance_", this.blobFarDistance);
    this._activeEffect.setFloat("_Blob_Fade_Length_", this.blobFadeLength);
    this._activeEffect.setFloat("_Blob_Pulse_", this.blobPulse);
    this._activeEffect.setFloat("_Blob_Fade_", this.blobFade);
    this._activeEffect.setTexture("_Blob_Texture_", this._blobTexture);
    this._activeEffect.setFloat("_Blob_Near_Size_2_", this.blobNearSize2);
    this._activeEffect.setFloat("_Blob_Pulse_2_", this.blobPulse2);
    this._activeEffect.setFloat("_Blob_Fade_2_", this.blobFade2);
    this._activeEffect.setFloat("_Rate_", this._rate);
    this._activeEffect.setDirectColor4("_Highlight_Color_", this.highlightColor);
    this._activeEffect.setFloat("_Highlight_Width_", this.highlightWidth);
    this._activeEffect.setVector4("_Highlight_Transform_", this._highlightTransform);
    this._activeEffect.setFloat("_Highlight_", this._highlight);
    this._activeEffect.setFloat("_Iridescence_Intensity_", this.iridescenceIntensity);
    this._activeEffect.setFloat("_Iridescence_Edge_Intensity_", this.iridescenceEdgeIntensity);
    this._activeEffect.setFloat("_Angle_", this._angle);
    this._activeEffect.setFloat("_Fade_Out_", this.fadeOut);
    this._activeEffect.setFloat("_Reflected_", this._reflected ? 1 : 0);
    this._activeEffect.setFloat("_Frequency_", this._frequency);
    this._activeEffect.setFloat("_Vertical_Offset_", this._verticalOffset);
    this._activeEffect.setTexture("_Iridescent_Map_", this._iridescentMap);
    this._activeEffect.setFloat("_Use_Global_Left_Index_", 1);
    this._activeEffect.setFloat("_Use_Global_Right_Index_", 1);
    this._globalLeftIndexTipPosition4.set(this.globalLeftIndexTipPosition.x, this.globalLeftIndexTipPosition.y, this.globalLeftIndexTipPosition.z, 1);
    this._activeEffect.setVector4("Global_Left_Index_Tip_Position", this._globalLeftIndexTipPosition4);
    this._globalRightIndexTipPosition4.set(this.globalRightIndexTipPosition.x, this.globalRightIndexTipPosition.y, this.globalRightIndexTipPosition.z, 1);
    this._activeEffect.setVector4("Global_Right_Index_Tip_Position", this._globalRightIndexTipPosition4);
    this._afterBind(mesh, this._activeEffect, subMesh);
  }
  /**
   * Get the list of animatables in the material.
   * @returns the list of animatables object used in the material
   */
  getAnimatables() {
    return [];
  }
  dispose(forceDisposeEffect) {
    super.dispose(forceDisposeEffect);
    this._blobTexture.dispose();
    this._iridescentMap.dispose();
  }
  clone(name22) {
    return SerializationHelper.Clone(() => new _FluentBackplateMaterial(name22, this.getScene()), this);
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.customType = "BABYLON.FluentBackplateMaterial";
    return serializationObject;
  }
  getClassName() {
    return "FluentBackplateMaterial";
  }
  // Statics
  static Parse(source, scene, rootUrl) {
    return SerializationHelper.Parse(() => new _FluentBackplateMaterial(source.name, scene), source, scene, rootUrl);
  }
};
FluentBackplateMaterial.BLOB_TEXTURE_URL = "https://assets.babylonjs.com/meshes/MRTK/mrtk-fluent-backplate-blob.png";
FluentBackplateMaterial.IM_TEXTURE_URL = "https://assets.babylonjs.com/meshes/MRTK/mrtk-fluent-backplate-iridescence.png";
__decorate([
  serialize()
], FluentBackplateMaterial.prototype, "radius", void 0);
__decorate([
  serialize()
], FluentBackplateMaterial.prototype, "lineWidth", void 0);
__decorate([
  serialize()
], FluentBackplateMaterial.prototype, "absoluteSizes", void 0);
__decorate([
  serialize()
], FluentBackplateMaterial.prototype, "baseColor", void 0);
__decorate([
  serialize()
], FluentBackplateMaterial.prototype, "lineColor", void 0);
__decorate([
  serialize()
], FluentBackplateMaterial.prototype, "blobIntensity", void 0);
__decorate([
  serialize()
], FluentBackplateMaterial.prototype, "blobFarSize", void 0);
__decorate([
  serialize()
], FluentBackplateMaterial.prototype, "blobNearDistance", void 0);
__decorate([
  serialize()
], FluentBackplateMaterial.prototype, "blobFarDistance", void 0);
__decorate([
  serialize()
], FluentBackplateMaterial.prototype, "blobFadeLength", void 0);
__decorate([
  serialize()
], FluentBackplateMaterial.prototype, "blobNearSize", void 0);
__decorate([
  serialize()
], FluentBackplateMaterial.prototype, "blobPulse", void 0);
__decorate([
  serialize()
], FluentBackplateMaterial.prototype, "blobFade", void 0);
__decorate([
  serialize()
], FluentBackplateMaterial.prototype, "blobNearSize2", void 0);
__decorate([
  serialize()
], FluentBackplateMaterial.prototype, "blobPulse2", void 0);
__decorate([
  serialize()
], FluentBackplateMaterial.prototype, "blobFade2", void 0);
__decorate([
  serialize()
], FluentBackplateMaterial.prototype, "highlightColor", void 0);
__decorate([
  serialize()
], FluentBackplateMaterial.prototype, "highlightWidth", void 0);
__decorate([
  serialize()
], FluentBackplateMaterial.prototype, "iridescenceIntensity", void 0);
__decorate([
  serialize()
], FluentBackplateMaterial.prototype, "iridescenceEdgeIntensity", void 0);
__decorate([
  serialize()
], FluentBackplateMaterial.prototype, "fadeOut", void 0);
__decorate([
  serializeAsVector3()
], FluentBackplateMaterial.prototype, "globalLeftIndexTipPosition", void 0);
__decorate([
  serializeAsVector3()
], FluentBackplateMaterial.prototype, "globalRightIndexTipPosition", void 0);
RegisterClass("BABYLON.GUI.FluentBackplateMaterial", FluentBackplateMaterial);

// node_modules/@babylonjs/gui/3D/controls/holographicBackplate.js
var HolographicBackplate = class _HolographicBackplate extends Control3D {
  /**
   * Rendering ground id of the backplate mesh.
   */
  set renderingGroupId(id) {
    this._model.renderingGroupId = id;
  }
  get renderingGroupId() {
    return this._model.renderingGroupId;
  }
  /**
   * Gets the material used by the backplate
   */
  get material() {
    return this._material;
  }
  /**
   * Gets a boolean indicating if this backplate shares its material with other HolographicBackplates
   */
  get shareMaterials() {
    return this._shareMaterials;
  }
  /**
   * Creates a new holographic backplate
   * @param name defines the control name
   * @param _shareMaterials
   */
  constructor(name22, _shareMaterials = true) {
    super(name22);
    this._shareMaterials = _shareMaterials;
  }
  _getTypeName() {
    return "HolographicBackplate";
  }
  // Mesh association
  _createNode(scene) {
    const collisionMesh = CreateBox((this.name ?? "HolographicBackplate") + "_CollisionMesh", {
      width: 1,
      height: 1,
      depth: 1
    }, scene);
    collisionMesh.isPickable = true;
    collisionMesh.visibility = 0;
    SceneLoader.ImportMeshAsync(void 0, _HolographicBackplate.MODEL_BASE_URL, _HolographicBackplate.MODEL_FILENAME, scene).then((result) => {
      const importedModel = result.meshes[1];
      importedModel.name = `${this.name}_frontPlate`;
      importedModel.isPickable = false;
      importedModel.parent = collisionMesh;
      if (this._material) {
        importedModel.material = this._material;
      }
      this._model = importedModel;
    });
    return collisionMesh;
  }
  _createMaterial(mesh) {
    this._material = new FluentBackplateMaterial(this.name + " Material", mesh.getScene());
  }
  _affectMaterial(mesh) {
    if (this._shareMaterials) {
      if (!this._host._touchSharedMaterials["fluentBackplateMaterial"]) {
        this._createMaterial(mesh);
        this._host._touchSharedMaterials["fluentBackplateMaterial"] = this._material;
      } else {
        this._material = this._host._touchSharedMaterials["fluentBackplateMaterial"];
      }
    } else {
      this._createMaterial(mesh);
    }
  }
  /**
   * Releases all associated resources
   */
  dispose() {
    super.dispose();
    if (!this.shareMaterials) {
      this._material.dispose();
    }
    this._model.dispose();
  }
};
HolographicBackplate.MODEL_BASE_URL = "https://assets.babylonjs.com/meshes/MRTK/";
HolographicBackplate.MODEL_FILENAME = "mrtk-fluent-backplate.glb";

// node_modules/@babylonjs/core/Meshes/Builders/planeBuilder.js
function CreatePlaneVertexData(options) {
  const indices = [];
  const positions = [];
  const normals = [];
  const uvs = [];
  const width = options.width || options.size || 1;
  const height = options.height || options.size || 1;
  const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;
  const halfWidth = width / 2;
  const halfHeight = height / 2;
  positions.push(-halfWidth, -halfHeight, 0);
  normals.push(0, 0, -1);
  uvs.push(0, useOpenGLOrientationForUV ? 1 : 0);
  positions.push(halfWidth, -halfHeight, 0);
  normals.push(0, 0, -1);
  uvs.push(1, useOpenGLOrientationForUV ? 1 : 0);
  positions.push(halfWidth, halfHeight, 0);
  normals.push(0, 0, -1);
  uvs.push(1, useOpenGLOrientationForUV ? 0 : 1);
  positions.push(-halfWidth, halfHeight, 0);
  normals.push(0, 0, -1);
  uvs.push(0, useOpenGLOrientationForUV ? 0 : 1);
  indices.push(0);
  indices.push(1);
  indices.push(2);
  indices.push(0);
  indices.push(2);
  indices.push(3);
  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);
  const vertexData = new VertexData();
  vertexData.indices = indices;
  vertexData.positions = positions;
  vertexData.normals = normals;
  vertexData.uvs = uvs;
  return vertexData;
}
function CreatePlane(name22, options = {}, scene = null) {
  const plane = new Mesh(name22, scene);
  options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);
  plane._originalBuilderSideOrientation = options.sideOrientation;
  const vertexData = CreatePlaneVertexData(options);
  vertexData.applyToMesh(plane, options.updatable);
  if (options.sourcePlane) {
    plane.translate(options.sourcePlane.normal, -options.sourcePlane.d);
    plane.setDirection(options.sourcePlane.normal.scale(-1));
  }
  return plane;
}
VertexData.CreatePlane = CreatePlaneVertexData;
Mesh.CreatePlane = (name22, size, scene, updatable, sideOrientation) => {
  const options = {
    size,
    width: size,
    height: size,
    sideOrientation,
    updatable
  };
  return CreatePlane(name22, options, scene);
};

// node_modules/@babylonjs/core/Behaviors/Meshes/fadeInOutBehavior.js
var FadeInOutBehavior = class {
  /**
   * Time in milliseconds to delay before fading in (Default: 0)
   * Will set both fade in and out delay to the same value
   */
  get delay() {
    return this.fadeInDelay;
  }
  set delay(value) {
    this.fadeInDelay = value;
    this.fadeOutDelay = value;
  }
  /**
   * Instantiates the FadeInOutBehavior
   */
  constructor() {
    this.fadeInDelay = 0;
    this.fadeOutDelay = 0;
    this.fadeInTime = 300;
    this.fadeOutTime = 300;
    this._millisecondsPerFrame = 1e3 / 60;
    this._hovered = false;
    this._hoverValue = 0;
    this._ownerNode = null;
    this._delay = 0;
    this._time = 300;
    this._update = () => {
      if (this._ownerNode) {
        this._hoverValue += this._hovered ? this._millisecondsPerFrame : -this._millisecondsPerFrame;
        this._setAllVisibility(this._ownerNode, (this._hoverValue - this._delay) / this._time);
        if (this._ownerNode.visibility > 1) {
          this._setAllVisibility(this._ownerNode, 1);
          if (this._hoverValue > this._time) {
            this._hoverValue = this._time;
            this._detachObserver();
            return;
          }
        } else if (this._ownerNode.visibility < 0) {
          this._setAllVisibility(this._ownerNode, 0);
          if (this._hoverValue < 0) {
            this._hoverValue = 0;
            this._detachObserver();
            return;
          }
        }
        this._attachObserver();
      }
    };
  }
  /**
   *  The name of the behavior
   */
  get name() {
    return "FadeInOut";
  }
  /**
   *  Initializes the behavior
   */
  init() {
  }
  /**
   * Attaches the fade behavior on the passed in mesh
   * @param ownerNode The mesh that will be faded in/out once attached
   */
  attach(ownerNode) {
    this._ownerNode = ownerNode;
    this._setAllVisibility(this._ownerNode, 0);
  }
  /**
   *  Detaches the behavior from the mesh
   */
  detach() {
    this._ownerNode = null;
  }
  /**
   * Triggers the mesh to begin fading in (or out)
   * @param fadeIn if the object should fade in or out (true to fade in)
   */
  fadeIn(fadeIn = true) {
    this._delay = fadeIn ? this.fadeInDelay : this.fadeOutDelay;
    this._time = fadeIn ? this.fadeInTime : this.fadeOutTime;
    this._detachObserver();
    if (this._ownerNode && (fadeIn && this._ownerNode.visibility >= 1 || !fadeIn && this._ownerNode.visibility <= 0)) {
      return;
    }
    this._hovered = fadeIn;
    if (!this._hovered) {
      this._delay *= -1;
    }
    if (this._ownerNode.visibility >= 1) {
      this._hoverValue = this._time;
    } else if (this._ownerNode.visibility <= 0) {
      this._hoverValue = 0;
    }
    this._update();
  }
  /**
   * Triggers the mesh to begin fading out
   */
  fadeOut() {
    this.fadeIn(false);
  }
  _setAllVisibility(mesh, value) {
    mesh.visibility = value;
    mesh.getChildMeshes().forEach((c) => {
      this._setAllVisibility(c, value);
    });
  }
  _attachObserver() {
    var _a;
    if (!this._onBeforeRenderObserver) {
      this._onBeforeRenderObserver = (_a = this._ownerNode) == null ? void 0 : _a.getScene().onBeforeRenderObservable.add(this._update);
    }
  }
  _detachObserver() {
    var _a;
    if (this._onBeforeRenderObserver) {
      (_a = this._ownerNode) == null ? void 0 : _a.getScene().onBeforeRenderObservable.remove(this._onBeforeRenderObserver);
      this._onBeforeRenderObserver = null;
    }
  }
};

// node_modules/@babylonjs/gui/3D/controls/holographicButton.js
var HolographicButton = class extends Button3D {
  _disposeTooltip() {
    this._tooltipFade = null;
    if (this._tooltipTextBlock) {
      this._tooltipTextBlock.dispose();
    }
    if (this._tooltipTexture) {
      this._tooltipTexture.dispose();
    }
    if (this._tooltipMesh) {
      this._tooltipMesh.dispose();
    }
    this.onPointerEnterObservable.remove(this._tooltipHoverObserver);
    this.onPointerOutObservable.remove(this._tooltipOutObserver);
  }
  /**
   * Rendering ground id of all the mesh in the button
   */
  set renderingGroupId(id) {
    this._backPlate.renderingGroupId = id;
    this._textPlate.renderingGroupId = id;
    this._frontPlate.renderingGroupId = id;
    if (this._tooltipMesh) {
      this._tooltipMesh.renderingGroupId = id;
    }
  }
  get renderingGroupId() {
    return this._backPlate.renderingGroupId;
  }
  /**
   * Text to be displayed on the tooltip shown when hovering on the button. When set to null tooltip is disabled. (Default: null)
   */
  set tooltipText(text) {
    if (!text) {
      this._disposeTooltip();
      return;
    }
    if (!this._tooltipFade) {
      const rightHandedScene = this._backPlate._scene.useRightHandedSystem;
      this._tooltipMesh = CreatePlane("", { size: 1 }, this._backPlate._scene);
      const tooltipBackground = CreatePlane("", { size: 1, sideOrientation: Mesh.DOUBLESIDE }, this._backPlate._scene);
      const mat = new StandardMaterial("", this._backPlate._scene);
      mat.diffuseColor = Color3.FromHexString("#212121");
      tooltipBackground.material = mat;
      tooltipBackground.isPickable = false;
      this._tooltipMesh.addChild(tooltipBackground);
      tooltipBackground.position = Vector3.Forward(rightHandedScene).scale(0.05);
      this._tooltipMesh.scaling.y = 1 / 3;
      this._tooltipMesh.position = Vector3.Up().scale(0.7).add(Vector3.Forward(rightHandedScene).scale(-0.15));
      this._tooltipMesh.isPickable = false;
      this._tooltipMesh.parent = this._backPlate;
      this._tooltipTexture = AdvancedDynamicTexture.CreateForMesh(this._tooltipMesh);
      this._tooltipTextBlock = new TextBlock();
      this._tooltipTextBlock.scaleY = 3;
      this._tooltipTextBlock.color = "white";
      this._tooltipTextBlock.fontSize = 130;
      this._tooltipTexture.addControl(this._tooltipTextBlock);
      this._tooltipFade = new FadeInOutBehavior();
      this._tooltipFade.delay = 500;
      this._tooltipMesh.addBehavior(this._tooltipFade);
      this._tooltipHoverObserver = this.onPointerEnterObservable.add(() => {
        if (this._tooltipFade) {
          this._tooltipFade.fadeIn(true);
        }
      });
      this._tooltipOutObserver = this.onPointerOutObservable.add(() => {
        if (this._tooltipFade) {
          this._tooltipFade.fadeIn(false);
        }
      });
    }
    if (this._tooltipTextBlock) {
      this._tooltipTextBlock.text = text;
    }
  }
  get tooltipText() {
    if (this._tooltipTextBlock) {
      return this._tooltipTextBlock.text;
    }
    return null;
  }
  /**
   * Gets or sets text for the button
   */
  get text() {
    return this._text;
  }
  set text(value) {
    if (this._text === value) {
      return;
    }
    this._text = value;
    this._rebuildContent();
  }
  /**
   * Gets or sets the image url for the button
   */
  get imageUrl() {
    return this._imageUrl;
  }
  set imageUrl(value) {
    if (this._imageUrl === value) {
      return;
    }
    this._imageUrl = value;
    this._rebuildContent();
  }
  /**
   * Gets the back material used by this button
   */
  get backMaterial() {
    return this._backMaterial;
  }
  /**
   * Gets the front material used by this button
   */
  get frontMaterial() {
    return this._frontMaterial;
  }
  /**
   * Gets the plate material used by this button
   */
  get plateMaterial() {
    return this._plateMaterial;
  }
  /**
   * Gets a boolean indicating if this button shares its material with other HolographicButtons
   */
  get shareMaterials() {
    return this._shareMaterials;
  }
  /**
   * Creates a new button
   * @param name defines the control name
   * @param shareMaterials
   */
  constructor(name22, shareMaterials = true) {
    super(name22);
    this._shareMaterials = true;
    this._shareMaterials = shareMaterials;
    this.pointerEnterAnimation = () => {
      if (!this.mesh) {
        return;
      }
      this._frontPlate.setEnabled(true);
    };
    this.pointerOutAnimation = () => {
      if (!this.mesh) {
        return;
      }
      this._frontPlate.setEnabled(false);
    };
  }
  _getTypeName() {
    return "HolographicButton";
  }
  _rebuildContent() {
    this._disposeFacadeTexture();
    const panel = new StackPanel();
    panel.isVertical = true;
    if (IsDocumentAvailable() && !!document.createElement) {
      if (this._imageUrl) {
        const image = new Image();
        image.source = this._imageUrl;
        image.paddingTop = "40px";
        image.height = "180px";
        image.width = "100px";
        image.paddingBottom = "40px";
        panel.addControl(image);
      }
    }
    if (this._text) {
      const text = new TextBlock();
      text.text = this._text;
      text.color = "white";
      text.height = "30px";
      text.fontSize = 24;
      panel.addControl(text);
    }
    if (this._frontPlate) {
      this.content = panel;
    }
  }
  // Mesh association
  _createNode(scene) {
    this._backPlate = CreateBox(this.name + "BackMesh", {
      width: 1,
      height: 1,
      depth: 0.08
    }, scene);
    this._frontPlate = CreateBox(this.name + "FrontMesh", {
      width: 1,
      height: 1,
      depth: 0.08
    }, scene);
    this._frontPlate.parent = this._backPlate;
    this._frontPlate.position = Vector3.Forward(scene.useRightHandedSystem).scale(-0.08);
    this._frontPlate.isPickable = false;
    this._frontPlate.setEnabled(false);
    this._textPlate = super._createNode(scene);
    this._textPlate.parent = this._backPlate;
    this._textPlate.position = Vector3.Forward(scene.useRightHandedSystem).scale(-0.08);
    this._textPlate.isPickable = false;
    return this._backPlate;
  }
  _applyFacade(facadeTexture) {
    this._plateMaterial.emissiveTexture = facadeTexture;
    this._plateMaterial.opacityTexture = facadeTexture;
  }
  _createBackMaterial(mesh) {
    this._backMaterial = new FluentMaterial(this.name + "Back Material", mesh.getScene());
    this._backMaterial.renderHoverLight = true;
    this._pickedPointObserver = this._host.onPickedPointChangedObservable.add((pickedPoint) => {
      if (pickedPoint) {
        this._backMaterial.hoverPosition = pickedPoint;
        this._backMaterial.hoverColor.a = 1;
      } else {
        this._backMaterial.hoverColor.a = 0;
      }
    });
  }
  _createFrontMaterial(mesh) {
    this._frontMaterial = new FluentMaterial(this.name + "Front Material", mesh.getScene());
    this._frontMaterial.innerGlowColorIntensity = 0;
    this._frontMaterial.alpha = 0.5;
    this._frontMaterial.renderBorders = true;
  }
  _createPlateMaterial(mesh) {
    this._plateMaterial = new StandardMaterial(this.name + "Plate Material", mesh.getScene());
    this._plateMaterial.specularColor = Color3.Black();
  }
  _affectMaterial(mesh) {
    if (this._shareMaterials) {
      if (!this._host._sharedMaterials["backFluentMaterial"]) {
        this._createBackMaterial(mesh);
        this._host._sharedMaterials["backFluentMaterial"] = this._backMaterial;
      } else {
        this._backMaterial = this._host._sharedMaterials["backFluentMaterial"];
      }
      if (!this._host._sharedMaterials["frontFluentMaterial"]) {
        this._createFrontMaterial(mesh);
        this._host._sharedMaterials["frontFluentMaterial"] = this._frontMaterial;
      } else {
        this._frontMaterial = this._host._sharedMaterials["frontFluentMaterial"];
      }
    } else {
      this._createBackMaterial(mesh);
      this._createFrontMaterial(mesh);
    }
    this._createPlateMaterial(mesh);
    this._backPlate.material = this._backMaterial;
    this._frontPlate.material = this._frontMaterial;
    this._textPlate.material = this._plateMaterial;
    this._rebuildContent();
  }
  /**
   * Releases all associated resources
   */
  dispose() {
    super.dispose();
    this._disposeTooltip();
    if (!this.shareMaterials) {
      this._backMaterial.dispose();
      this._frontMaterial.dispose();
      this._plateMaterial.dispose();
      if (this._pickedPointObserver) {
        this._host.onPickedPointChangedObservable.remove(this._pickedPointObserver);
        this._pickedPointObserver = null;
      }
    }
  }
};

// node_modules/@babylonjs/gui/3D/materials/fluentButton/shaders/fluentButton.fragment.js
var name6 = "fluentButtonPixelShader";
var shader5 = `uniform vec3 cameraPosition;varying vec3 vPosition;varying vec3 vNormal;varying vec2 vUV;varying vec3 vTangent;varying vec3 vBinormal;varying vec4 vColor;varying vec4 vExtra1;uniform float _Edge_Width_;uniform vec4 _Edge_Color_;uniform bool _Relative_Width_;uniform float _Proximity_Max_Intensity_;uniform float _Proximity_Far_Distance_;uniform float _Proximity_Near_Radius_;uniform float _Proximity_Anisotropy_;uniform float _Selection_Fuzz_;uniform float _Selected_;uniform float _Selection_Fade_;uniform float _Selection_Fade_Size_;uniform float _Selected_Distance_;uniform float _Selected_Fade_Length_;uniform bool _Blob_Enable_;uniform vec3 _Blob_Position_;uniform float _Blob_Intensity_;uniform float _Blob_Near_Size_;uniform float _Blob_Far_Size_;uniform float _Blob_Near_Distance_;uniform float _Blob_Far_Distance_;uniform float _Blob_Fade_Length_;uniform float _Blob_Inner_Fade_;uniform float _Blob_Pulse_;uniform float _Blob_Fade_;uniform sampler2D _Blob_Texture_;uniform bool _Blob_Enable_2_;uniform vec3 _Blob_Position_2_;uniform float _Blob_Near_Size_2_;uniform float _Blob_Inner_Fade_2_;uniform float _Blob_Pulse_2_;uniform float _Blob_Fade_2_;uniform vec3 _Active_Face_Dir_;uniform vec3 _Active_Face_Up_;uniform bool Enable_Fade;uniform float _Fade_Width_;uniform bool _Smooth_Active_Face_;uniform bool _Show_Frame_;uniform bool _Use_Blob_Texture_;uniform bool Use_Global_Left_Index;uniform bool Use_Global_Right_Index;uniform vec4 Global_Left_Index_Tip_Position;uniform vec4 Global_Right_Index_Tip_Position;uniform vec4 Global_Left_Thumb_Tip_Position;uniform vec4 Global_Right_Thumb_Tip_Position;uniform float Global_Left_Index_Tip_Proximity;uniform float Global_Right_Index_Tip_Proximity;void Holo_Edge_Fragment_B35(
vec4 Edges,
float Edge_Width,
out float NotEdge)
{vec2 c=vec2(min(Edges.r,Edges.g),min(Edges.b,Edges.a));vec2 df=fwidth(c)*Edge_Width;vec2 g=clamp(c/df,0.0,1.0);NotEdge=g.x*g.y;}
void Blob_Fragment_B39(
vec2 UV,
vec3 Blob_Info,
sampler2D Blob_Texture,
out vec4 Blob_Color)
{float k=dot(UV,UV);Blob_Color=Blob_Info.y*texture(Blob_Texture,vec2(vec2(sqrt(k),Blob_Info.x).x,1.0-vec2(sqrt(k),Blob_Info.x).y))*(1.0-clamp(k,0.0,1.0));}
vec2 FilterStep(vec2 Edge,vec2 X)
{vec2 dX=max(fwidth(X),vec2(0.00001,0.00001));return clamp( (X+dX-max(Edge,X-dX))/(dX*2.0),0.0,1.0);}
void Wireframe_Fragment_B59(
vec3 Widths,
vec2 UV,
float Proximity,
vec4 Edge_Color,
out vec4 Wireframe)
{vec2 c=min(UV,vec2(1.0,1.0)-UV);vec2 g=FilterStep(Widths.xy*0.5,c); 
Wireframe=(1.0-min(g.x,g.y))*Proximity*Edge_Color;}
void Proximity_B53(
vec3 Proximity_Center,
vec3 Proximity_Center_2,
float Proximity_Max_Intensity,
float Proximity_Near_Radius,
vec3 Position,
vec3 Show_Selection,
vec4 Extra1,
float Dist_To_Face,
float Intensity,
out float Proximity)
{vec2 delta1=Extra1.xy;vec2 delta2=Extra1.zw;float d2=sqrt(min(dot(delta1,delta1),dot(delta2,delta2))+Dist_To_Face*Dist_To_Face);Proximity=Intensity*Proximity_Max_Intensity*(1.0-clamp(d2/Proximity_Near_Radius,0.0,1.0))*(1.0-Show_Selection.x)+Show_Selection.x;}
void To_XYZ_B46(
vec3 Vec3,
out float X,
out float Y,
out float Z)
{X=Vec3.x;Y=Vec3.y;Z=Vec3.z;}
void main()
{float NotEdge_Q35;
#if ENABLE_FADE
Holo_Edge_Fragment_B35(vColor,_Fade_Width_,NotEdge_Q35);
#else
NotEdge_Q35=1.0;
#endif
vec4 Blob_Color_Q39;float k=dot(vUV,vUV);vec2 blobTextureCoord=vec2(vec2(sqrt(k),vTangent.x).x,1.0-vec2(sqrt(k),vTangent.x).y);vec4 blobColor=mix(vec4(1.0,1.0,1.0,1.0)*step(1.0-vTangent.x,clamp(sqrt(k)+0.1,0.0,1.0)),texture(_Blob_Texture_,blobTextureCoord),float(_Use_Blob_Texture_));Blob_Color_Q39=vTangent.y*blobColor*(1.0-clamp(k,0.0,1.0));float Is_Quad_Q24;Is_Quad_Q24=vNormal.z;vec3 Blob_Position_Q41= mix(_Blob_Position_,Global_Left_Index_Tip_Position.xyz,float(Use_Global_Left_Index));vec3 Blob_Position_Q42= mix(_Blob_Position_2_,Global_Right_Index_Tip_Position.xyz,float(Use_Global_Right_Index));float X_Q46;float Y_Q46;float Z_Q46;To_XYZ_B46(vBinormal,X_Q46,Y_Q46,Z_Q46);float Proximity_Q53;Proximity_B53(Blob_Position_Q41,Blob_Position_Q42,_Proximity_Max_Intensity_,_Proximity_Near_Radius_,vPosition,vBinormal,vExtra1,Y_Q46,Z_Q46,Proximity_Q53);vec4 Wireframe_Q59;Wireframe_Fragment_B59(vNormal,vUV,Proximity_Q53,_Edge_Color_,Wireframe_Q59);vec4 Wire_Or_Blob_Q23=mix(Wireframe_Q59,Blob_Color_Q39,Is_Quad_Q24);vec4 Result_Q22;Result_Q22=mix(Wire_Or_Blob_Q23,vec4(0.3,0.3,0.3,0.3),float(_Show_Frame_));vec4 Final_Color_Q37=NotEdge_Q35*Result_Q22;vec4 Out_Color=Final_Color_Q37;float Clip_Threshold=0.0;bool To_sRGB=false;gl_FragColor=Out_Color;}`;
ShaderStore.ShadersStore[name6] = shader5;

// node_modules/@babylonjs/gui/3D/materials/fluentButton/shaders/fluentButton.vertex.js
var name7 = "fluentButtonVertexShader";
var shader6 = `uniform mat4 world;uniform mat4 viewProjection;uniform vec3 cameraPosition;attribute vec3 position;attribute vec3 normal;attribute vec2 uv;attribute vec3 tangent;attribute vec4 color;uniform float _Edge_Width_;uniform vec4 _Edge_Color_;uniform float _Proximity_Max_Intensity_;uniform float _Proximity_Far_Distance_;uniform float _Proximity_Near_Radius_;uniform float _Proximity_Anisotropy_;uniform float _Selection_Fuzz_;uniform float _Selected_;uniform float _Selection_Fade_;uniform float _Selection_Fade_Size_;uniform float _Selected_Distance_;uniform float _Selected_Fade_Length_;uniform bool _Blob_Enable_;uniform vec3 _Blob_Position_;uniform float _Blob_Intensity_;uniform float _Blob_Near_Size_;uniform float _Blob_Far_Size_;uniform float _Blob_Near_Distance_;uniform float _Blob_Far_Distance_;uniform float _Blob_Fade_Length_;uniform float _Blob_Inner_Fade_;uniform float _Blob_Pulse_;uniform float _Blob_Fade_;uniform sampler2D _Blob_Texture_;uniform bool _Blob_Enable_2_;uniform vec3 _Blob_Position_2_;uniform float _Blob_Near_Size_2_;uniform float _Blob_Inner_Fade_2_;uniform float _Blob_Pulse_2_;uniform float _Blob_Fade_2_;uniform vec3 _Active_Face_Dir_;uniform vec3 _Active_Face_Up_;uniform bool _Enable_Fade_;uniform float _Fade_Width_;uniform bool _Smooth_Active_Face_;uniform bool _Show_Frame_;uniform bool Use_Global_Left_Index;uniform bool Use_Global_Right_Index;uniform vec4 Global_Left_Index_Tip_Position;uniform vec4 Global_Right_Index_Tip_Position;uniform vec4 Global_Left_Thumb_Tip_Position;uniform vec4 Global_Right_Thumb_Tip_Position;uniform float Global_Left_Index_Tip_Proximity;uniform float Global_Right_Index_Tip_Proximity;varying vec3 vPosition;varying vec3 vNormal;varying vec2 vUV;varying vec3 vTangent;varying vec3 vBinormal;varying vec4 vColor;varying vec4 vExtra1;void Blob_Vertex_B47(
vec3 Position,
vec3 Normal,
vec3 Tangent,
vec3 Bitangent,
vec3 Blob_Position,
float Intensity,
float Blob_Near_Size,
float Blob_Far_Size,
float Blob_Near_Distance,
float Blob_Far_Distance,
vec4 Vx_Color,
vec2 UV,
vec3 Face_Center,
vec2 Face_Size,
vec2 In_UV,
float Blob_Fade_Length,
float Selection_Fade,
float Selection_Fade_Size,
float Inner_Fade,
vec3 Active_Face_Center,
float Blob_Pulse,
float Blob_Fade,
float Blob_Enabled,
out vec3 Out_Position,
out vec2 Out_UV,
out vec3 Blob_Info)
{float blobSize,fadeIn;vec3 Hit_Position;Blob_Info=vec3(0.0,0.0,0.0);float Hit_Distance=dot(Blob_Position-Face_Center,Normal);Hit_Position=Blob_Position-Hit_Distance*Normal;float absD=abs(Hit_Distance);float lerpVal=clamp((absD-Blob_Near_Distance)/(Blob_Far_Distance-Blob_Near_Distance),0.0,1.0);fadeIn=1.0-clamp((absD-Blob_Far_Distance)/Blob_Fade_Length,0.0,1.0);float innerFade=1.0-clamp(-Hit_Distance/Inner_Fade,0.0,1.0);float farClip=clamp(1.0-step(Blob_Far_Distance+Blob_Fade_Length,absD),0.0,1.0);float size=mix(Blob_Near_Size,Blob_Far_Size,lerpVal)*farClip;blobSize=mix(size,Selection_Fade_Size,Selection_Fade)*innerFade*Blob_Enabled;Blob_Info.x=lerpVal*0.5+0.5;Blob_Info.y=fadeIn*Intensity*(1.0-Selection_Fade)*Blob_Fade;Blob_Info.x*=(1.0-Blob_Pulse);vec3 delta=Hit_Position-Face_Center;vec2 blobCenterXY=vec2(dot(delta,Tangent),dot(delta,Bitangent));vec2 quadUVin=2.0*UV-1.0; 
vec2 blobXY=blobCenterXY+quadUVin*blobSize;vec2 blobClipped=clamp(blobXY,-Face_Size*0.5,Face_Size*0.5);vec2 blobUV=(blobClipped-blobCenterXY)/max(blobSize,0.0001)*2.0;vec3 blobCorner=Face_Center+blobClipped.x*Tangent+blobClipped.y*Bitangent;Out_Position=mix(Position,blobCorner,Vx_Color.rrr);Out_UV=mix(In_UV,blobUV,Vx_Color.rr);}
vec2 ProjectProximity(
vec3 blobPosition,
vec3 position,
vec3 center,
vec3 dir,
vec3 xdir,
vec3 ydir,
out float vdistance
)
{vec3 delta=blobPosition-position;vec2 xy=vec2(dot(delta,xdir),dot(delta,ydir));vdistance=abs(dot(delta,dir));return xy;}
void Proximity_Vertex_B66(
vec3 Blob_Position,
vec3 Blob_Position_2,
vec3 Active_Face_Center,
vec3 Active_Face_Dir,
vec3 Position,
float Proximity_Far_Distance,
float Relative_Scale,
float Proximity_Anisotropy,
vec3 Up,
out vec4 Extra1,
out float Distance_To_Face,
out float Intensity)
{vec3 Active_Face_Dir_X=normalize(cross(Active_Face_Dir,Up));vec3 Active_Face_Dir_Y=cross(Active_Face_Dir,Active_Face_Dir_X);float distz1,distz2;Extra1.xy=ProjectProximity(Blob_Position,Position,Active_Face_Center,Active_Face_Dir,Active_Face_Dir_X*Proximity_Anisotropy,Active_Face_Dir_Y,distz1)/Relative_Scale;Extra1.zw=ProjectProximity(Blob_Position_2,Position,Active_Face_Center,Active_Face_Dir,Active_Face_Dir_X*Proximity_Anisotropy,Active_Face_Dir_Y,distz2)/Relative_Scale;Distance_To_Face=dot(Active_Face_Dir,Position-Active_Face_Center);Intensity=1.0-clamp(min(distz1,distz2)/Proximity_Far_Distance,0.0,1.0);}
void Holo_Edge_Vertex_B44(
vec3 Incident,
vec3 Normal,
vec2 UV,
vec3 Tangent,
vec3 Bitangent,
bool Smooth_Active_Face,
float Active,
out vec4 Holo_Edges)
{float NdotI=dot(Incident,Normal);vec2 flip=(UV-vec2(0.5,0.5));float udot=dot(Incident,Tangent)*flip.x*NdotI;float uval=1.0-float(udot>0.0);float vdot=-dot(Incident,Bitangent)*flip.y*NdotI;float vval=1.0-float(vdot>0.0);float Smooth_And_Active=step(1.0,float(Smooth_Active_Face && Active>0.0));uval=mix(uval,max(1.0,uval),Smooth_And_Active); 
vval=mix(vval,max(1.0,vval),Smooth_And_Active);Holo_Edges=vec4(1.0,1.0,1.0,1.0)-vec4(uval*UV.x,uval*(1.0-UV.x),vval*UV.y,vval*(1.0-UV.y));}
void Object_To_World_Pos_B13(
vec3 Pos_Object,
out vec3 Pos_World)
{Pos_World=(world*vec4(Pos_Object,1.0)).xyz;}
void Choose_Blob_B38(
vec4 Vx_Color,
vec3 Position1,
vec3 Position2,
bool Blob_Enable_1,
bool Blob_Enable_2,
float Near_Size_1,
float Near_Size_2,
float Blob_Inner_Fade_1,
float Blob_Inner_Fade_2,
float Blob_Pulse_1,
float Blob_Pulse_2,
float Blob_Fade_1,
float Blob_Fade_2,
out vec3 Position,
out float Near_Size,
out float Inner_Fade,
out float Blob_Enable,
out float Fade,
out float Pulse)
{Position=Position1*(1.0-Vx_Color.g)+Vx_Color.g*Position2;float b1=float(Blob_Enable_1);float b2=float(Blob_Enable_2);Blob_Enable=b1+(b2-b1)*Vx_Color.g;Pulse=Blob_Pulse_1*(1.0-Vx_Color.g)+Vx_Color.g*Blob_Pulse_2;Fade=Blob_Fade_1*(1.0-Vx_Color.g)+Vx_Color.g*Blob_Fade_2;Near_Size=Near_Size_1*(1.0-Vx_Color.g)+Vx_Color.g*Near_Size_2;Inner_Fade=Blob_Inner_Fade_1*(1.0-Vx_Color.g)+Vx_Color.g*Blob_Inner_Fade_2;}
void Wireframe_Vertex_B51(
vec3 Position,
vec3 Normal,
vec3 Tangent,
vec3 Bitangent,
float Edge_Width,
vec2 Face_Size,
out vec3 Wire_Vx_Pos,
out vec2 UV,
out vec2 Widths)
{Widths.xy=Edge_Width/Face_Size;float x=dot(Position,Tangent);float y=dot(Position,Bitangent);float dx=0.5-abs(x);float newx=(0.5-dx*Widths.x*2.0)*sign(x);float dy=0.5-abs(y);float newy=(0.5-dy*Widths.y*2.0)*sign(y);Wire_Vx_Pos=Normal*0.5+newx*Tangent+newy*Bitangent;UV.x=dot(Wire_Vx_Pos,Tangent)+0.5;UV.y=dot(Wire_Vx_Pos,Bitangent)+0.5;}
vec2 ramp2(vec2 start,vec2 end,vec2 x)
{return clamp((x-start)/(end-start),vec2(0.0,0.0),vec2(1.0,1.0));}
float computeSelection(
vec3 blobPosition,
vec3 normal,
vec3 tangent,
vec3 bitangent,
vec3 faceCenter,
vec2 faceSize,
float selectionFuzz,
float farDistance,
float fadeLength
)
{vec3 delta=blobPosition-faceCenter;float absD=abs(dot(delta,normal));float fadeIn=1.0-clamp((absD-farDistance)/fadeLength,0.0,1.0);vec2 blobCenterXY=vec2(dot(delta,tangent),dot(delta,bitangent));vec2 innerFace=faceSize*(1.0-selectionFuzz)*0.5;vec2 selectPulse=ramp2(-faceSize*0.5,-innerFace,blobCenterXY)-ramp2(innerFace,faceSize*0.5,blobCenterXY);return selectPulse.x*selectPulse.y*fadeIn;}
void Selection_Vertex_B48(
vec3 Blob_Position,
vec3 Blob_Position_2,
vec3 Face_Center,
vec2 Face_Size,
vec3 Normal,
vec3 Tangent,
vec3 Bitangent,
float Selection_Fuzz,
float Selected,
float Far_Distance,
float Fade_Length,
vec3 Active_Face_Dir,
out float Show_Selection)
{float select1=computeSelection(Blob_Position,Normal,Tangent,Bitangent,Face_Center,Face_Size,Selection_Fuzz,Far_Distance,Fade_Length);float select2=computeSelection(Blob_Position_2,Normal,Tangent,Bitangent,Face_Center,Face_Size,Selection_Fuzz,Far_Distance,Fade_Length);float Active=max(0.0,dot(Active_Face_Dir,Normal));Show_Selection=mix(max(select1,select2),1.0,Selected)*Active;}
void Proximity_Visibility_B54(
float Selection,
vec3 Proximity_Center,
vec3 Proximity_Center_2,
float Input_Width,
float Proximity_Far_Distance,
float Proximity_Radius,
vec3 Active_Face_Center,
vec3 Active_Face_Dir,
out float Width)
{vec3 boxEdges=(world*vec4(vec3(0.5,0.5,0.5),0.0)).xyz;float boxMaxSize=length(boxEdges);float d1=dot(Proximity_Center-Active_Face_Center,Active_Face_Dir);vec3 blob1=Proximity_Center-d1*Active_Face_Dir;float d2=dot(Proximity_Center_2-Active_Face_Center,Active_Face_Dir);vec3 blob2=Proximity_Center_2-d2*Active_Face_Dir;vec3 delta1=blob1-Active_Face_Center;vec3 delta2=blob2-Active_Face_Center;float dist1=dot(delta1,delta1);float dist2=dot(delta2,delta2);float nearestProxDist=sqrt(min(dist1,dist2));Width=Input_Width*(1.0-step(boxMaxSize+Proximity_Radius,nearestProxDist))*(1.0-step(Proximity_Far_Distance,min(d1,d2))*(1.0-step(0.0001,Selection)));}
void Object_To_World_Dir_B67(
vec3 Dir_Object,
out vec3 Dir_World)
{Dir_World=(world*vec4(Dir_Object,0.0)).xyz;}
void main()
{vec3 Active_Face_Center_Q49;Active_Face_Center_Q49=(world*vec4(_Active_Face_Dir_*0.5,1.0)).xyz;vec3 Blob_Position_Q41= mix(_Blob_Position_,Global_Left_Index_Tip_Position.xyz,float(Use_Global_Left_Index));vec3 Blob_Position_Q42= mix(_Blob_Position_2_,Global_Right_Index_Tip_Position.xyz,float(Use_Global_Right_Index));vec3 Active_Face_Dir_Q64=normalize((world*vec4(_Active_Face_Dir_,0.0)).xyz);float Relative_Scale_Q57;
#if RELATIVE_WIDTH
Relative_Scale_Q57=length((world*vec4(vec3(0,1,0),0.0)).xyz);
#else
Relative_Scale_Q57=1.0;
#endif
vec3 Tangent_World_Q30;Tangent_World_Q30=(world*vec4(tangent,0.0)).xyz;vec3 Binormal_World_Q31;Binormal_World_Q31=(world*vec4((cross(normal,tangent)),0.0)).xyz;vec3 Normal_World_Q60;Normal_World_Q60=(world*vec4(normal,0.0)).xyz;vec3 Result_Q18=0.5*normal;vec3 Dir_World_Q67;Object_To_World_Dir_B67(_Active_Face_Up_,Dir_World_Q67);float Product_Q56=_Edge_Width_*Relative_Scale_Q57;vec3 Normal_World_N_Q29=normalize(Normal_World_Q60);vec3 Tangent_World_N_Q28=normalize(Tangent_World_Q30);vec3 Binormal_World_N_Q32=normalize(Binormal_World_Q31);vec3 Position_Q38;float Near_Size_Q38;float Inner_Fade_Q38;float Blob_Enable_Q38;float Fade_Q38;float Pulse_Q38;Choose_Blob_B38(color,Blob_Position_Q41,Blob_Position_Q42,_Blob_Enable_,_Blob_Enable_2_,_Blob_Near_Size_,_Blob_Near_Size_2_,_Blob_Inner_Fade_,_Blob_Inner_Fade_2_,_Blob_Pulse_,_Blob_Pulse_2_,_Blob_Fade_,_Blob_Fade_2_,Position_Q38,Near_Size_Q38,Inner_Fade_Q38,Blob_Enable_Q38,Fade_Q38,Pulse_Q38);vec3 Face_Center_Q33;Face_Center_Q33=(world*vec4(Result_Q18,1.0)).xyz;vec2 Face_Size_Q50=vec2(length(Tangent_World_Q30),length(Binormal_World_Q31));float Show_Selection_Q48;Selection_Vertex_B48(Blob_Position_Q41,Blob_Position_Q42,Face_Center_Q33,Face_Size_Q50,Normal_World_N_Q29,Tangent_World_N_Q28,Binormal_World_N_Q32,_Selection_Fuzz_,_Selected_,_Selected_Distance_,_Selected_Fade_Length_,Active_Face_Dir_Q64,Show_Selection_Q48);vec3 Normalized_Q72=normalize(Dir_World_Q67);float Active_Q34=max(0.0,dot(Active_Face_Dir_Q64,Normal_World_N_Q29));float Width_Q54;Proximity_Visibility_B54(Show_Selection_Q48,Blob_Position_Q41,Blob_Position_Q42,Product_Q56,_Proximity_Far_Distance_,_Proximity_Near_Radius_,Active_Face_Center_Q49,Active_Face_Dir_Q64,Width_Q54);vec3 Wire_Vx_Pos_Q51;vec2 UV_Q51;vec2 Widths_Q51;Wireframe_Vertex_B51(position,normal,tangent,(cross(normal,tangent)),Width_Q54,Face_Size_Q50,Wire_Vx_Pos_Q51,UV_Q51,Widths_Q51);vec3 Vec3_Q27=vec3(Widths_Q51.x,Widths_Q51.y,color.r);vec3 Pos_World_Q13;Object_To_World_Pos_B13(Wire_Vx_Pos_Q51,Pos_World_Q13);vec3 Incident_Q36=normalize(Pos_World_Q13-cameraPosition);vec3 Out_Position_Q47;vec2 Out_UV_Q47;vec3 Blob_Info_Q47;Blob_Vertex_B47(Pos_World_Q13,Normal_World_N_Q29,Tangent_World_N_Q28,Binormal_World_N_Q32,Position_Q38,_Blob_Intensity_,Near_Size_Q38,_Blob_Far_Size_,_Blob_Near_Distance_,_Blob_Far_Distance_,color,uv,Face_Center_Q33,Face_Size_Q50,UV_Q51,_Blob_Fade_Length_,_Selection_Fade_,_Selection_Fade_Size_,Inner_Fade_Q38,Active_Face_Center_Q49,Pulse_Q38,Fade_Q38,Blob_Enable_Q38,Out_Position_Q47,Out_UV_Q47,Blob_Info_Q47);vec4 Extra1_Q66;float Distance_To_Face_Q66;float Intensity_Q66;Proximity_Vertex_B66(Blob_Position_Q41,Blob_Position_Q42,Active_Face_Center_Q49,Active_Face_Dir_Q64,Pos_World_Q13,_Proximity_Far_Distance_,Relative_Scale_Q57,_Proximity_Anisotropy_,Normalized_Q72,Extra1_Q66,Distance_To_Face_Q66,Intensity_Q66);vec4 Holo_Edges_Q44;Holo_Edge_Vertex_B44(Incident_Q36,Normal_World_N_Q29,uv,Tangent_World_Q30,Binormal_World_Q31,_Smooth_Active_Face_,Active_Q34,Holo_Edges_Q44);vec3 Vec3_Q19=vec3(Show_Selection_Q48,Distance_To_Face_Q66,Intensity_Q66);vec3 Position=Out_Position_Q47;vec2 UV=Out_UV_Q47;vec3 Tangent=Blob_Info_Q47;vec3 Binormal=Vec3_Q19;vec3 Normal=Vec3_Q27;vec4 Extra1=Extra1_Q66;vec4 Color=Holo_Edges_Q44;gl_Position=viewProjection*vec4(Position,1);vPosition=Position;vNormal=Normal;vUV=UV;vTangent=Tangent;vBinormal=Binormal;vColor=Color;vExtra1=Extra1;}`;
ShaderStore.ShadersStore[name7] = shader6;

// node_modules/@babylonjs/gui/3D/materials/fluentButton/fluentButtonMaterial.js
var FluentButtonMaterialDefines = class extends MaterialDefines {
  constructor() {
    super();
    this.RELATIVE_WIDTH = true;
    this.ENABLE_FADE = true;
    this._needNormals = true;
    this._needUVs = true;
    this.rebuild();
  }
};
var FluentButtonMaterial = class _FluentButtonMaterial extends PushMaterial {
  constructor(name22, scene) {
    super(name22, scene);
    this.edgeWidth = 0.04;
    this.edgeColor = new Color4(0.592157, 0.592157, 0.592157, 1);
    this.proximityMaxIntensity = 0.45;
    this.proximityFarDistance = 0.16;
    this.proximityNearRadius = 1.5;
    this.proximityAnisotropy = 1;
    this.selectionFuzz = 0.5;
    this.selected = 0;
    this.selectionFade = 0;
    this.selectionFadeSize = 0.3;
    this.selectedDistance = 0.08;
    this.selectedFadeLength = 0.08;
    this.blobIntensity = 0.5;
    this.blobFarSize = 0.05;
    this.blobNearDistance = 0;
    this.blobFarDistance = 0.08;
    this.blobFadeLength = 0.08;
    this.leftBlobEnable = true;
    this.leftBlobNearSize = 0.025;
    this.leftBlobPulse = 0;
    this.leftBlobFade = 1;
    this.leftBlobInnerFade = 0.01;
    this.rightBlobEnable = true;
    this.rightBlobNearSize = 0.025;
    this.rightBlobPulse = 0;
    this.rightBlobFade = 1;
    this.rightBlobInnerFade = 0.01;
    this.activeFaceDir = new Vector3(0, 0, -1);
    this.activeFaceUp = new Vector3(0, 1, 0);
    this.enableFade = true;
    this.fadeWidth = 1.5;
    this.smoothActiveFace = true;
    this.showFrame = false;
    this.useBlobTexture = true;
    this.globalLeftIndexTipPosition = Vector3.Zero();
    this.globalRightIndexTipPosition = Vector3.Zero();
    this.alphaMode = Constants.ALPHA_ADD;
    this.disableDepthWrite = true;
    this.backFaceCulling = false;
    this._blobTexture = new Texture(_FluentButtonMaterial.BLOB_TEXTURE_URL, this.getScene(), true, false, Texture.NEAREST_SAMPLINGMODE);
  }
  needAlphaBlending() {
    return true;
  }
  needAlphaTesting() {
    return true;
  }
  getAlphaTestTexture() {
    return null;
  }
  // Methods
  isReadyForSubMesh(mesh, subMesh) {
    const drawWrapper = subMesh._drawWrapper;
    if (this.isFrozen) {
      if (drawWrapper.effect && drawWrapper._wasPreviouslyReady) {
        return true;
      }
    }
    if (!subMesh.materialDefines) {
      subMesh.materialDefines = new FluentButtonMaterialDefines();
    }
    const defines = subMesh.materialDefines;
    const scene = this.getScene();
    if (this._isReadyForSubMesh(subMesh)) {
      return true;
    }
    const engine = scene.getEngine();
    PrepareDefinesForAttributes(mesh, defines, true, false);
    if (defines.isDirty) {
      defines.markAsProcessed();
      scene.resetCachedMaterial();
      const fallbacks = new EffectFallbacks();
      if (defines.FOG) {
        fallbacks.addFallback(1, "FOG");
      }
      HandleFallbacksForShadows(defines, fallbacks);
      defines.IMAGEPROCESSINGPOSTPROCESS = scene.imageProcessingConfiguration.applyByPostProcess;
      const attribs = [VertexBuffer.PositionKind];
      if (defines.NORMAL) {
        attribs.push(VertexBuffer.NormalKind);
      }
      if (defines.UV1) {
        attribs.push(VertexBuffer.UVKind);
      }
      if (defines.UV2) {
        attribs.push(VertexBuffer.UV2Kind);
      }
      if (defines.VERTEXCOLOR) {
        attribs.push(VertexBuffer.ColorKind);
      }
      if (defines.TANGENT) {
        attribs.push(VertexBuffer.TangentKind);
      }
      PrepareAttributesForInstances(attribs, defines);
      const shaderName = "fluentButton";
      const join = defines.toString();
      const uniforms = [
        "world",
        "viewProjection",
        "cameraPosition",
        "_Edge_Width_",
        "_Edge_Color_",
        "_Relative_Width_",
        "_Proximity_Max_Intensity_",
        "_Proximity_Far_Distance_",
        "_Proximity_Near_Radius_",
        "_Proximity_Anisotropy_",
        "_Selection_Fuzz_",
        "_Selected_",
        "_Selection_Fade_",
        "_Selection_Fade_Size_",
        "_Selected_Distance_",
        "_Selected_Fade_Length_",
        "_Blob_Enable_",
        "_Blob_Position_",
        "_Blob_Intensity_",
        "_Blob_Near_Size_",
        "_Blob_Far_Size_",
        "_Blob_Near_Distance_",
        "_Blob_Far_Distance_",
        "_Blob_Fade_Length_",
        "_Blob_Inner_Fade_",
        "_Blob_Pulse_",
        "_Blob_Fade_",
        "_Blob_Texture_",
        "_Blob_Enable_2_",
        "_Blob_Position_2_",
        "_Blob_Near_Size_2_",
        "_Blob_Inner_Fade_2_",
        "_Blob_Pulse_2_",
        "_Blob_Fade_2_",
        "_Active_Face_Dir_",
        "_Active_Face_Up_",
        "_Enable_Fade_",
        "_Fade_Width_",
        "_Smooth_Active_Face_",
        "_Show_Frame_",
        "_Use_Blob_Texture_",
        "Use_Global_Left_Index",
        "Use_Global_Right_Index",
        "Global_Left_Index_Tip_Position",
        "Global_Right_Index_Tip_Position",
        "Global_Left_Thumb_Tip_Position",
        "Global_Right_Thumb_Tip_Position",
        "Global_Left_Index_Tip_Proximity",
        "Global_Right_Index_Tip_Proximity"
      ];
      const samplers = ["_Blob_Texture_"];
      const uniformBuffers = [];
      PrepareUniformsAndSamplersList({
        uniformsNames: uniforms,
        uniformBuffersNames: uniformBuffers,
        samplers,
        defines,
        maxSimultaneousLights: 4
      });
      subMesh.setEffect(scene.getEngine().createEffect(shaderName, {
        attributes: attribs,
        uniformsNames: uniforms,
        uniformBuffersNames: uniformBuffers,
        samplers,
        defines: join,
        fallbacks,
        onCompiled: this.onCompiled,
        onError: this.onError,
        indexParameters: { maxSimultaneousLights: 4 }
      }, engine), defines, this._materialContext);
    }
    if (!subMesh.effect || !subMesh.effect.isReady()) {
      return false;
    }
    defines._renderId = scene.getRenderId();
    drawWrapper._wasPreviouslyReady = true;
    return true;
  }
  bindForSubMesh(world, mesh, subMesh) {
    const scene = this.getScene();
    const defines = subMesh.materialDefines;
    if (!defines) {
      return;
    }
    const effect = subMesh.effect;
    if (!effect) {
      return;
    }
    this._activeEffect = effect;
    this.bindOnlyWorldMatrix(world);
    this._activeEffect.setMatrix("viewProjection", scene.getTransformMatrix());
    this._activeEffect.setVector3("cameraPosition", scene.activeCamera.position);
    this._activeEffect.setTexture("_Blob_Texture_", this._blobTexture);
    this._activeEffect.setFloat("_Edge_Width_", this.edgeWidth);
    this._activeEffect.setColor4("_Edge_Color_", new Color3(this.edgeColor.r, this.edgeColor.g, this.edgeColor.b), this.edgeColor.a);
    this._activeEffect.setFloat("_Proximity_Max_Intensity_", this.proximityMaxIntensity);
    this._activeEffect.setFloat("_Proximity_Far_Distance_", this.proximityFarDistance);
    this._activeEffect.setFloat("_Proximity_Near_Radius_", this.proximityNearRadius);
    this._activeEffect.setFloat("_Proximity_Anisotropy_", this.proximityAnisotropy);
    this._activeEffect.setFloat("_Selection_Fuzz_", this.selectionFuzz);
    this._activeEffect.setFloat("_Selected_", this.selected);
    this._activeEffect.setFloat("_Selection_Fade_", this.selectionFade);
    this._activeEffect.setFloat("_Selection_Fade_Size_", this.selectionFadeSize);
    this._activeEffect.setFloat("_Selected_Distance_", this.selectedDistance);
    this._activeEffect.setFloat("_Selected_Fade_Length_", this.selectedFadeLength);
    this._activeEffect.setFloat("_Blob_Enable_", this.leftBlobEnable ? 1 : 0);
    this._activeEffect.setFloat("_Blob_Intensity_", this.blobIntensity);
    this._activeEffect.setFloat("_Blob_Near_Size_", this.leftBlobNearSize);
    this._activeEffect.setFloat("_Blob_Far_Size_", this.blobFarSize);
    this._activeEffect.setFloat("_Blob_Near_Distance_", this.blobNearDistance);
    this._activeEffect.setFloat("_Blob_Far_Distance_", this.blobFarDistance);
    this._activeEffect.setFloat("_Blob_Fade_Length_", this.blobFadeLength);
    this._activeEffect.setFloat("_Blob_Inner_Fade_", this.leftBlobInnerFade);
    this._activeEffect.setFloat("_Blob_Pulse_", this.leftBlobPulse);
    this._activeEffect.setFloat("_Blob_Fade_", this.leftBlobFade);
    this._activeEffect.setFloat("_Blob_Enable_2_", this.rightBlobEnable ? 1 : 0);
    this._activeEffect.setFloat("_Blob_Near_Size_2_", this.rightBlobNearSize);
    this._activeEffect.setFloat("_Blob_Inner_Fade_2_", this.rightBlobInnerFade);
    this._activeEffect.setFloat("_Blob_Pulse_2_", this.rightBlobPulse);
    this._activeEffect.setFloat("_Blob_Fade_2_", this.rightBlobFade);
    this._activeEffect.setVector3("_Active_Face_Dir_", this.activeFaceDir);
    this._activeEffect.setVector3("_Active_Face_Up_", this.activeFaceUp);
    this._activeEffect.setFloat("_Fade_Width_", this.fadeWidth);
    this._activeEffect.setFloat("_Smooth_Active_Face_", this.smoothActiveFace ? 1 : 0);
    this._activeEffect.setFloat("_Show_Frame_", this.showFrame ? 1 : 0);
    this._activeEffect.setFloat("_Use_Blob_Texture_", this.useBlobTexture ? 1 : 0);
    this._activeEffect.setFloat("Use_Global_Left_Index", 1);
    this._activeEffect.setFloat("Use_Global_Right_Index", 1);
    this._activeEffect.setVector4("Global_Left_Index_Tip_Position", new Vector4(this.globalLeftIndexTipPosition.x, this.globalLeftIndexTipPosition.y, this.globalLeftIndexTipPosition.z, 1));
    this._activeEffect.setVector4("Global_Right_Index_Tip_Position", new Vector4(this.globalRightIndexTipPosition.x, this.globalRightIndexTipPosition.y, this.globalRightIndexTipPosition.z, 1));
    this._afterBind(mesh, this._activeEffect, subMesh);
  }
  /**
   * Get the list of animatables in the material.
   * @returns the list of animatables object used in the material
   */
  getAnimatables() {
    return [];
  }
  dispose(forceDisposeEffect) {
    super.dispose(forceDisposeEffect);
  }
  clone(name22) {
    return SerializationHelper.Clone(() => new _FluentButtonMaterial(name22, this.getScene()), this);
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.customType = "BABYLON.FluentButtonMaterial";
    return serializationObject;
  }
  getClassName() {
    return "FluentButtonMaterial";
  }
  // Statics
  static Parse(source, scene, rootUrl) {
    return SerializationHelper.Parse(() => new _FluentButtonMaterial(source.name, scene), source, scene, rootUrl);
  }
};
FluentButtonMaterial.BLOB_TEXTURE_URL = "https://assets.babylonjs.com/meshes/MRTK/mrtk-fluent-button-blob.png";
__decorate([
  serialize()
], FluentButtonMaterial.prototype, "edgeWidth", void 0);
__decorate([
  serializeAsColor4()
], FluentButtonMaterial.prototype, "edgeColor", void 0);
__decorate([
  serialize()
], FluentButtonMaterial.prototype, "proximityMaxIntensity", void 0);
__decorate([
  serialize()
], FluentButtonMaterial.prototype, "proximityFarDistance", void 0);
__decorate([
  serialize()
], FluentButtonMaterial.prototype, "proximityNearRadius", void 0);
__decorate([
  serialize()
], FluentButtonMaterial.prototype, "proximityAnisotropy", void 0);
__decorate([
  serialize()
], FluentButtonMaterial.prototype, "selectionFuzz", void 0);
__decorate([
  serialize()
], FluentButtonMaterial.prototype, "selected", void 0);
__decorate([
  serialize()
], FluentButtonMaterial.prototype, "selectionFade", void 0);
__decorate([
  serialize()
], FluentButtonMaterial.prototype, "selectionFadeSize", void 0);
__decorate([
  serialize()
], FluentButtonMaterial.prototype, "selectedDistance", void 0);
__decorate([
  serialize()
], FluentButtonMaterial.prototype, "selectedFadeLength", void 0);
__decorate([
  serialize()
], FluentButtonMaterial.prototype, "blobIntensity", void 0);
__decorate([
  serialize()
], FluentButtonMaterial.prototype, "blobFarSize", void 0);
__decorate([
  serialize()
], FluentButtonMaterial.prototype, "blobNearDistance", void 0);
__decorate([
  serialize()
], FluentButtonMaterial.prototype, "blobFarDistance", void 0);
__decorate([
  serialize()
], FluentButtonMaterial.prototype, "blobFadeLength", void 0);
__decorate([
  serialize()
], FluentButtonMaterial.prototype, "leftBlobEnable", void 0);
__decorate([
  serialize()
], FluentButtonMaterial.prototype, "leftBlobNearSize", void 0);
__decorate([
  serialize()
], FluentButtonMaterial.prototype, "leftBlobPulse", void 0);
__decorate([
  serialize()
], FluentButtonMaterial.prototype, "leftBlobFade", void 0);
__decorate([
  serialize()
], FluentButtonMaterial.prototype, "leftBlobInnerFade", void 0);
__decorate([
  serialize()
], FluentButtonMaterial.prototype, "rightBlobEnable", void 0);
__decorate([
  serialize()
], FluentButtonMaterial.prototype, "rightBlobNearSize", void 0);
__decorate([
  serialize()
], FluentButtonMaterial.prototype, "rightBlobPulse", void 0);
__decorate([
  serialize()
], FluentButtonMaterial.prototype, "rightBlobFade", void 0);
__decorate([
  serialize()
], FluentButtonMaterial.prototype, "rightBlobInnerFade", void 0);
__decorate([
  serializeAsVector3()
], FluentButtonMaterial.prototype, "activeFaceDir", void 0);
__decorate([
  serializeAsVector3()
], FluentButtonMaterial.prototype, "activeFaceUp", void 0);
__decorate([
  serialize()
], FluentButtonMaterial.prototype, "enableFade", void 0);
__decorate([
  serialize()
], FluentButtonMaterial.prototype, "fadeWidth", void 0);
__decorate([
  serialize()
], FluentButtonMaterial.prototype, "smoothActiveFace", void 0);
__decorate([
  serialize()
], FluentButtonMaterial.prototype, "showFrame", void 0);
__decorate([
  serialize()
], FluentButtonMaterial.prototype, "useBlobTexture", void 0);
__decorate([
  serializeAsVector3()
], FluentButtonMaterial.prototype, "globalLeftIndexTipPosition", void 0);
__decorate([
  serializeAsVector3()
], FluentButtonMaterial.prototype, "globalRightIndexTipPosition", void 0);
RegisterClass("BABYLON.GUI.FluentButtonMaterial", FluentButtonMaterial);

// node_modules/@babylonjs/gui/3D/controls/touchButton3D.js
var TouchButton3D = class extends Button3D {
  /**
   * Creates a new touchable button
   * @param name defines the control name
   * @param collisionMesh mesh to track collisions with
   */
  constructor(name22, collisionMesh) {
    super(name22);
    this._isNearPressed = false;
    this._interactionSurfaceHeight = 0;
    this._isToggleButton = false;
    this._toggleState = false;
    this._toggleButtonCallback = () => {
      this._onToggle(!this._toggleState);
    };
    this.onToggleObservable = new Observable();
    this.collidableFrontDirection = Vector3.Zero();
    if (collisionMesh) {
      this.collisionMesh = collisionMesh;
    }
  }
  /**
   * Whether the current interaction is caused by near interaction or not
   */
  get isActiveNearInteraction() {
    return this._isNearPressed;
  }
  /**
   * Sets the front-facing direction of the button. Pass in Vector3.Zero to allow interactions from any direction
   * @param frontWorldDir the forward direction of the button
   */
  set collidableFrontDirection(frontWorldDir) {
    this._collidableFrontDirection = frontWorldDir.normalize();
    if (this._collisionMesh) {
      const invert = TmpVectors.Matrix[0];
      invert.copyFrom(this._collisionMesh.getWorldMatrix());
      invert.invert();
      Vector3.TransformNormalToRef(this._collidableFrontDirection, invert, this._collidableFrontDirection);
      this._collidableFrontDirection.normalize();
    }
  }
  /**
   * Returns the front-facing direction of the button, or Vector3.Zero if there is no 'front'
   */
  get collidableFrontDirection() {
    if (this._collisionMesh) {
      const transformedDirection = TmpVectors.Vector3[0];
      Vector3.TransformNormalToRef(this._collidableFrontDirection, this._collisionMesh.getWorldMatrix(), transformedDirection);
      return transformedDirection.normalize();
    }
    return this._collidableFrontDirection;
  }
  /**
   * Sets the mesh used for testing input collision
   * @param collisionMesh the new collision mesh for the button
   */
  set collisionMesh(collisionMesh) {
    var _a;
    if (this._collisionMesh) {
      this._collisionMesh.isNearPickable = false;
      if ((_a = this._collisionMesh.reservedDataStore) == null ? void 0 : _a.GUI3D) {
        this._collisionMesh.reservedDataStore.GUI3D = {};
      }
      this._collisionMesh.getChildMeshes().forEach((mesh) => {
        var _a2;
        mesh.isNearPickable = false;
        if ((_a2 = mesh.reservedDataStore) == null ? void 0 : _a2.GUI3D) {
          mesh.reservedDataStore.GUI3D = {};
        }
      });
    }
    this._collisionMesh = collisionMesh;
    this._injectGUI3DReservedDataStore(this._collisionMesh).control = this;
    this._collisionMesh.isNearPickable = true;
    this._collisionMesh.getChildMeshes().forEach((mesh) => {
      this._injectGUI3DReservedDataStore(mesh).control = this;
      mesh.isNearPickable = true;
    });
    this.collidableFrontDirection = collisionMesh.forward;
  }
  /**
   * Setter for if this TouchButton3D should be treated as a toggle button
   * @param value If this TouchHolographicButton should act like a toggle button
   */
  set isToggleButton(value) {
    if (value === this._isToggleButton) {
      return;
    }
    this._isToggleButton = value;
    if (value) {
      this.onPointerUpObservable.add(this._toggleButtonCallback);
    } else {
      this.onPointerUpObservable.removeCallback(this._toggleButtonCallback);
      if (this._toggleState) {
        this._onToggle(false);
      }
    }
  }
  get isToggleButton() {
    return this._isToggleButton;
  }
  /**
   * A public entrypoint to set the toggle state of the TouchHolographicButton. Only works if 'isToggleButton' is true
   * @param newState The new state to set the TouchHolographicButton's toggle state to
   */
  set isToggled(newState) {
    if (this._isToggleButton && this._toggleState !== newState) {
      this._onToggle(newState);
    }
  }
  get isToggled() {
    return this._toggleState;
  }
  _onToggle(newState) {
    this._toggleState = newState;
    this.onToggleObservable.notifyObservers(newState);
  }
  // Returns true if the collidable is in front of the button, or if the button has no front direction
  _isInteractionInFrontOfButton(collidablePos) {
    return this._getInteractionHeight(collidablePos, this._collisionMesh.getAbsolutePosition()) > 0;
  }
  /**
   * Get the height of the touchPoint from the collidable part of the button
   * @param touchPoint the point to compare to the button, in absolute position
   * @returns the depth of the touch point into the front of the button
   */
  getPressDepth(touchPoint) {
    if (!this._isNearPressed) {
      return 0;
    }
    const interactionHeight = this._getInteractionHeight(touchPoint, this._collisionMesh.getAbsolutePosition());
    return this._interactionSurfaceHeight - interactionHeight;
  }
  // Returns true if the collidable is in front of the button, or if the button has no front direction
  _getInteractionHeight(interactionPos, basePos) {
    const frontDir = this.collidableFrontDirection;
    if (frontDir.length() === 0) {
      return Vector3.Distance(interactionPos, basePos);
    }
    const d = Vector3.Dot(basePos, frontDir);
    const abc = Vector3.Dot(interactionPos, frontDir);
    return abc - d;
  }
  /**
   * @internal
   */
  _generatePointerEventType(providedType, nearMeshPosition, activeInteractionCount) {
    if (providedType === PointerEventTypes.POINTERDOWN || providedType === PointerEventTypes.POINTERMOVE) {
      if (!this._isInteractionInFrontOfButton(nearMeshPosition)) {
        return PointerEventTypes.POINTERMOVE;
      } else {
        this._isNearPressed = true;
        this._interactionSurfaceHeight = this._getInteractionHeight(nearMeshPosition, this._collisionMesh.getAbsolutePosition());
      }
    }
    if (providedType === PointerEventTypes.POINTERUP) {
      if (activeInteractionCount == 0) {
        return PointerEventTypes.POINTERMOVE;
      } else {
        this._isNearPressed = false;
      }
    }
    return providedType;
  }
  _getTypeName() {
    return "TouchButton3D";
  }
  // Mesh association
  _createNode(scene) {
    return super._createNode(scene);
  }
  /**
   * Releases all associated resources
   */
  dispose() {
    super.dispose();
    this.onPointerUpObservable.removeCallback(this._toggleButtonCallback);
    this.onToggleObservable.clear();
    if (this._collisionMesh) {
      this._collisionMesh.dispose();
    }
  }
};

// node_modules/@babylonjs/core/Maths/math.scalar.js
var HCF = HighestCommonFactor;
var Scalar = {
  ...math_scalar_functions_exports,
  /**
   * Two pi constants convenient for computation.
   */
  TwoPi: Math.PI * 2,
  /**
   * Returns -1 if value is negative and +1 is value is positive.
   * @param value the value
   * @returns the value itself if it's equal to zero.
   */
  Sign: Math.sign,
  /**
   * the log2 of value.
   * @param value the value to compute log2 of
   * @returns the log2 of value.
   */
  Log2: Math.log2,
  /**
   * Returns the highest common factor of two integers.
   * @param a first parameter
   * @param b second parameter
   * @returns HCF of a and b
   */
  HCF
};

// node_modules/@babylonjs/gui/3D/controls/touchHolographicButton.js
var TouchHolographicButton = class _TouchHolographicButton extends TouchButton3D {
  _disposeTooltip() {
    this._tooltipFade = null;
    if (this._tooltipTextBlock) {
      this._tooltipTextBlock.dispose();
    }
    if (this._tooltipTexture) {
      this._tooltipTexture.dispose();
    }
    if (this._tooltipMesh) {
      this._tooltipMesh.dispose();
    }
    this.onPointerEnterObservable.remove(this._tooltipHoverObserver);
    this.onPointerOutObservable.remove(this._tooltipOutObserver);
  }
  /**
   * Rendering ground id of all the mesh in the button
   */
  set renderingGroupId(id) {
    this._backPlate.renderingGroupId = id;
    this._textPlate.renderingGroupId = id;
    this._frontPlate.renderingGroupId = id;
    if (this._tooltipMesh) {
      this._tooltipMesh.renderingGroupId = id;
    }
  }
  get renderingGroupId() {
    return this._backPlate.renderingGroupId;
  }
  /**
   * Gets the mesh used to render this control
   */
  get mesh() {
    return this._backPlate;
  }
  /**
   * Text to be displayed on the tooltip shown when hovering on the button. When set to null tooltip is disabled. (Default: null)
   */
  set tooltipText(text) {
    if (!text) {
      this._disposeTooltip();
      return;
    }
    if (!this._tooltipFade) {
      const rightHandedScene = this._backPlate._scene.useRightHandedSystem;
      this._tooltipMesh = CreatePlane("", { size: 1 }, this._backPlate._scene);
      const tooltipBackground = CreatePlane("", { size: 1, sideOrientation: Mesh.DOUBLESIDE }, this._backPlate._scene);
      const mat = new StandardMaterial("", this._backPlate._scene);
      mat.diffuseColor = Color3.FromHexString("#212121");
      tooltipBackground.material = mat;
      tooltipBackground.isPickable = false;
      this._tooltipMesh.addChild(tooltipBackground);
      tooltipBackground.position = Vector3.Forward(rightHandedScene).scale(0.05);
      this._tooltipMesh.scaling.y = 1 / 3;
      this._tooltipMesh.position = Vector3.Up().scale(0.7).add(Vector3.Forward(rightHandedScene).scale(-0.15));
      this._tooltipMesh.isPickable = false;
      this._tooltipMesh.parent = this._backPlate;
      this._tooltipTexture = AdvancedDynamicTexture.CreateForMesh(this._tooltipMesh);
      this._tooltipTextBlock = new TextBlock();
      this._tooltipTextBlock.scaleY = 3;
      this._tooltipTextBlock.color = "white";
      this._tooltipTextBlock.fontSize = 130;
      this._tooltipTexture.addControl(this._tooltipTextBlock);
      this._tooltipFade = new FadeInOutBehavior();
      this._tooltipFade.delay = 500;
      this._tooltipMesh.addBehavior(this._tooltipFade);
      this._tooltipHoverObserver = this.onPointerEnterObservable.add(() => {
        if (this._tooltipFade) {
          this._tooltipFade.fadeIn(true);
        }
      });
      this._tooltipOutObserver = this.onPointerOutObservable.add(() => {
        if (this._tooltipFade) {
          this._tooltipFade.fadeIn(false);
        }
      });
    }
    if (this._tooltipTextBlock) {
      this._tooltipTextBlock.text = text;
    }
  }
  get tooltipText() {
    if (this._tooltipTextBlock) {
      return this._tooltipTextBlock.text;
    }
    return null;
  }
  /**
   * Gets or sets text for the button
   */
  get text() {
    return this._text;
  }
  set text(value) {
    if (this._text === value) {
      return;
    }
    this._text = value;
    this._rebuildContent();
  }
  /**
   * Gets or sets the image url for the button
   */
  get imageUrl() {
    return this._imageUrl;
  }
  set imageUrl(value) {
    if (this._imageUrl === value) {
      return;
    }
    this._imageUrl = value;
    this._rebuildContent();
  }
  /**
   * Gets the back material used by this button
   */
  get backMaterial() {
    return this._backMaterial;
  }
  /**
   * Gets the front material used by this button
   */
  get frontMaterial() {
    return this._frontMaterial;
  }
  /**
   * Gets the plate material used by this button
   */
  get plateMaterial() {
    return this._plateMaterial;
  }
  /**
   * Gets a boolean indicating if this button shares its material with other HolographicButtons
   */
  get shareMaterials() {
    return this._shareMaterials;
  }
  /**
   * Sets whether the backplate is visible or hidden. Hiding the backplate is not recommended without some sort of replacement
   */
  set isBackplateVisible(isVisible) {
    if (this.mesh && !!this._backMaterial) {
      if (isVisible && !this._isBackplateVisible) {
        this._backPlate.visibility = 1;
      } else if (!isVisible && this._isBackplateVisible) {
        this._backPlate.visibility = 0;
      }
    }
    this._isBackplateVisible = isVisible;
  }
  /**
   * Creates a new button
   * @param name defines the control name
   * @param shareMaterials
   */
  constructor(name22, shareMaterials = true) {
    super(name22);
    this._shareMaterials = true;
    this._isBackplateVisible = true;
    this._frontPlateDepth = 0.5;
    this._backPlateDepth = 0.04;
    this._backplateColor = new Color3(0.08, 0.15, 0.55);
    this._backplateToggledColor = new Color3(0.25, 0.4, 0.95);
    this._shareMaterials = shareMaterials;
    this.pointerEnterAnimation = () => {
      this._frontMaterial.leftBlobEnable = true;
      this._frontMaterial.rightBlobEnable = true;
    };
    this.pointerOutAnimation = () => {
      this._frontMaterial.leftBlobEnable = false;
      this._frontMaterial.rightBlobEnable = false;
    };
    this.pointerDownAnimation = () => {
      if (this._frontPlate && !this.isActiveNearInteraction) {
        this._frontPlate.scaling.z = this._frontPlateDepth * 0.2;
        this._frontPlate.position = Vector3.Forward(this._frontPlate._scene.useRightHandedSystem).scale((this._frontPlateDepth - 0.2 * this._frontPlateDepth) / 2);
        this._textPlate.position = Vector3.Forward(this._textPlate._scene.useRightHandedSystem).scale(-(this._backPlateDepth + 0.2 * this._frontPlateDepth) / 2);
      }
    };
    this.pointerUpAnimation = () => {
      if (this._frontPlate) {
        this._frontPlate.scaling.z = this._frontPlateDepth;
        this._frontPlate.position = Vector3.Forward(this._frontPlate._scene.useRightHandedSystem).scale((this._frontPlateDepth - this._frontPlateDepth) / 2);
        this._textPlate.position = Vector3.Forward(this._textPlate._scene.useRightHandedSystem).scale(-(this._backPlateDepth + this._frontPlateDepth) / 2);
      }
    };
    this.onPointerMoveObservable.add((position) => {
      if (this._frontPlate && this.isActiveNearInteraction) {
        const scale = Vector3.Zero();
        if (this._backPlate.getWorldMatrix().decompose(scale, void 0, void 0)) {
          let interactionHeight = this._getInteractionHeight(position, this._backPlate.getAbsolutePosition()) / scale.z;
          interactionHeight = Scalar.Clamp(interactionHeight - this._backPlateDepth / 2, 0.2 * this._frontPlateDepth, this._frontPlateDepth);
          this._frontPlate.scaling.z = interactionHeight;
          this._frontPlate.position = Vector3.Forward(this._frontPlate._scene.useRightHandedSystem).scale((this._frontPlateDepth - interactionHeight) / 2);
          this._textPlate.position = Vector3.Forward(this._textPlate._scene.useRightHandedSystem).scale(-(this._backPlateDepth + interactionHeight) / 2);
        }
      }
    });
    this._pointerHoverObserver = this.onPointerMoveObservable.add((hoverPosition) => {
      this._frontMaterial.globalLeftIndexTipPosition = hoverPosition;
    });
  }
  _getTypeName() {
    return "TouchHolographicButton";
  }
  _rebuildContent() {
    this._disposeFacadeTexture();
    const panel = new StackPanel();
    panel.isVertical = true;
    if (IsDocumentAvailable() && !!document.createElement) {
      if (this._imageUrl) {
        const image = new Image();
        image.source = this._imageUrl;
        image.paddingTop = "40px";
        image.height = "180px";
        image.width = "100px";
        image.paddingBottom = "40px";
        panel.addControl(image);
      }
    }
    if (this._text) {
      const text = new TextBlock();
      text.text = this._text;
      text.color = "white";
      text.height = "30px";
      text.fontSize = 24;
      panel.addControl(text);
    }
    this.content = panel;
  }
  // Mesh association
  _createNode(scene) {
    this.name = this.name ?? "TouchHolographicButton";
    const collisionMesh = CreateBox(`${this.name}_collisionMesh`, {
      width: 1,
      height: 1,
      depth: this._frontPlateDepth
    }, scene);
    collisionMesh.isPickable = true;
    collisionMesh.isNearPickable = true;
    collisionMesh.visibility = 0;
    collisionMesh.position = Vector3.Forward(scene.useRightHandedSystem).scale(-this._frontPlateDepth / 2);
    SceneLoader.ImportMeshAsync(void 0, _TouchHolographicButton.MODEL_BASE_URL, _TouchHolographicButton.MODEL_FILENAME, scene).then((result) => {
      const alphaMesh = CreateBox("${this.name}_alphaMesh", {
        width: 1,
        height: 1,
        depth: 1
      }, scene);
      alphaMesh.isPickable = false;
      alphaMesh.material = new StandardMaterial("${this.name}_alphaMesh_material", scene);
      alphaMesh.material.alpha = 0.15;
      const importedFrontPlate = result.meshes[1];
      importedFrontPlate.name = `${this.name}_frontPlate`;
      importedFrontPlate.isPickable = false;
      importedFrontPlate.scaling.z = this._frontPlateDepth;
      alphaMesh.parent = importedFrontPlate;
      importedFrontPlate.parent = collisionMesh;
      if (this._frontMaterial) {
        importedFrontPlate.material = this._frontMaterial;
      }
      this._frontPlate = importedFrontPlate;
    });
    this._backPlate = CreateBox(`${this.name}_backPlate`, {
      width: 1,
      height: 1,
      depth: this._backPlateDepth
    }, scene);
    this._backPlate.position = Vector3.Forward(scene.useRightHandedSystem).scale(this._backPlateDepth / 2);
    this._backPlate.isPickable = false;
    this._textPlate = super._createNode(scene);
    this._textPlate.name = `${this.name}_textPlate`;
    this._textPlate.isPickable = false;
    this._textPlate.position = Vector3.Forward(scene.useRightHandedSystem).scale(-this._frontPlateDepth / 2);
    this._backPlate.addChild(collisionMesh);
    this._backPlate.addChild(this._textPlate);
    const tn = new TransformNode(`{this.name}_root`, scene);
    this._backPlate.setParent(tn);
    this.collisionMesh = collisionMesh;
    this.collidableFrontDirection = this._backPlate.forward.negate();
    return tn;
  }
  _applyFacade(facadeTexture) {
    this._plateMaterial.emissiveTexture = facadeTexture;
    this._plateMaterial.opacityTexture = facadeTexture;
    this._plateMaterial.diffuseColor = new Color3(0.4, 0.4, 0.4);
  }
  _createBackMaterial(mesh) {
    this._backMaterial = new FluentMaterial(this.name + "backPlateMaterial", mesh.getScene());
    this._backMaterial.albedoColor = this._backplateColor;
    this._backMaterial.renderBorders = true;
    this._backMaterial.renderHoverLight = false;
  }
  _createFrontMaterial(mesh) {
    this._frontMaterial = new FluentButtonMaterial(this.name + "Front Material", mesh.getScene());
  }
  _createPlateMaterial(mesh) {
    this._plateMaterial = new StandardMaterial(this.name + "Plate Material", mesh.getScene());
    this._plateMaterial.specularColor = Color3.Black();
  }
  _onToggle(newState) {
    if (this._backMaterial) {
      if (newState) {
        this._backMaterial.albedoColor = this._backplateToggledColor;
      } else {
        this._backMaterial.albedoColor = this._backplateColor;
      }
    }
    super._onToggle(newState);
  }
  _affectMaterial(mesh) {
    if (this._shareMaterials) {
      if (!this._host._touchSharedMaterials["backFluentMaterial"]) {
        this._createBackMaterial(mesh);
        this._host._touchSharedMaterials["backFluentMaterial"] = this._backMaterial;
      } else {
        this._backMaterial = this._host._touchSharedMaterials["backFluentMaterial"];
      }
      if (!this._host._touchSharedMaterials["frontFluentMaterial"]) {
        this._createFrontMaterial(mesh);
        this._host._touchSharedMaterials["frontFluentMaterial"] = this._frontMaterial;
      } else {
        this._frontMaterial = this._host._touchSharedMaterials["frontFluentMaterial"];
      }
    } else {
      this._createBackMaterial(mesh);
      this._createFrontMaterial(mesh);
    }
    this._createPlateMaterial(mesh);
    this._backPlate.material = this._backMaterial;
    this._textPlate.material = this._plateMaterial;
    if (!this._isBackplateVisible) {
      this._backPlate.visibility = 0;
    }
    if (this._frontPlate) {
      this._frontPlate.material = this._frontMaterial;
    }
    this._rebuildContent();
  }
  /**
   * Releases all associated resources
   */
  dispose() {
    super.dispose();
    this._disposeTooltip();
    this.onPointerMoveObservable.remove(this._pointerHoverObserver);
    if (!this.shareMaterials) {
      this._backMaterial.dispose();
      this._frontMaterial.dispose();
      this._plateMaterial.dispose();
      if (this._pickedPointObserver) {
        this._host.onPickedPointChangedObservable.remove(this._pickedPointObserver);
        this._pickedPointObserver = null;
      }
    }
  }
};
TouchHolographicButton.MODEL_BASE_URL = "https://assets.babylonjs.com/meshes/MRTK/";
TouchHolographicButton.MODEL_FILENAME = "mrtk-fluent-button.glb";

// node_modules/@babylonjs/core/Behaviors/Meshes/followBehavior.js
var FollowBehavior = class {
  constructor() {
    this._tmpQuaternion = new Quaternion();
    this._tmpVectors = [new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3()];
    this._tmpMatrix = new Matrix();
    this._tmpInvertView = new Matrix();
    this._tmpForward = new Vector3();
    this._tmpNodeForward = new Vector3();
    this._tmpPosition = new Vector3();
    this._workingPosition = new Vector3();
    this._workingQuaternion = new Quaternion();
    this._lastTick = -1;
    this._recenterNextUpdate = true;
    this.interpolatePose = true;
    this.lerpTime = 500;
    this.ignoreCameraPitchAndRoll = false;
    this.pitchOffset = 15;
    this.maxViewVerticalDegrees = 30;
    this.maxViewHorizontalDegrees = 30;
    this.orientToCameraDeadzoneDegrees = 60;
    this.ignoreDistanceClamp = false;
    this.ignoreAngleClamp = false;
    this.verticalMaxDistance = 0;
    this.defaultDistance = 0.8;
    this.maximumDistance = 2;
    this.minimumDistance = 0.3;
    this.useFixedVerticalOffset = false;
    this.fixedVerticalOffset = 0;
    this._enabled = true;
  }
  /**
   * The camera that should be followed by this behavior
   */
  get followedCamera() {
    return this._followedCamera || this._scene.activeCamera;
  }
  set followedCamera(camera) {
    this._followedCamera = camera;
  }
  /**
   *  The name of the behavior
   */
  get name() {
    return "Follow";
  }
  /**
   *  Initializes the behavior
   */
  init() {
  }
  /**
   * Attaches the follow behavior
   * @param ownerNode The mesh that will be following once attached
   * @param followedCamera The camera that should be followed by the node
   */
  attach(ownerNode, followedCamera) {
    this._scene = ownerNode.getScene();
    this.attachedNode = ownerNode;
    if (followedCamera) {
      this.followedCamera = followedCamera;
    }
    this._addObservables();
  }
  /**
   *  Detaches the behavior from the mesh
   */
  detach() {
    this.attachedNode = null;
    this._removeObservables();
  }
  /**
   * Recenters the attached node in front of the camera on the next update
   */
  recenter() {
    this._recenterNextUpdate = true;
  }
  _angleBetweenVectorAndPlane(vector, normal) {
    this._tmpVectors[0].copyFrom(vector);
    vector = this._tmpVectors[0];
    this._tmpVectors[1].copyFrom(normal);
    normal = this._tmpVectors[1];
    vector.normalize();
    normal.normalize();
    return Math.PI / 2 - Math.acos(Vector3.Dot(vector, normal));
  }
  _length2D(vector) {
    return Math.sqrt(vector.x * vector.x + vector.z * vector.z);
  }
  _distanceClamp(currentToTarget, moveToDefault = false) {
    let minDistance = this.minimumDistance;
    let maxDistance = this.maximumDistance;
    const defaultDistance = this.defaultDistance;
    const direction = this._tmpVectors[0];
    direction.copyFrom(currentToTarget);
    let currentDistance = direction.length();
    direction.normalizeFromLength(currentDistance);
    if (this.ignoreCameraPitchAndRoll) {
      minDistance = this._length2D(direction) * minDistance;
      maxDistance = this._length2D(direction) * maxDistance;
      const currentDistance2D = this._length2D(currentToTarget);
      direction.scaleInPlace(currentDistance / currentDistance2D);
      currentDistance = currentDistance2D;
    }
    let clampedDistance = currentDistance;
    if (moveToDefault) {
      clampedDistance = defaultDistance;
    } else {
      clampedDistance = Clamp(currentDistance, minDistance, maxDistance);
    }
    currentToTarget.copyFrom(direction).scaleInPlace(clampedDistance);
    return currentDistance !== clampedDistance;
  }
  _applyVerticalClamp(currentToTarget) {
    if (this.verticalMaxDistance !== 0) {
      currentToTarget.y = Clamp(currentToTarget.y, -this.verticalMaxDistance, this.verticalMaxDistance);
    }
  }
  _toOrientationQuatToRef(vector, quaternion) {
    Quaternion.RotationYawPitchRollToRef(Math.atan2(vector.x, vector.z), Math.atan2(vector.y, Math.sqrt(vector.z * vector.z + vector.x * vector.x)), 0, quaternion);
  }
  _applyPitchOffset(invertView) {
    const forward = this._tmpVectors[0];
    const right = this._tmpVectors[1];
    forward.copyFromFloats(0, 0, this._scene.useRightHandedSystem ? -1 : 1);
    right.copyFromFloats(1, 0, 0);
    Vector3.TransformNormalToRef(forward, invertView, forward);
    forward.y = 0;
    forward.normalize();
    Vector3.TransformNormalToRef(right, invertView, right);
    Quaternion.RotationAxisToRef(right, this.pitchOffset * Math.PI / 180, this._tmpQuaternion);
    forward.rotateByQuaternionToRef(this._tmpQuaternion, forward);
    this._toOrientationQuatToRef(forward, this._tmpQuaternion);
    this._tmpQuaternion.toRotationMatrix(this._tmpMatrix);
    invertView.copyFrom(this._tmpMatrix);
  }
  _angularClamp(invertView, currentToTarget) {
    const forward = this._tmpVectors[5];
    forward.copyFromFloats(0, 0, this._scene.useRightHandedSystem ? -1 : 1);
    const right = this._tmpVectors[6];
    right.copyFromFloats(1, 0, 0);
    Vector3.TransformNormalToRef(forward, invertView, forward);
    Vector3.TransformNormalToRef(right, invertView, right);
    const up = Vector3.UpReadOnly;
    const dist = currentToTarget.length();
    if (dist < Epsilon) {
      return false;
    }
    let angularClamped = false;
    const rotationQuat = this._tmpQuaternion;
    if (this.ignoreCameraPitchAndRoll) {
      const angle2 = Vector3.GetAngleBetweenVectorsOnPlane(currentToTarget, forward, right);
      Quaternion.RotationAxisToRef(right, angle2, rotationQuat);
      currentToTarget.rotateByQuaternionToRef(rotationQuat, currentToTarget);
    } else {
      const angle2 = -Vector3.GetAngleBetweenVectorsOnPlane(currentToTarget, forward, right);
      const minMaxAngle2 = this.maxViewVerticalDegrees * Math.PI / 180 * 0.5;
      if (angle2 < -minMaxAngle2) {
        Quaternion.RotationAxisToRef(right, -angle2 - minMaxAngle2, rotationQuat);
        currentToTarget.rotateByQuaternionToRef(rotationQuat, currentToTarget);
        angularClamped = true;
      } else if (angle2 > minMaxAngle2) {
        Quaternion.RotationAxisToRef(right, -angle2 + minMaxAngle2, rotationQuat);
        currentToTarget.rotateByQuaternionToRef(rotationQuat, currentToTarget);
        angularClamped = true;
      }
    }
    const angle = this._angleBetweenVectorAndPlane(currentToTarget, right) * (this._scene.useRightHandedSystem ? -1 : 1);
    const minMaxAngle = this.maxViewHorizontalDegrees * Math.PI / 180 * 0.5;
    if (angle < -minMaxAngle) {
      Quaternion.RotationAxisToRef(up, -angle - minMaxAngle, rotationQuat);
      currentToTarget.rotateByQuaternionToRef(rotationQuat, currentToTarget);
      angularClamped = true;
    } else if (angle > minMaxAngle) {
      Quaternion.RotationAxisToRef(up, -angle + minMaxAngle, rotationQuat);
      currentToTarget.rotateByQuaternionToRef(rotationQuat, currentToTarget);
      angularClamped = true;
    }
    return angularClamped;
  }
  _orientationClamp(currentToTarget, rotationQuaternion) {
    var _a;
    const toFollowed = this._tmpVectors[0];
    toFollowed.copyFrom(currentToTarget).scaleInPlace(-1).normalize();
    const up = this._tmpVectors[1];
    const right = this._tmpVectors[2];
    up.copyFromFloats(0, 1, 0);
    Vector3.CrossToRef(toFollowed, up, right);
    const length = right.length();
    if (length < Epsilon) {
      return;
    }
    right.normalizeFromLength(length);
    Vector3.CrossToRef(right, toFollowed, up);
    if ((_a = this.attachedNode) == null ? void 0 : _a.getScene().useRightHandedSystem) {
      Quaternion.FromLookDirectionRHToRef(toFollowed, up, rotationQuaternion);
    } else {
      Quaternion.FromLookDirectionLHToRef(toFollowed, up, rotationQuaternion);
    }
  }
  _passedOrientationDeadzone(currentToTarget, forward) {
    const leashToFollow = this._tmpVectors[5];
    leashToFollow.copyFrom(currentToTarget);
    leashToFollow.normalize();
    const angle = Math.abs(Vector3.GetAngleBetweenVectorsOnPlane(forward, leashToFollow, Vector3.UpReadOnly));
    return angle * 180 / Math.PI > this.orientToCameraDeadzoneDegrees;
  }
  _updateLeashing(camera) {
    if (this.attachedNode && this._enabled) {
      const oldParent = this.attachedNode.parent;
      this.attachedNode.setParent(null);
      const worldMatrix = this.attachedNode.getWorldMatrix();
      const currentToTarget = this._workingPosition;
      const rotationQuaternion = this._workingQuaternion;
      const pivot = this.attachedNode.getPivotPoint();
      const invertView = this._tmpInvertView;
      invertView.copyFrom(camera.getViewMatrix());
      invertView.invert();
      Vector3.TransformCoordinatesToRef(pivot, worldMatrix, currentToTarget);
      const position = this._tmpPosition;
      position.copyFromFloats(0, 0, 0);
      Vector3.TransformCoordinatesToRef(position, worldMatrix, position);
      position.scaleInPlace(-1).subtractInPlace(pivot);
      currentToTarget.subtractInPlace(camera.globalPosition);
      if (this.ignoreCameraPitchAndRoll) {
        this._applyPitchOffset(invertView);
      }
      let angularClamped = false;
      const forward = this._tmpForward;
      forward.copyFromFloats(0, 0, this._scene.useRightHandedSystem ? -1 : 1);
      Vector3.TransformNormalToRef(forward, invertView, forward);
      const nodeForward = this._tmpNodeForward;
      nodeForward.copyFromFloats(0, 0, this._scene.useRightHandedSystem ? -1 : 1);
      Vector3.TransformNormalToRef(nodeForward, worldMatrix, nodeForward);
      if (this._recenterNextUpdate) {
        currentToTarget.copyFrom(forward).scaleInPlace(this.defaultDistance);
      } else {
        if (this.ignoreAngleClamp) {
          const currentDistance = currentToTarget.length();
          currentToTarget.copyFrom(forward).scaleInPlace(currentDistance);
        } else {
          angularClamped = this._angularClamp(invertView, currentToTarget);
        }
      }
      let distanceClamped = false;
      if (!this.ignoreDistanceClamp) {
        distanceClamped = this._distanceClamp(currentToTarget, angularClamped);
        this._applyVerticalClamp(currentToTarget);
      }
      if (this.useFixedVerticalOffset) {
        currentToTarget.y = position.y - camera.globalPosition.y + this.fixedVerticalOffset;
      }
      if (angularClamped || distanceClamped || this._passedOrientationDeadzone(currentToTarget, nodeForward) || this._recenterNextUpdate) {
        this._orientationClamp(currentToTarget, rotationQuaternion);
      }
      this._workingPosition.subtractInPlace(pivot);
      this._recenterNextUpdate = false;
      this.attachedNode.setParent(oldParent);
    }
  }
  _updateTransformToGoal(elapsed) {
    if (!this.attachedNode || !this.followedCamera || !this._enabled) {
      return;
    }
    if (!this.attachedNode.rotationQuaternion) {
      this.attachedNode.rotationQuaternion = Quaternion.Identity();
    }
    const oldParent = this.attachedNode.parent;
    this.attachedNode.setParent(null);
    if (!this.interpolatePose) {
      this.attachedNode.position.copyFrom(this.followedCamera.globalPosition).addInPlace(this._workingPosition);
      this.attachedNode.rotationQuaternion.copyFrom(this._workingQuaternion);
      return;
    }
    const currentDirection = new Vector3();
    currentDirection.copyFrom(this.attachedNode.position).subtractInPlace(this.followedCamera.globalPosition);
    Vector3.SmoothToRef(currentDirection, this._workingPosition, elapsed, this.lerpTime, currentDirection);
    currentDirection.addInPlace(this.followedCamera.globalPosition);
    this.attachedNode.position.copyFrom(currentDirection);
    const currentRotation = new Quaternion();
    currentRotation.copyFrom(this.attachedNode.rotationQuaternion);
    Quaternion.SmoothToRef(currentRotation, this._workingQuaternion, elapsed, this.lerpTime, this.attachedNode.rotationQuaternion);
    this.attachedNode.setParent(oldParent);
  }
  _addObservables() {
    this._lastTick = Date.now();
    this._onBeforeRender = this._scene.onBeforeRenderObservable.add(() => {
      if (!this.followedCamera) {
        return;
      }
      const tick = Date.now();
      this._updateLeashing(this.followedCamera);
      this._updateTransformToGoal(tick - this._lastTick);
      this._lastTick = tick;
    });
  }
  _removeObservables() {
    if (this._onBeforeRender) {
      this._scene.onBeforeRenderObservable.remove(this._onBeforeRender);
    }
  }
};

// node_modules/@babylonjs/core/Behaviors/Meshes/baseSixDofDragBehavior.js
var BaseSixDofDragBehavior = class _BaseSixDofDragBehavior {
  constructor() {
    this._attachedToElement = false;
    this._virtualMeshesInfo = {};
    this._tmpVector = new Vector3();
    this._tmpQuaternion = new Quaternion();
    this._dragType = {
      NONE: 0,
      DRAG: 1,
      DRAG_WITH_CONTROLLER: 2,
      NEAR_DRAG: 3
    };
    this._moving = false;
    this._dragging = this._dragType.NONE;
    this.draggableMeshes = null;
    this.zDragFactor = 3;
    this.currentDraggingPointerIds = [];
    this.detachCameraControls = true;
    this.onDragStartObservable = new Observable();
    this.onDragObservable = new Observable();
    this.onDragEndObservable = new Observable();
    this.allowMultiPointer = true;
  }
  /**
   * The id of the pointer that is currently interacting with the behavior (-1 when no pointer is active)
   */
  get currentDraggingPointerId() {
    if (this.currentDraggingPointerIds[0] !== void 0) {
      return this.currentDraggingPointerIds[0];
    }
    return -1;
  }
  set currentDraggingPointerId(value) {
    this.currentDraggingPointerIds[0] = value;
  }
  /**
   * Get or set the currentDraggingPointerId
   * @deprecated Please use currentDraggingPointerId instead
   */
  get currentDraggingPointerID() {
    return this.currentDraggingPointerId;
  }
  set currentDraggingPointerID(currentDraggingPointerID) {
    this.currentDraggingPointerId = currentDraggingPointerID;
  }
  /**
   *  The name of the behavior
   */
  get name() {
    return "BaseSixDofDrag";
  }
  /**
   *  Returns true if the attached mesh is currently moving with this behavior
   */
  get isMoving() {
    return this._moving;
  }
  /**
   *  Initializes the behavior
   */
  init() {
  }
  /**
   * In the case of multiple active cameras, the cameraToUseForPointers should be used if set instead of active camera
   */
  get _pointerCamera() {
    if (this._scene.cameraToUseForPointers) {
      return this._scene.cameraToUseForPointers;
    } else {
      return this._scene.activeCamera;
    }
  }
  _createVirtualMeshInfo() {
    const dragMesh = new TransformNode("", _BaseSixDofDragBehavior._virtualScene);
    dragMesh.rotationQuaternion = new Quaternion();
    const originMesh = new TransformNode("", _BaseSixDofDragBehavior._virtualScene);
    originMesh.rotationQuaternion = new Quaternion();
    const pivotMesh = new TransformNode("", _BaseSixDofDragBehavior._virtualScene);
    pivotMesh.rotationQuaternion = new Quaternion();
    return {
      dragging: false,
      moving: false,
      dragMesh,
      originMesh,
      pivotMesh,
      startingPivotPosition: new Vector3(),
      startingPivotOrientation: new Quaternion(),
      startingPosition: new Vector3(),
      startingOrientation: new Quaternion(),
      lastOriginPosition: new Vector3(),
      lastDragPosition: new Vector3()
    };
  }
  _resetVirtualMeshesPosition() {
    for (let i = 0; i < this.currentDraggingPointerIds.length; i++) {
      this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].pivotMesh.position.copyFrom(this._ownerNode.getAbsolutePivotPoint());
      this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].pivotMesh.rotationQuaternion.copyFrom(this._ownerNode.rotationQuaternion);
      this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].startingPivotPosition.copyFrom(this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].pivotMesh.position);
      this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].startingPivotOrientation.copyFrom(this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].pivotMesh.rotationQuaternion);
      this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].startingPosition.copyFrom(this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].dragMesh.position);
      this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].startingOrientation.copyFrom(this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].dragMesh.rotationQuaternion);
    }
  }
  _pointerUpdate2D(ray, pointerId, zDragFactor) {
    if (this._pointerCamera && this._pointerCamera.cameraRigMode == Camera.RIG_MODE_NONE && !this._pointerCamera._isLeftCamera && !this._pointerCamera._isRightCamera) {
      ray.origin.copyFrom(this._pointerCamera.globalPosition);
      zDragFactor = 0;
    }
    const virtualMeshesInfo = this._virtualMeshesInfo[pointerId];
    const originDragDifference = TmpVectors.Vector3[0];
    ray.origin.subtractToRef(virtualMeshesInfo.lastOriginPosition, originDragDifference);
    virtualMeshesInfo.lastOriginPosition.copyFrom(ray.origin);
    const localOriginDragDifference = -Vector3.Dot(originDragDifference, ray.direction);
    virtualMeshesInfo.originMesh.addChild(virtualMeshesInfo.dragMesh);
    virtualMeshesInfo.originMesh.addChild(virtualMeshesInfo.pivotMesh);
    this._applyZOffset(virtualMeshesInfo.dragMesh, localOriginDragDifference, zDragFactor);
    this._applyZOffset(virtualMeshesInfo.pivotMesh, localOriginDragDifference, zDragFactor);
    virtualMeshesInfo.originMesh.position.copyFrom(ray.origin);
    const lookAt = TmpVectors.Vector3[0];
    ray.origin.addToRef(ray.direction, lookAt);
    virtualMeshesInfo.originMesh.lookAt(lookAt);
    virtualMeshesInfo.originMesh.removeChild(virtualMeshesInfo.dragMesh);
    virtualMeshesInfo.originMesh.removeChild(virtualMeshesInfo.pivotMesh);
  }
  _pointerUpdateXR(controllerAimTransform, controllerGripTransform, pointerId, zDragFactor) {
    const virtualMeshesInfo = this._virtualMeshesInfo[pointerId];
    virtualMeshesInfo.originMesh.position.copyFrom(controllerAimTransform.position);
    if (this._dragging === this._dragType.NEAR_DRAG && controllerGripTransform) {
      virtualMeshesInfo.originMesh.rotationQuaternion.copyFrom(controllerGripTransform.rotationQuaternion);
    } else {
      virtualMeshesInfo.originMesh.rotationQuaternion.copyFrom(controllerAimTransform.rotationQuaternion);
    }
    virtualMeshesInfo.pivotMesh.computeWorldMatrix(true);
    virtualMeshesInfo.dragMesh.computeWorldMatrix(true);
    if (zDragFactor !== 0) {
      const cameraForwardVec = TmpVectors.Vector3[0];
      const originDragDirection = TmpVectors.Vector3[1];
      cameraForwardVec.copyFrom(this._pointerCamera.getForwardRay().direction);
      virtualMeshesInfo.originMesh.position.subtractToRef(virtualMeshesInfo.lastOriginPosition, originDragDirection);
      virtualMeshesInfo.lastOriginPosition.copyFrom(virtualMeshesInfo.originMesh.position);
      const controllerDragDistance = originDragDirection.length();
      originDragDirection.normalize();
      const cameraToDrag = TmpVectors.Vector3[2];
      const controllerToDrag = TmpVectors.Vector3[3];
      virtualMeshesInfo.dragMesh.absolutePosition.subtractToRef(this._pointerCamera.globalPosition, cameraToDrag);
      virtualMeshesInfo.dragMesh.absolutePosition.subtractToRef(virtualMeshesInfo.originMesh.position, controllerToDrag);
      const controllerToDragDistance = controllerToDrag.length();
      cameraToDrag.normalize();
      controllerToDrag.normalize();
      const controllerDragScaling = Math.abs(Vector3.Dot(originDragDirection, controllerToDrag)) * Vector3.Dot(originDragDirection, cameraForwardVec);
      let zOffsetScaling = controllerDragScaling * zDragFactor * controllerDragDistance * controllerToDragDistance;
      const minDistanceFromControllerToDragMesh = 0.01;
      if (zOffsetScaling < 0 && minDistanceFromControllerToDragMesh - controllerToDragDistance > zOffsetScaling) {
        zOffsetScaling = Math.min(minDistanceFromControllerToDragMesh - controllerToDragDistance, 0);
      }
      controllerToDrag.scaleInPlace(zOffsetScaling);
      controllerToDrag.addToRef(virtualMeshesInfo.pivotMesh.absolutePosition, this._tmpVector);
      virtualMeshesInfo.pivotMesh.setAbsolutePosition(this._tmpVector);
      controllerToDrag.addToRef(virtualMeshesInfo.dragMesh.absolutePosition, this._tmpVector);
      virtualMeshesInfo.dragMesh.setAbsolutePosition(this._tmpVector);
    }
  }
  /**
   * Attaches the scale behavior the passed in mesh
   * @param ownerNode The mesh that will be scaled around once attached
   */
  attach(ownerNode) {
    this._ownerNode = ownerNode;
    this._scene = this._ownerNode.getScene();
    if (!_BaseSixDofDragBehavior._virtualScene) {
      _BaseSixDofDragBehavior._virtualScene = new Scene(this._scene.getEngine(), { virtual: true });
      _BaseSixDofDragBehavior._virtualScene.detachControl();
    }
    const pickPredicate = (m) => {
      return this._ownerNode === m || m.isDescendantOf(this._ownerNode) && (!this.draggableMeshes || this.draggableMeshes.indexOf(m) !== -1);
    };
    this._pointerObserver = this._scene.onPointerObservable.add((pointerInfo) => {
      const pointerId = pointerInfo.event.pointerId;
      if (!this._virtualMeshesInfo[pointerId]) {
        this._virtualMeshesInfo[pointerId] = this._createVirtualMeshInfo();
      }
      const virtualMeshesInfo = this._virtualMeshesInfo[pointerId];
      const isXRPointer = pointerInfo.event.pointerType === "xr-near" || pointerInfo.event.pointerType === "xr";
      if (pointerInfo.type == PointerEventTypes.POINTERDOWN) {
        if (!virtualMeshesInfo.dragging && pointerInfo.pickInfo && pointerInfo.pickInfo.hit && pointerInfo.pickInfo.pickedMesh && pointerInfo.pickInfo.pickedPoint && pointerInfo.pickInfo.ray && (!isXRPointer || pointerInfo.pickInfo.aimTransform) && pickPredicate(pointerInfo.pickInfo.pickedMesh)) {
          if ((!this.allowMultiPointer || isXRPointer) && this.currentDraggingPointerIds.length > 0) {
            return;
          }
          if (this._pointerCamera && this._pointerCamera.cameraRigMode === Camera.RIG_MODE_NONE && !this._pointerCamera._isLeftCamera && !this._pointerCamera._isRightCamera) {
            pointerInfo.pickInfo.ray.origin.copyFrom(this._pointerCamera.globalPosition);
          }
          this._ownerNode.computeWorldMatrix(true);
          const virtualMeshesInfo2 = this._virtualMeshesInfo[pointerId];
          if (isXRPointer) {
            this._dragging = pointerInfo.pickInfo.originMesh ? this._dragType.NEAR_DRAG : this._dragType.DRAG_WITH_CONTROLLER;
            virtualMeshesInfo2.originMesh.position.copyFrom(pointerInfo.pickInfo.aimTransform.position);
            if (this._dragging === this._dragType.NEAR_DRAG && pointerInfo.pickInfo.gripTransform) {
              virtualMeshesInfo2.originMesh.rotationQuaternion.copyFrom(pointerInfo.pickInfo.gripTransform.rotationQuaternion);
            } else {
              virtualMeshesInfo2.originMesh.rotationQuaternion.copyFrom(pointerInfo.pickInfo.aimTransform.rotationQuaternion);
            }
          } else {
            this._dragging = this._dragType.DRAG;
            virtualMeshesInfo2.originMesh.position.copyFrom(pointerInfo.pickInfo.ray.origin);
          }
          virtualMeshesInfo2.lastOriginPosition.copyFrom(virtualMeshesInfo2.originMesh.position);
          virtualMeshesInfo2.dragMesh.position.copyFrom(pointerInfo.pickInfo.pickedPoint);
          virtualMeshesInfo2.lastDragPosition.copyFrom(pointerInfo.pickInfo.pickedPoint);
          virtualMeshesInfo2.pivotMesh.position.copyFrom(this._ownerNode.getAbsolutePivotPoint());
          virtualMeshesInfo2.pivotMesh.rotationQuaternion.copyFrom(this._ownerNode.absoluteRotationQuaternion);
          virtualMeshesInfo2.startingPosition.copyFrom(virtualMeshesInfo2.dragMesh.position);
          virtualMeshesInfo2.startingPivotPosition.copyFrom(virtualMeshesInfo2.pivotMesh.position);
          virtualMeshesInfo2.startingOrientation.copyFrom(virtualMeshesInfo2.dragMesh.rotationQuaternion);
          virtualMeshesInfo2.startingPivotOrientation.copyFrom(virtualMeshesInfo2.pivotMesh.rotationQuaternion);
          if (isXRPointer) {
            virtualMeshesInfo2.originMesh.addChild(virtualMeshesInfo2.dragMesh);
            virtualMeshesInfo2.originMesh.addChild(virtualMeshesInfo2.pivotMesh);
          } else {
            virtualMeshesInfo2.originMesh.lookAt(virtualMeshesInfo2.dragMesh.position);
          }
          virtualMeshesInfo2.dragging = true;
          if (this.currentDraggingPointerIds.indexOf(pointerId) === -1) {
            this.currentDraggingPointerIds.push(pointerId);
          }
          if (this.detachCameraControls && this._pointerCamera && !this._pointerCamera.leftCamera) {
            if (this._pointerCamera.inputs && this._pointerCamera.inputs.attachedToElement) {
              this._pointerCamera.detachControl();
              this._attachedToElement = true;
            } else if (!this.allowMultiPointer || this.currentDraggingPointerIds.length === 0) {
              this._attachedToElement = false;
            }
          }
          this._targetDragStart(virtualMeshesInfo2.pivotMesh.position, virtualMeshesInfo2.pivotMesh.rotationQuaternion, pointerId);
          this.onDragStartObservable.notifyObservers({ position: virtualMeshesInfo2.pivotMesh.position });
        }
      } else if (pointerInfo.type == PointerEventTypes.POINTERUP || pointerInfo.type == PointerEventTypes.POINTERDOUBLETAP) {
        const registeredPointerIndex = this.currentDraggingPointerIds.indexOf(pointerId);
        virtualMeshesInfo.dragging = false;
        if (registeredPointerIndex !== -1) {
          this.currentDraggingPointerIds.splice(registeredPointerIndex, 1);
          if (this.currentDraggingPointerIds.length === 0) {
            this._moving = false;
            this._dragging = this._dragType.NONE;
            if (this.detachCameraControls && this._attachedToElement && this._pointerCamera && !this._pointerCamera.leftCamera) {
              this._reattachCameraControls();
              this._attachedToElement = false;
            }
          }
          virtualMeshesInfo.originMesh.removeChild(virtualMeshesInfo.dragMesh);
          virtualMeshesInfo.originMesh.removeChild(virtualMeshesInfo.pivotMesh);
          this._targetDragEnd(pointerId);
          this.onDragEndObservable.notifyObservers({});
        }
      } else if (pointerInfo.type == PointerEventTypes.POINTERMOVE) {
        const registeredPointerIndex = this.currentDraggingPointerIds.indexOf(pointerId);
        if (registeredPointerIndex !== -1 && virtualMeshesInfo.dragging && pointerInfo.pickInfo && (pointerInfo.pickInfo.ray || pointerInfo.pickInfo.aimTransform)) {
          let zDragFactor = this.zDragFactor;
          if (this.currentDraggingPointerIds.length > 1 || pointerInfo.pickInfo.originMesh) {
            zDragFactor = 0;
          }
          this._ownerNode.computeWorldMatrix(true);
          if (!isXRPointer) {
            this._pointerUpdate2D(pointerInfo.pickInfo.ray, pointerId, zDragFactor);
          } else {
            this._pointerUpdateXR(pointerInfo.pickInfo.aimTransform, pointerInfo.pickInfo.gripTransform, pointerId, zDragFactor);
          }
          this._tmpQuaternion.copyFrom(virtualMeshesInfo.startingPivotOrientation);
          this._tmpQuaternion.x = -this._tmpQuaternion.x;
          this._tmpQuaternion.y = -this._tmpQuaternion.y;
          this._tmpQuaternion.z = -this._tmpQuaternion.z;
          virtualMeshesInfo.pivotMesh.absoluteRotationQuaternion.multiplyToRef(this._tmpQuaternion, this._tmpQuaternion);
          virtualMeshesInfo.pivotMesh.absolutePosition.subtractToRef(virtualMeshesInfo.startingPivotPosition, this._tmpVector);
          this.onDragObservable.notifyObservers({ delta: this._tmpVector, position: virtualMeshesInfo.pivotMesh.position, pickInfo: pointerInfo.pickInfo });
          this._targetDrag(this._tmpVector, this._tmpQuaternion, pointerId);
          virtualMeshesInfo.lastDragPosition.copyFrom(virtualMeshesInfo.dragMesh.absolutePosition);
          this._moving = true;
        }
      }
    });
  }
  _applyZOffset(node, localOriginDragDifference, zDragFactor) {
    node.position.z -= node.position.z < 1 ? localOriginDragDifference * zDragFactor : localOriginDragDifference * zDragFactor * node.position.z;
    if (node.position.z < 0) {
      node.position.z = 0;
    }
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _targetDragStart(worldPosition, worldRotation, pointerId) {
  }
  _targetDrag(worldDeltaPosition, worldDeltaRotation, pointerId) {
  }
  _targetDragEnd(pointerId) {
  }
  _reattachCameraControls() {
    if (this._pointerCamera) {
      if (this._pointerCamera.getClassName() === "ArcRotateCamera") {
        const arcRotateCamera = this._pointerCamera;
        arcRotateCamera.attachControl(arcRotateCamera.inputs ? arcRotateCamera.inputs.noPreventDefault : true, arcRotateCamera._useCtrlForPanning, arcRotateCamera._panningMouseButton);
      } else {
        this._pointerCamera.attachControl(this._pointerCamera.inputs ? this._pointerCamera.inputs.noPreventDefault : true);
      }
    }
  }
  /**
   * Detaches the behavior from the mesh
   */
  detach() {
    if (this._scene) {
      if (this.detachCameraControls && this._attachedToElement && this._pointerCamera && !this._pointerCamera.leftCamera) {
        this._reattachCameraControls();
        this._attachedToElement = false;
      }
      this._scene.onPointerObservable.remove(this._pointerObserver);
    }
    for (const pointerId in this._virtualMeshesInfo) {
      this._virtualMeshesInfo[pointerId].originMesh.dispose();
      this._virtualMeshesInfo[pointerId].dragMesh.dispose();
    }
    this.onDragEndObservable.clear();
    this.onDragObservable.clear();
    this.onDragStartObservable.clear();
  }
};

// node_modules/@babylonjs/core/Behaviors/Meshes/sixDofDragBehavior.js
var SixDofDragBehavior = class extends BaseSixDofDragBehavior {
  constructor() {
    super(...arguments);
    this._sceneRenderObserver = null;
    this._targetPosition = new Vector3(0, 0, 0);
    this._targetOrientation = new Quaternion();
    this._targetScaling = new Vector3(1, 1, 1);
    this._startingPosition = new Vector3(0, 0, 0);
    this._startingOrientation = new Quaternion();
    this._startingScaling = new Vector3(1, 1, 1);
    this.onPositionChangedObservable = new Observable();
    this.dragDeltaRatio = 0.2;
    this.rotateDraggedObject = true;
    this.rotateAroundYOnly = false;
    this.rotateWithMotionController = true;
    this.disableMovement = false;
    this.faceCameraOnDragStart = false;
  }
  /**
   *  The name of the behavior
   */
  get name() {
    return "SixDofDrag";
  }
  /**
   * Attaches the six DoF drag behavior
   * In XR mode the mesh and its children will have their isNearGrabbable property set to true
   * @param ownerNode The mesh that will be dragged around once attached
   */
  attach(ownerNode) {
    super.attach(ownerNode);
    ownerNode.isNearGrabbable = true;
    ownerNode.getChildMeshes().forEach((m) => {
      m.isNearGrabbable = true;
    });
    this._virtualTransformNode = new TransformNode("virtual_sixDof", BaseSixDofDragBehavior._virtualScene);
    this._virtualTransformNode.rotationQuaternion = Quaternion.Identity();
    this._sceneRenderObserver = ownerNode.getScene().onBeforeRenderObservable.add(() => {
      if (this.currentDraggingPointerIds.length === 1 && this._moving && !this.disableMovement) {
        const deltaToAdd = TmpVectors.Vector3[0];
        deltaToAdd.copyFrom(this._targetPosition).subtractInPlace(ownerNode.absolutePosition).scaleInPlace(this.dragDeltaRatio);
        const deltaToAddTransformed = TmpVectors.Vector3[1];
        deltaToAddTransformed.copyFrom(deltaToAdd);
        if (ownerNode.parent) {
          const parentRotationMatrixInverse = TmpVectors.Matrix[0];
          ownerNode.parent.absoluteRotationQuaternion.toRotationMatrix(parentRotationMatrixInverse);
          parentRotationMatrixInverse.invert();
          Vector3.TransformNormalToRef(deltaToAdd, parentRotationMatrixInverse, deltaToAddTransformed);
        }
        ownerNode.position.addInPlace(deltaToAddTransformed);
        this.onPositionChangedObservable.notifyObservers({ position: ownerNode.absolutePosition });
        if (!ownerNode.parent || ownerNode.parent.scaling && !ownerNode.parent.scaling.isNonUniformWithinEpsilon(1e-3)) {
          const rotationToApply = TmpVectors.Quaternion[0];
          rotationToApply.copyFrom(this._targetOrientation);
          if (ownerNode.parent) {
            const parentRotationInverse = TmpVectors.Quaternion[0];
            parentRotationInverse.copyFrom(ownerNode.parent.absoluteRotationQuaternion);
            parentRotationInverse.invertInPlace();
            parentRotationInverse.multiplyToRef(this._targetOrientation, rotationToApply);
          }
          Quaternion.SlerpToRef(ownerNode.rotationQuaternion, rotationToApply, this.dragDeltaRatio, ownerNode.rotationQuaternion);
        }
      }
    });
  }
  _getPositionOffsetAround(transformationLocalOrigin, scaling, rotation) {
    const translationMatrix = TmpVectors.Matrix[0];
    const translationMatrixInv = TmpVectors.Matrix[1];
    const rotationMatrix = TmpVectors.Matrix[2];
    const scaleMatrix = TmpVectors.Matrix[3];
    const finalMatrix = TmpVectors.Matrix[4];
    Matrix.TranslationToRef(transformationLocalOrigin.x, transformationLocalOrigin.y, transformationLocalOrigin.z, translationMatrix);
    Matrix.TranslationToRef(-transformationLocalOrigin.x, -transformationLocalOrigin.y, -transformationLocalOrigin.z, translationMatrixInv);
    Matrix.FromQuaternionToRef(rotation, rotationMatrix);
    Matrix.ScalingToRef(scaling, scaling, scaling, scaleMatrix);
    translationMatrixInv.multiplyToRef(rotationMatrix, finalMatrix);
    finalMatrix.multiplyToRef(scaleMatrix, finalMatrix);
    finalMatrix.multiplyToRef(translationMatrix, finalMatrix);
    return finalMatrix.getTranslation();
  }
  _onePointerPositionUpdated(worldDeltaPosition, worldDeltaRotation) {
    const pointerDelta = TmpVectors.Vector3[0];
    pointerDelta.setAll(0);
    if (this._dragging === this._dragType.DRAG) {
      if (this.rotateDraggedObject) {
        if (this.rotateAroundYOnly) {
          Quaternion.RotationYawPitchRollToRef(worldDeltaRotation.toEulerAngles().y, 0, 0, TmpVectors.Quaternion[0]);
        } else {
          TmpVectors.Quaternion[0].copyFrom(worldDeltaRotation);
        }
        TmpVectors.Quaternion[0].multiplyToRef(this._startingOrientation, this._targetOrientation);
      }
    } else if (this._dragging === this._dragType.NEAR_DRAG || this._dragging === this._dragType.DRAG_WITH_CONTROLLER && this.rotateWithMotionController) {
      worldDeltaRotation.multiplyToRef(this._startingOrientation, this._targetOrientation);
    }
    this._targetPosition.copyFrom(this._startingPosition).addInPlace(worldDeltaPosition);
  }
  _twoPointersPositionUpdated() {
    const startingPosition0 = this._virtualMeshesInfo[this.currentDraggingPointerIds[0]].startingPosition;
    const startingPosition1 = this._virtualMeshesInfo[this.currentDraggingPointerIds[1]].startingPosition;
    const startingCenter = TmpVectors.Vector3[0];
    startingPosition0.addToRef(startingPosition1, startingCenter);
    startingCenter.scaleInPlace(0.5);
    const startingVector = TmpVectors.Vector3[1];
    startingPosition1.subtractToRef(startingPosition0, startingVector);
    const currentPosition0 = this._virtualMeshesInfo[this.currentDraggingPointerIds[0]].dragMesh.absolutePosition;
    const currentPosition1 = this._virtualMeshesInfo[this.currentDraggingPointerIds[1]].dragMesh.absolutePosition;
    const currentCenter = TmpVectors.Vector3[2];
    currentPosition0.addToRef(currentPosition1, currentCenter);
    currentCenter.scaleInPlace(0.5);
    const currentVector = TmpVectors.Vector3[3];
    currentPosition1.subtractToRef(currentPosition0, currentVector);
    const scaling = currentVector.length() / startingVector.length();
    const translation = currentCenter.subtract(startingCenter);
    const rotationQuaternion = Quaternion.FromEulerAngles(0, Vector3.GetAngleBetweenVectorsOnPlane(startingVector.normalize(), currentVector.normalize(), Vector3.UpReadOnly), 0);
    const oldParent = this._ownerNode.parent;
    this._ownerNode.setParent(null);
    const positionOffset = this._getPositionOffsetAround(startingCenter.subtract(this._virtualTransformNode.getAbsolutePivotPoint()), scaling, rotationQuaternion);
    this._virtualTransformNode.rotationQuaternion.multiplyToRef(rotationQuaternion, this._ownerNode.rotationQuaternion);
    this._virtualTransformNode.scaling.scaleToRef(scaling, this._ownerNode.scaling);
    this._virtualTransformNode.position.addToRef(translation.addInPlace(positionOffset), this._ownerNode.position);
    this.onPositionChangedObservable.notifyObservers({ position: this._ownerNode.position });
    this._ownerNode.setParent(oldParent);
  }
  _targetDragStart() {
    const pointerCount = this.currentDraggingPointerIds.length;
    if (!this._ownerNode.rotationQuaternion) {
      this._ownerNode.rotationQuaternion = Quaternion.RotationYawPitchRoll(this._ownerNode.rotation.y, this._ownerNode.rotation.x, this._ownerNode.rotation.z);
    }
    const worldPivot = this._ownerNode.getAbsolutePivotPoint();
    if (pointerCount === 1) {
      this._targetPosition.copyFrom(this._ownerNode.absolutePosition);
      this._targetOrientation.copyFrom(this._ownerNode.rotationQuaternion);
      this._targetScaling.copyFrom(this._ownerNode.absoluteScaling);
      if (this.faceCameraOnDragStart && this._scene.activeCamera) {
        const toCamera = TmpVectors.Vector3[0];
        this._scene.activeCamera.position.subtractToRef(worldPivot, toCamera);
        toCamera.normalize();
        const quat = TmpVectors.Quaternion[0];
        if (this._scene.useRightHandedSystem) {
          Quaternion.FromLookDirectionRHToRef(toCamera, new Vector3(0, 1, 0), quat);
        } else {
          Quaternion.FromLookDirectionLHToRef(toCamera, new Vector3(0, 1, 0), quat);
        }
        quat.normalize();
        Quaternion.RotationYawPitchRollToRef(quat.toEulerAngles().y, 0, 0, TmpVectors.Quaternion[0]);
        this._targetOrientation.copyFrom(TmpVectors.Quaternion[0]);
      }
      this._startingPosition.copyFrom(this._targetPosition);
      this._startingOrientation.copyFrom(this._targetOrientation);
      this._startingScaling.copyFrom(this._targetScaling);
    } else if (pointerCount === 2) {
      this._virtualTransformNode.setPivotPoint(
        new Vector3(0, 0, 0),
        0
        /* Space.LOCAL */
      );
      this._virtualTransformNode.position.copyFrom(this._ownerNode.absolutePosition);
      this._virtualTransformNode.scaling.copyFrom(this._ownerNode.absoluteScaling);
      this._virtualTransformNode.rotationQuaternion.copyFrom(this._ownerNode.absoluteRotationQuaternion);
      this._virtualTransformNode.setPivotPoint(
        worldPivot,
        1
        /* Space.WORLD */
      );
      this._resetVirtualMeshesPosition();
    }
  }
  _targetDrag(worldDeltaPosition, worldDeltaRotation) {
    if (this.currentDraggingPointerIds.length === 1) {
      this._onePointerPositionUpdated(worldDeltaPosition, worldDeltaRotation);
    } else if (this.currentDraggingPointerIds.length === 2) {
      this._twoPointersPositionUpdated();
    }
  }
  _targetDragEnd() {
    if (this.currentDraggingPointerIds.length === 1) {
      this._resetVirtualMeshesPosition();
      const previousFaceCameraFlag = this.faceCameraOnDragStart;
      this.faceCameraOnDragStart = false;
      this._targetDragStart();
      this.faceCameraOnDragStart = previousFaceCameraFlag;
    }
  }
  /**
   *  Detaches the behavior from the mesh
   */
  detach() {
    super.detach();
    if (this._ownerNode) {
      this._ownerNode.getScene().onBeforeRenderObservable.remove(this._sceneRenderObserver);
    }
    if (this._virtualTransformNode) {
      this._virtualTransformNode.dispose();
    }
  }
};

// node_modules/@babylonjs/core/Behaviors/Meshes/surfaceMagnetismBehavior.js
var SurfaceMagnetismBehavior = class {
  constructor() {
    this._attachPointLocalOffset = new Vector3();
    this._workingPosition = new Vector3();
    this._workingQuaternion = new Quaternion();
    this._lastTick = -1;
    this._hit = false;
    this.hitNormalOffset = 0.05;
    this.meshes = [];
    this.interpolatePose = true;
    this.lerpTime = 250;
    this.keepOrientationVertical = true;
    this.enabled = true;
    this.maxStickingDistance = 0.8;
  }
  /**
   * Name of the behavior
   */
  get name() {
    return "SurfaceMagnetism";
  }
  /**
   * Function called when the behavior needs to be initialized (after attaching it to a target)
   */
  init() {
  }
  /**
   * Attaches the behavior to a transform node
   * @param target defines the target where the behavior is attached to
   * @param scene the scene
   */
  attach(target, scene) {
    this._attachedMesh = target;
    this._scene = scene || target.getScene();
    if (!this._attachedMesh.rotationQuaternion) {
      this._attachedMesh.rotationQuaternion = Quaternion.RotationYawPitchRoll(this._attachedMesh.rotation.y, this._attachedMesh.rotation.x, this._attachedMesh.rotation.z);
    }
    this.updateAttachPoint();
    this._workingPosition.copyFrom(this._attachedMesh.position);
    this._workingQuaternion.copyFrom(this._attachedMesh.rotationQuaternion);
    this._addObservables();
  }
  /**
   * Detaches the behavior
   */
  detach() {
    this._attachedMesh = null;
    this._removeObservables();
  }
  _getTargetPose(pickingInfo) {
    if (!this._attachedMesh) {
      return null;
    }
    if (pickingInfo && pickingInfo.hit) {
      const pickedNormal = pickingInfo.getNormal(true, true);
      const pickedPoint = pickingInfo.pickedPoint;
      if (!pickedNormal || !pickedPoint) {
        return null;
      }
      pickedNormal.normalize();
      const worldTarget = TmpVectors.Vector3[0];
      worldTarget.copyFrom(pickedNormal);
      worldTarget.scaleInPlace(this.hitNormalOffset);
      worldTarget.addInPlace(pickedPoint);
      if (this._attachedMesh.parent) {
        TmpVectors.Matrix[0].copyFrom(this._attachedMesh.parent.getWorldMatrix()).invert();
        Vector3.TransformNormalToRef(worldTarget, TmpVectors.Matrix[0], worldTarget);
      }
      return {
        position: worldTarget,
        quaternion: Quaternion.RotationYawPitchRoll(-Math.atan2(pickedNormal.x, -pickedNormal.z), this.keepOrientationVertical ? 0 : Math.atan2(pickedNormal.y, Math.sqrt(pickedNormal.z * pickedNormal.z + pickedNormal.x * pickedNormal.x)), 0)
      };
    }
    return null;
  }
  /**
   * Updates the attach point with the current geometry extents of the attached mesh
   */
  updateAttachPoint() {
    this._getAttachPointOffsetToRef(this._attachPointLocalOffset);
  }
  /**
   * Finds the intersection point of the given ray onto the meshes and updates the target.
   * Transformation will be interpolated according to `interpolatePose` and `lerpTime` properties.
   * If no mesh of `meshes` are hit, this does nothing.
   * @param pickInfo The input pickingInfo that will be used to intersect the meshes
   * @returns a boolean indicating if we found a hit to stick to
   */
  findAndUpdateTarget(pickInfo) {
    this._hit = false;
    if (!pickInfo.ray) {
      return false;
    }
    const subPicking = pickInfo.ray.intersectsMeshes(this.meshes)[0];
    if (this._attachedMesh && subPicking && subPicking.hit && subPicking.pickedMesh) {
      const pose = this._getTargetPose(subPicking);
      if (pose && Vector3.Distance(this._attachedMesh.position, pose.position) < this.maxStickingDistance) {
        this._workingPosition.copyFrom(pose.position);
        this._workingQuaternion.copyFrom(pose.quaternion);
        this._hit = true;
      }
    }
    return this._hit;
  }
  _getAttachPointOffsetToRef(ref) {
    if (!this._attachedMesh) {
      ref.setAll(0);
      return;
    }
    const storedQuat = TmpVectors.Quaternion[0];
    storedQuat.copyFrom(this._attachedMesh.rotationQuaternion);
    this._attachedMesh.rotationQuaternion.copyFromFloats(0, 0, 0, 1);
    this._attachedMesh.computeWorldMatrix();
    const boundingMinMax = this._attachedMesh.getHierarchyBoundingVectors();
    const center = TmpVectors.Vector3[0];
    boundingMinMax.max.addToRef(boundingMinMax.min, center);
    center.scaleInPlace(0.5);
    center.z = boundingMinMax.max.z;
    const invWorld = TmpVectors.Matrix[0];
    this._attachedMesh.getWorldMatrix().invertToRef(invWorld);
    Vector3.TransformCoordinatesToRef(center, invWorld, ref);
    this._attachedMesh.rotationQuaternion.copyFrom(storedQuat);
  }
  _updateTransformToGoal(elapsed) {
    if (!this._attachedMesh || !this._hit) {
      return;
    }
    const oldParent = this._attachedMesh.parent;
    this._attachedMesh.setParent(null);
    const worldOffset = TmpVectors.Vector3[0];
    Vector3.TransformNormalToRef(this._attachPointLocalOffset, this._attachedMesh.getWorldMatrix(), worldOffset);
    if (!this.interpolatePose) {
      this._attachedMesh.position.copyFrom(this._workingPosition).subtractInPlace(worldOffset);
      this._attachedMesh.rotationQuaternion.copyFrom(this._workingQuaternion);
      return;
    }
    const interpolatedPosition = new Vector3();
    Vector3.SmoothToRef(this._attachedMesh.position, this._workingPosition, elapsed, this.lerpTime, interpolatedPosition);
    this._attachedMesh.position.copyFrom(interpolatedPosition);
    const currentRotation = new Quaternion();
    currentRotation.copyFrom(this._attachedMesh.rotationQuaternion);
    Quaternion.SmoothToRef(currentRotation, this._workingQuaternion, elapsed, this.lerpTime, this._attachedMesh.rotationQuaternion);
    this._attachedMesh.setParent(oldParent);
  }
  _addObservables() {
    this._pointerObserver = this._scene.onPointerObservable.add((pointerInfo) => {
      if (this.enabled && pointerInfo.type == PointerEventTypes.POINTERMOVE && pointerInfo.pickInfo) {
        this.findAndUpdateTarget(pointerInfo.pickInfo);
      }
    });
    this._lastTick = Date.now();
    this._onBeforeRender = this._scene.onBeforeRenderObservable.add(() => {
      const tick = Date.now();
      this._updateTransformToGoal(tick - this._lastTick);
      this._lastTick = tick;
    });
  }
  _removeObservables() {
    this._scene.onPointerObservable.remove(this._pointerObserver);
    this._scene.onBeforeRenderObservable.remove(this._onBeforeRender);
    this._pointerObserver = null;
    this._onBeforeRender = null;
  }
};

// node_modules/@babylonjs/gui/3D/behaviors/defaultBehavior.js
var DefaultBehavior = class {
  /**
   * Instantiates the default behavior
   */
  constructor() {
    this.followBehaviorEnabled = false;
    this.sixDofDragBehaviorEnabled = true;
    this.surfaceMagnetismBehaviorEnabled = true;
    this._followBehavior = new FollowBehavior();
    this._sixDofDragBehavior = new SixDofDragBehavior();
    this._surfaceMagnetismBehavior = new SurfaceMagnetismBehavior();
  }
  /**
   *  The name of the behavior
   */
  get name() {
    return "Default";
  }
  /**
   *  The follow behavior
   */
  get followBehavior() {
    return this._followBehavior;
  }
  /**
   *  The six DoF drag behavior
   */
  get sixDofDragBehavior() {
    return this._sixDofDragBehavior;
  }
  /**
   * The surface magnetism behavior
   */
  get surfaceMagnetismBehavior() {
    return this._surfaceMagnetismBehavior;
  }
  /**
   *  Initializes the behavior
   */
  init() {
  }
  /**
   * Attaches the default behavior
   * @param ownerMesh The top level mesh
   * @param draggablesMeshes Descendant meshes that can be used for dragging the owner mesh
   * @param sceneUnderstandingMeshes Meshes from the scene understanding that will be used for surface magnetism
   */
  attach(ownerMesh, draggablesMeshes, sceneUnderstandingMeshes) {
    this._scene = ownerMesh.getScene();
    this.attachedNode = ownerMesh;
    this._addObservables();
    this._followBehavior.attach(ownerMesh);
    this._sixDofDragBehavior.attach(ownerMesh);
    this._sixDofDragBehavior.draggableMeshes = draggablesMeshes || null;
    this._sixDofDragBehavior.faceCameraOnDragStart = true;
    this._surfaceMagnetismBehavior.attach(ownerMesh, this._scene);
    if (sceneUnderstandingMeshes) {
      this._surfaceMagnetismBehavior.meshes = sceneUnderstandingMeshes;
    }
    this._surfaceMagnetismBehavior.enabled = false;
  }
  /**
   *  Detaches the behavior from the mesh
   */
  detach() {
    this.attachedNode = null;
    this._removeObservables();
    this._followBehavior.detach();
    this._sixDofDragBehavior.detach();
    this._surfaceMagnetismBehavior.detach();
  }
  _addObservables() {
    this._onBeforeRenderObserver = this._scene.onBeforeRenderObservable.add(() => {
      this._followBehavior._enabled = !this._sixDofDragBehavior.isMoving && this.followBehaviorEnabled;
    });
    this._onDragObserver = this._sixDofDragBehavior.onDragObservable.add((event) => {
      this._sixDofDragBehavior.disableMovement = this._surfaceMagnetismBehavior.findAndUpdateTarget(event.pickInfo);
    });
  }
  _removeObservables() {
    this._scene.onBeforeRenderObservable.remove(this._onBeforeRenderObserver);
    this._sixDofDragBehavior.onDragObservable.remove(this._onDragObserver);
  }
};

// node_modules/@babylonjs/core/Rendering/utilityLayerRenderer.js
var UtilityLayerRenderer = class _UtilityLayerRenderer {
  /**
   * Gets the camera that is used to render the utility layer (when not set, this will be the last active camera)
   * @param getRigParentIfPossible if the current active camera is a rig camera, should its parent camera be returned
   * @returns the camera that is used when rendering the utility layer
   */
  getRenderCamera(getRigParentIfPossible) {
    if (this._renderCamera) {
      return this._renderCamera;
    } else {
      let activeCam;
      if (this.originalScene.activeCameras && this.originalScene.activeCameras.length > 1) {
        activeCam = this.originalScene.activeCameras[this.originalScene.activeCameras.length - 1];
      } else {
        activeCam = this.originalScene.activeCamera;
      }
      if (getRigParentIfPossible && activeCam && activeCam.isRigCamera) {
        return activeCam.rigParent;
      }
      return activeCam;
    }
  }
  /**
   * Sets the camera that should be used when rendering the utility layer (If set to null the last active camera will be used)
   * @param cam the camera that should be used when rendering the utility layer
   */
  setRenderCamera(cam) {
    this._renderCamera = cam;
  }
  /**
   * @internal
   * Light which used by gizmos to get light shading
   */
  _getSharedGizmoLight() {
    if (!this._sharedGizmoLight) {
      this._sharedGizmoLight = new HemisphericLight("shared gizmo light", new Vector3(0, 1, 0), this.utilityLayerScene);
      this._sharedGizmoLight.intensity = 2;
      this._sharedGizmoLight.groundColor = Color3.Gray();
    }
    return this._sharedGizmoLight;
  }
  /**
   * A shared utility layer that can be used to overlay objects into a scene (Depth map of the previous scene is cleared before drawing on top of it)
   */
  static get DefaultUtilityLayer() {
    if (_UtilityLayerRenderer._DefaultUtilityLayer == null) {
      return _UtilityLayerRenderer._CreateDefaultUtilityLayerFromScene(EngineStore.LastCreatedScene);
    }
    return _UtilityLayerRenderer._DefaultUtilityLayer;
  }
  /**
   * Creates an utility layer, and set it as a default utility layer
   * @param scene associated scene
   * @internal
   */
  static _CreateDefaultUtilityLayerFromScene(scene) {
    _UtilityLayerRenderer._DefaultUtilityLayer = new _UtilityLayerRenderer(scene);
    _UtilityLayerRenderer._DefaultUtilityLayer.originalScene.onDisposeObservable.addOnce(() => {
      _UtilityLayerRenderer._DefaultUtilityLayer = null;
    });
    return _UtilityLayerRenderer._DefaultUtilityLayer;
  }
  /**
   * A shared utility layer that can be used to embed objects into a scene (Depth map of the previous scene is not cleared before drawing on top of it)
   */
  static get DefaultKeepDepthUtilityLayer() {
    if (_UtilityLayerRenderer._DefaultKeepDepthUtilityLayer == null) {
      _UtilityLayerRenderer._DefaultKeepDepthUtilityLayer = new _UtilityLayerRenderer(EngineStore.LastCreatedScene);
      _UtilityLayerRenderer._DefaultKeepDepthUtilityLayer.utilityLayerScene.autoClearDepthAndStencil = false;
      _UtilityLayerRenderer._DefaultKeepDepthUtilityLayer.originalScene.onDisposeObservable.addOnce(() => {
        _UtilityLayerRenderer._DefaultKeepDepthUtilityLayer = null;
      });
    }
    return _UtilityLayerRenderer._DefaultKeepDepthUtilityLayer;
  }
  /**
   * Instantiates a UtilityLayerRenderer
   * @param originalScene the original scene that will be rendered on top of
   * @param handleEvents boolean indicating if the utility layer should handle events
   */
  constructor(originalScene, handleEvents = true) {
    this.originalScene = originalScene;
    this._pointerCaptures = {};
    this._lastPointerEvents = {};
    this._sharedGizmoLight = null;
    this._renderCamera = null;
    this.pickUtilitySceneFirst = true;
    this.shouldRender = true;
    this.onlyCheckPointerDownEvents = true;
    this.processAllEvents = false;
    this.pickingEnabled = true;
    this.onPointerOutObservable = new Observable();
    this.utilityLayerScene = new Scene(originalScene.getEngine(), { virtual: true });
    this.utilityLayerScene.useRightHandedSystem = originalScene.useRightHandedSystem;
    this.utilityLayerScene._allowPostProcessClearColor = false;
    this.utilityLayerScene.postProcessesEnabled = false;
    this.utilityLayerScene.detachControl();
    if (handleEvents) {
      this._originalPointerObserver = originalScene.onPrePointerObservable.add((prePointerInfo) => {
        if (!this.utilityLayerScene.activeCamera) {
          return;
        }
        if (!this.pickingEnabled) {
          return;
        }
        if (!this.processAllEvents) {
          if (prePointerInfo.type !== PointerEventTypes.POINTERMOVE && prePointerInfo.type !== PointerEventTypes.POINTERUP && prePointerInfo.type !== PointerEventTypes.POINTERDOWN && prePointerInfo.type !== PointerEventTypes.POINTERDOUBLETAP) {
            return;
          }
        }
        this.utilityLayerScene.pointerX = originalScene.pointerX;
        this.utilityLayerScene.pointerY = originalScene.pointerY;
        const pointerEvent = prePointerInfo.event;
        if (originalScene.isPointerCaptured(pointerEvent.pointerId)) {
          this._pointerCaptures[pointerEvent.pointerId] = false;
          return;
        }
        const getNearPickDataForScene = (scene) => {
          let scenePick = null;
          if (prePointerInfo.nearInteractionPickingInfo) {
            if (prePointerInfo.nearInteractionPickingInfo.pickedMesh.getScene() == scene) {
              scenePick = prePointerInfo.nearInteractionPickingInfo;
            } else {
              scenePick = new PickingInfo();
            }
          } else if (scene !== this.utilityLayerScene && prePointerInfo.originalPickingInfo) {
            scenePick = prePointerInfo.originalPickingInfo;
          } else {
            let previousActiveCamera = null;
            if (this._renderCamera) {
              previousActiveCamera = scene._activeCamera;
              scene._activeCamera = this._renderCamera;
              prePointerInfo.ray = null;
            }
            scenePick = prePointerInfo.ray ? scene.pickWithRay(prePointerInfo.ray) : scene.pick(originalScene.pointerX, originalScene.pointerY);
            if (previousActiveCamera) {
              scene._activeCamera = previousActiveCamera;
            }
          }
          return scenePick;
        };
        const utilityScenePick = getNearPickDataForScene(this.utilityLayerScene);
        if (!prePointerInfo.ray && utilityScenePick) {
          prePointerInfo.ray = utilityScenePick.ray;
        }
        this.utilityLayerScene.onPrePointerObservable.notifyObservers(prePointerInfo);
        if (this.onlyCheckPointerDownEvents && prePointerInfo.type != PointerEventTypes.POINTERDOWN) {
          if (!prePointerInfo.skipOnPointerObservable) {
            this.utilityLayerScene.onPointerObservable.notifyObservers(new PointerInfo(prePointerInfo.type, prePointerInfo.event, utilityScenePick), prePointerInfo.type);
          }
          if (prePointerInfo.type === PointerEventTypes.POINTERUP && this._pointerCaptures[pointerEvent.pointerId]) {
            this._pointerCaptures[pointerEvent.pointerId] = false;
          }
          return;
        }
        if (this.utilityLayerScene.autoClearDepthAndStencil || this.pickUtilitySceneFirst) {
          if (utilityScenePick && utilityScenePick.hit) {
            if (!prePointerInfo.skipOnPointerObservable) {
              this.utilityLayerScene.onPointerObservable.notifyObservers(new PointerInfo(prePointerInfo.type, prePointerInfo.event, utilityScenePick), prePointerInfo.type);
            }
            prePointerInfo.skipOnPointerObservable = true;
          }
        } else {
          const originalScenePick = getNearPickDataForScene(originalScene);
          const pointerEvent2 = prePointerInfo.event;
          if (originalScenePick && utilityScenePick) {
            if (utilityScenePick.distance === 0 && originalScenePick.pickedMesh) {
              if (this.mainSceneTrackerPredicate && this.mainSceneTrackerPredicate(originalScenePick.pickedMesh)) {
                this._notifyObservers(prePointerInfo, originalScenePick, pointerEvent2);
                prePointerInfo.skipOnPointerObservable = true;
              } else if (prePointerInfo.type === PointerEventTypes.POINTERDOWN) {
                this._pointerCaptures[pointerEvent2.pointerId] = true;
              } else if (prePointerInfo.type === PointerEventTypes.POINTERMOVE || prePointerInfo.type === PointerEventTypes.POINTERUP) {
                if (this._lastPointerEvents[pointerEvent2.pointerId]) {
                  this.onPointerOutObservable.notifyObservers(pointerEvent2.pointerId);
                  delete this._lastPointerEvents[pointerEvent2.pointerId];
                }
                this._notifyObservers(prePointerInfo, originalScenePick, pointerEvent2);
              }
            } else if (!this._pointerCaptures[pointerEvent2.pointerId] && (utilityScenePick.distance < originalScenePick.distance || originalScenePick.distance === 0)) {
              this._notifyObservers(prePointerInfo, utilityScenePick, pointerEvent2);
              if (!prePointerInfo.skipOnPointerObservable) {
                prePointerInfo.skipOnPointerObservable = utilityScenePick.distance > 0;
              }
            } else if (!this._pointerCaptures[pointerEvent2.pointerId] && utilityScenePick.distance >= originalScenePick.distance) {
              if (this.mainSceneTrackerPredicate && this.mainSceneTrackerPredicate(originalScenePick.pickedMesh)) {
                this._notifyObservers(prePointerInfo, originalScenePick, pointerEvent2);
                prePointerInfo.skipOnPointerObservable = true;
              } else {
                if (prePointerInfo.type === PointerEventTypes.POINTERMOVE || prePointerInfo.type === PointerEventTypes.POINTERUP) {
                  if (this._lastPointerEvents[pointerEvent2.pointerId]) {
                    this.onPointerOutObservable.notifyObservers(pointerEvent2.pointerId);
                    delete this._lastPointerEvents[pointerEvent2.pointerId];
                  }
                }
                this._notifyObservers(prePointerInfo, utilityScenePick, pointerEvent2);
              }
            }
            if (prePointerInfo.type === PointerEventTypes.POINTERUP && this._pointerCaptures[pointerEvent2.pointerId]) {
              this._pointerCaptures[pointerEvent2.pointerId] = false;
            }
          }
        }
      });
      if (this._originalPointerObserver) {
        originalScene.onPrePointerObservable.makeObserverTopPriority(this._originalPointerObserver);
      }
    }
    this.utilityLayerScene.autoClear = false;
    this._afterRenderObserver = this.originalScene.onAfterRenderCameraObservable.add((camera) => {
      if (this.shouldRender && camera == this.getRenderCamera()) {
        this.render();
      }
    });
    this._sceneDisposeObserver = this.originalScene.onDisposeObservable.add(() => {
      this.dispose();
    });
    this._updateCamera();
  }
  _notifyObservers(prePointerInfo, pickInfo, pointerEvent) {
    if (!prePointerInfo.skipOnPointerObservable) {
      this.utilityLayerScene.onPointerObservable.notifyObservers(new PointerInfo(prePointerInfo.type, prePointerInfo.event, pickInfo), prePointerInfo.type);
      this._lastPointerEvents[pointerEvent.pointerId] = true;
    }
  }
  /**
   * Renders the utility layers scene on top of the original scene
   */
  render() {
    this._updateCamera();
    if (this.utilityLayerScene.activeCamera) {
      const oldScene = this.utilityLayerScene.activeCamera.getScene();
      const camera = this.utilityLayerScene.activeCamera;
      camera._scene = this.utilityLayerScene;
      if (camera.leftCamera) {
        camera.leftCamera._scene = this.utilityLayerScene;
      }
      if (camera.rightCamera) {
        camera.rightCamera._scene = this.utilityLayerScene;
      }
      this.utilityLayerScene.render(false);
      camera._scene = oldScene;
      if (camera.leftCamera) {
        camera.leftCamera._scene = oldScene;
      }
      if (camera.rightCamera) {
        camera.rightCamera._scene = oldScene;
      }
    }
  }
  /**
   * Disposes of the renderer
   */
  dispose() {
    this.onPointerOutObservable.clear();
    if (this._afterRenderObserver) {
      this.originalScene.onAfterCameraRenderObservable.remove(this._afterRenderObserver);
    }
    if (this._sceneDisposeObserver) {
      this.originalScene.onDisposeObservable.remove(this._sceneDisposeObserver);
    }
    if (this._originalPointerObserver) {
      this.originalScene.onPrePointerObservable.remove(this._originalPointerObserver);
    }
    this.utilityLayerScene.dispose();
  }
  _updateCamera() {
    this.utilityLayerScene.cameraToUseForPointers = this.getRenderCamera();
    this.utilityLayerScene.activeCamera = this.getRenderCamera();
  }
};
UtilityLayerRenderer._DefaultUtilityLayer = null;
UtilityLayerRenderer._DefaultKeepDepthUtilityLayer = null;

// node_modules/@babylonjs/core/Gizmos/gizmo.js
var GizmoAnchorPoint;
(function(GizmoAnchorPoint2) {
  GizmoAnchorPoint2[GizmoAnchorPoint2["Origin"] = 0] = "Origin";
  GizmoAnchorPoint2[GizmoAnchorPoint2["Pivot"] = 1] = "Pivot";
})(GizmoAnchorPoint || (GizmoAnchorPoint = {}));
var GizmoCoordinatesMode;
(function(GizmoCoordinatesMode2) {
  GizmoCoordinatesMode2[GizmoCoordinatesMode2["World"] = 0] = "World";
  GizmoCoordinatesMode2[GizmoCoordinatesMode2["Local"] = 1] = "Local";
})(GizmoCoordinatesMode || (GizmoCoordinatesMode = {}));
var Gizmo = class _Gizmo {
  /**
   * Ratio for the scale of the gizmo (Default: 1)
   */
  set scaleRatio(value) {
    this._scaleRatio = value;
  }
  get scaleRatio() {
    return this._scaleRatio;
  }
  /**
   * True when the mouse pointer is hovered a gizmo mesh
   */
  get isHovered() {
    return this._isHovered;
  }
  /**
   * Mesh that the gizmo will be attached to. (eg. on a drag gizmo the mesh that will be dragged)
   * * When set, interactions will be enabled
   */
  get attachedMesh() {
    return this._attachedMesh;
  }
  set attachedMesh(value) {
    this._attachedMesh = value;
    if (value) {
      this._attachedNode = value;
    }
    this._rootMesh.setEnabled(value ? true : false);
    this._attachedNodeChanged(value);
  }
  /**
   * Node that the gizmo will be attached to. (eg. on a drag gizmo the mesh, bone or NodeTransform that will be dragged)
   * * When set, interactions will be enabled
   */
  get attachedNode() {
    return this._attachedNode;
  }
  set attachedNode(value) {
    this._attachedNode = value;
    this._attachedMesh = null;
    this._rootMesh.setEnabled(value ? true : false);
    this._attachedNodeChanged(value);
  }
  /**
   * Disposes and replaces the current meshes in the gizmo with the specified mesh
   * @param mesh The mesh to replace the default mesh of the gizmo
   */
  setCustomMesh(mesh) {
    if (mesh.getScene() != this.gizmoLayer.utilityLayerScene) {
      throw "When setting a custom mesh on a gizmo, the custom meshes scene must be the same as the gizmos (eg. gizmo.gizmoLayer.utilityLayerScene)";
    }
    this._rootMesh.getChildMeshes().forEach((c) => {
      c.dispose();
    });
    mesh.parent = this._rootMesh;
    this._customMeshSet = true;
  }
  /**
   * Additional transform applied to the gizmo.
   * It's useful when the gizmo is attached to a bone: if the bone is part of a skeleton attached to a mesh, you should define the mesh as additionalTransformNode if you want the gizmo to be displayed at the bone's correct location.
   * Otherwise, as the gizmo is relative to the skeleton root, the mesh transformation will not be taken into account.
   */
  get additionalTransformNode() {
    return this._additionalTransformNode;
  }
  set additionalTransformNode(value) {
    this._additionalTransformNode = value;
  }
  /**
   * If set the gizmo's rotation will be updated to match the attached mesh each frame (Default: true)
   * NOTE: This is only possible for meshes with uniform scaling, as otherwise it's not possible to decompose the rotation
   */
  set updateGizmoRotationToMatchAttachedMesh(value) {
    this._updateGizmoRotationToMatchAttachedMesh = value;
  }
  get updateGizmoRotationToMatchAttachedMesh() {
    return this._updateGizmoRotationToMatchAttachedMesh;
  }
  /**
   * If set the gizmo's position will be updated to match the attached mesh each frame (Default: true)
   */
  set updateGizmoPositionToMatchAttachedMesh(value) {
    this._updateGizmoPositionToMatchAttachedMesh = value;
  }
  get updateGizmoPositionToMatchAttachedMesh() {
    return this._updateGizmoPositionToMatchAttachedMesh;
  }
  /**
   * Defines where the gizmo will be positioned if `updateGizmoPositionToMatchAttachedMesh` is enabled.
   * (Default: GizmoAnchorPoint.Origin)
   */
  set anchorPoint(value) {
    this._anchorPoint = value;
  }
  get anchorPoint() {
    return this._anchorPoint;
  }
  /**
   * Set the coordinate system to use. By default it's local.
   * But it's possible for a user to tweak so its local for translation and world for rotation.
   * In that case, setting the coordinate system will change `updateGizmoRotationToMatchAttachedMesh` and `updateGizmoPositionToMatchAttachedMesh`
   */
  set coordinatesMode(coordinatesMode) {
    this._coordinatesMode = coordinatesMode;
    const local = coordinatesMode == 1;
    this.updateGizmoRotationToMatchAttachedMesh = local;
    this.updateGizmoPositionToMatchAttachedMesh = true;
  }
  get coordinatesMode() {
    return this._coordinatesMode;
  }
  /**
   * When set, the gizmo will always appear the same size no matter where the camera is (default: true)
   */
  set updateScale(value) {
    this._updateScale = value;
  }
  get updateScale() {
    return this._updateScale;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _attachedNodeChanged(value) {
  }
  /**
   * Creates a gizmo
   * @param gizmoLayer The utility layer the gizmo will be added to
   */
  constructor(gizmoLayer = UtilityLayerRenderer.DefaultUtilityLayer) {
    this.gizmoLayer = gizmoLayer;
    this._attachedMesh = null;
    this._attachedNode = null;
    this._customRotationQuaternion = null;
    this._scaleRatio = 1;
    this._isHovered = false;
    this._customMeshSet = false;
    this._updateGizmoRotationToMatchAttachedMesh = true;
    this._updateGizmoPositionToMatchAttachedMesh = true;
    this._anchorPoint = 0;
    this._updateScale = true;
    this._coordinatesMode = 1;
    this._interactionsEnabled = true;
    this._rightHandtoLeftHandMatrix = Matrix.RotationY(Math.PI);
    this._rootMesh = new Mesh("gizmoRootNode", gizmoLayer.utilityLayerScene);
    this._rootMesh.rotationQuaternion = Quaternion.Identity();
    this._beforeRenderObserver = this.gizmoLayer.utilityLayerScene.onBeforeRenderObservable.add(() => {
      this._update();
    });
  }
  /**
   * posture that the gizmo will be display
   * When set null, default value will be used (Quaternion(0, 0, 0, 1))
   */
  get customRotationQuaternion() {
    return this._customRotationQuaternion;
  }
  set customRotationQuaternion(customRotationQuaternion) {
    this._customRotationQuaternion = customRotationQuaternion;
  }
  /**
   * Updates the gizmo to match the attached mesh's position/rotation
   */
  _update() {
    if (this.attachedNode) {
      let effectiveNode = this.attachedNode;
      if (this.attachedMesh) {
        effectiveNode = this.attachedMesh || this.attachedNode;
      }
      if (this.updateGizmoPositionToMatchAttachedMesh) {
        if (this.anchorPoint == 1 && effectiveNode.getAbsolutePivotPoint) {
          const position = effectiveNode.getAbsolutePivotPoint();
          this._rootMesh.position.copyFrom(position);
        } else {
          const row = effectiveNode.getWorldMatrix().getRow(3);
          const position = row ? row.toVector3() : new Vector3(0, 0, 0);
          this._rootMesh.position.copyFrom(position);
        }
      }
      if (this.updateGizmoRotationToMatchAttachedMesh) {
        const supportedNode = effectiveNode._isMesh || effectiveNode.getClassName() === "AbstractMesh" || effectiveNode.getClassName() === "TransformNode" || effectiveNode.getClassName() === "InstancedMesh";
        const transformNode = supportedNode ? effectiveNode : void 0;
        effectiveNode.getWorldMatrix().decompose(void 0, this._rootMesh.rotationQuaternion, void 0, _Gizmo.PreserveScaling ? transformNode : void 0);
        this._rootMesh.rotationQuaternion.normalize();
      } else {
        if (this._customRotationQuaternion) {
          this._rootMesh.rotationQuaternion.copyFrom(this._customRotationQuaternion);
        } else {
          this._rootMesh.rotationQuaternion.set(0, 0, 0, 1);
        }
      }
      if (this.updateScale) {
        const activeCamera = this.gizmoLayer.utilityLayerScene.activeCamera;
        const cameraPosition = activeCamera.globalPosition;
        this._rootMesh.position.subtractToRef(cameraPosition, TmpVectors.Vector3[0]);
        let scale = this.scaleRatio;
        if (activeCamera.mode == Camera.ORTHOGRAPHIC_CAMERA) {
          if (activeCamera.orthoTop && activeCamera.orthoBottom) {
            const orthoHeight = activeCamera.orthoTop - activeCamera.orthoBottom;
            scale *= orthoHeight;
          }
        } else {
          const camForward = activeCamera.getScene().useRightHandedSystem ? Vector3.RightHandedForwardReadOnly : Vector3.LeftHandedForwardReadOnly;
          const direction = activeCamera.getDirection(camForward);
          scale *= Vector3.Dot(TmpVectors.Vector3[0], direction);
        }
        this._rootMesh.scaling.setAll(scale);
        if (effectiveNode._getWorldMatrixDeterminant() < 0 && !_Gizmo.PreserveScaling) {
          this._rootMesh.scaling.y *= -1;
        }
      } else {
        this._rootMesh.scaling.setAll(this.scaleRatio);
      }
    }
    if (this.additionalTransformNode) {
      this._rootMesh.computeWorldMatrix(true);
      this._rootMesh.getWorldMatrix().multiplyToRef(this.additionalTransformNode.getWorldMatrix(), TmpVectors.Matrix[0]);
      TmpVectors.Matrix[0].decompose(this._rootMesh.scaling, this._rootMesh.rotationQuaternion, this._rootMesh.position);
    }
  }
  /**
   * if transform has a pivot and is not using PostMultiplyPivotMatrix, then the worldMatrix contains the pivot matrix (it's not cancelled at the end)
   * so, when extracting the world matrix component, the translation (and other components) is containing the pivot translation.
   * And the pivot is applied each frame. Removing it anyway here makes it applied only in computeWorldMatrix.
   * @param transform local transform that needs to be transform by the pivot inverse matrix
   * @param localMatrix local matrix that needs to be transform by the pivot inverse matrix
   * @param result resulting matrix transformed by pivot inverse if the transform node is using pivot without using post Multiply Pivot Matrix
   */
  _handlePivotMatrixInverse(transform, localMatrix, result) {
    if (transform.isUsingPivotMatrix() && !transform.isUsingPostMultiplyPivotMatrix()) {
      transform.getPivotMatrix().invertToRef(TmpVectors.Matrix[5]);
      TmpVectors.Matrix[5].multiplyToRef(localMatrix, result);
      return;
    }
    result.copyFrom(localMatrix);
  }
  /**
   * computes the rotation/scaling/position of the transform once the Node world matrix has changed.
   */
  _matrixChanged() {
    if (!this._attachedNode) {
      return;
    }
    if (this._attachedNode._isCamera) {
      const camera = this._attachedNode;
      let worldMatrix;
      let worldMatrixUC;
      if (camera.parent) {
        const parentInv = TmpVectors.Matrix[1];
        camera.parent._worldMatrix.invertToRef(parentInv);
        this._attachedNode._worldMatrix.multiplyToRef(parentInv, TmpVectors.Matrix[0]);
        worldMatrix = TmpVectors.Matrix[0];
      } else {
        worldMatrix = this._attachedNode._worldMatrix;
      }
      if (camera.getScene().useRightHandedSystem) {
        this._rightHandtoLeftHandMatrix.multiplyToRef(worldMatrix, TmpVectors.Matrix[1]);
        worldMatrixUC = TmpVectors.Matrix[1];
      } else {
        worldMatrixUC = worldMatrix;
      }
      worldMatrixUC.decompose(TmpVectors.Vector3[1], TmpVectors.Quaternion[0], TmpVectors.Vector3[0]);
      const inheritsTargetCamera = this._attachedNode.getClassName() === "FreeCamera" || this._attachedNode.getClassName() === "FlyCamera" || this._attachedNode.getClassName() === "ArcFollowCamera" || this._attachedNode.getClassName() === "TargetCamera" || this._attachedNode.getClassName() === "TouchCamera" || this._attachedNode.getClassName() === "UniversalCamera";
      if (inheritsTargetCamera) {
        const targetCamera = this._attachedNode;
        targetCamera.rotation = TmpVectors.Quaternion[0].toEulerAngles();
        if (targetCamera.rotationQuaternion) {
          targetCamera.rotationQuaternion.copyFrom(TmpVectors.Quaternion[0]);
          targetCamera.rotationQuaternion.normalize();
        }
      }
      camera.position.copyFrom(TmpVectors.Vector3[0]);
    } else if (this._attachedNode._isMesh || this._attachedNode.getClassName() === "AbstractMesh" || this._attachedNode.getClassName() === "TransformNode" || this._attachedNode.getClassName() === "InstancedMesh") {
      const transform = this._attachedNode;
      if (transform.parent) {
        const parentInv = TmpVectors.Matrix[0];
        const localMat = TmpVectors.Matrix[1];
        transform.parent.getWorldMatrix().invertToRef(parentInv);
        this._attachedNode.getWorldMatrix().multiplyToRef(parentInv, localMat);
        const matrixToDecompose = TmpVectors.Matrix[4];
        this._handlePivotMatrixInverse(transform, localMat, matrixToDecompose);
        matrixToDecompose.decompose(TmpVectors.Vector3[0], TmpVectors.Quaternion[0], transform.position, _Gizmo.PreserveScaling ? transform : void 0, _Gizmo.UseAbsoluteScaling);
        TmpVectors.Quaternion[0].normalize();
        if (transform.isUsingPivotMatrix()) {
          const r = TmpVectors.Quaternion[1];
          Quaternion.RotationYawPitchRollToRef(transform.rotation.y, transform.rotation.x, transform.rotation.z, r);
          const scaleMatrix = TmpVectors.Matrix[2];
          Matrix.ScalingToRef(transform.scaling.x, transform.scaling.y, transform.scaling.z, scaleMatrix);
          const rotationMatrix = TmpVectors.Matrix[2];
          r.toRotationMatrix(rotationMatrix);
          const pivotMatrix = transform.getPivotMatrix();
          const invPivotMatrix = TmpVectors.Matrix[3];
          pivotMatrix.invertToRef(invPivotMatrix);
          pivotMatrix.multiplyToRef(scaleMatrix, TmpVectors.Matrix[4]);
          TmpVectors.Matrix[4].multiplyToRef(rotationMatrix, TmpVectors.Matrix[5]);
          TmpVectors.Matrix[5].multiplyToRef(invPivotMatrix, TmpVectors.Matrix[6]);
          TmpVectors.Matrix[6].getTranslationToRef(TmpVectors.Vector3[1]);
          transform.position.subtractInPlace(TmpVectors.Vector3[1]);
        }
      } else {
        const matrixToDecompose = TmpVectors.Matrix[4];
        this._handlePivotMatrixInverse(transform, this._attachedNode._worldMatrix, matrixToDecompose);
        matrixToDecompose.decompose(TmpVectors.Vector3[0], TmpVectors.Quaternion[0], transform.position, _Gizmo.PreserveScaling ? transform : void 0, _Gizmo.UseAbsoluteScaling);
      }
      TmpVectors.Vector3[0].scaleInPlace(1 / transform.scalingDeterminant);
      transform.scaling.copyFrom(TmpVectors.Vector3[0]);
      if (!transform.billboardMode) {
        if (transform.rotationQuaternion) {
          transform.rotationQuaternion.copyFrom(TmpVectors.Quaternion[0]);
          transform.rotationQuaternion.normalize();
        } else {
          transform.rotation = TmpVectors.Quaternion[0].toEulerAngles();
        }
      }
    } else if (this._attachedNode.getClassName() === "Bone") {
      const bone = this._attachedNode;
      const parent = bone.getParent();
      if (parent) {
        const invParent = TmpVectors.Matrix[0];
        const boneLocalMatrix = TmpVectors.Matrix[1];
        parent.getFinalMatrix().invertToRef(invParent);
        bone.getFinalMatrix().multiplyToRef(invParent, boneLocalMatrix);
        const lmat = bone.getLocalMatrix();
        lmat.copyFrom(boneLocalMatrix);
      } else {
        const lmat = bone.getLocalMatrix();
        lmat.copyFrom(bone.getFinalMatrix());
      }
      bone.markAsDirty();
    } else {
      const light = this._attachedNode;
      if (light.getTypeID) {
        const type = light.getTypeID();
        if (type === Light.LIGHTTYPEID_DIRECTIONALLIGHT || type === Light.LIGHTTYPEID_SPOTLIGHT || type === Light.LIGHTTYPEID_POINTLIGHT) {
          const parent = light.parent;
          if (parent) {
            const invParent = TmpVectors.Matrix[0];
            const nodeLocalMatrix = TmpVectors.Matrix[1];
            parent.getWorldMatrix().invertToRef(invParent);
            light.getWorldMatrix().multiplyToRef(invParent, nodeLocalMatrix);
            nodeLocalMatrix.decompose(void 0, TmpVectors.Quaternion[0], TmpVectors.Vector3[0]);
          } else {
            this._attachedNode._worldMatrix.decompose(void 0, TmpVectors.Quaternion[0], TmpVectors.Vector3[0]);
          }
          light.position = new Vector3(TmpVectors.Vector3[0].x, TmpVectors.Vector3[0].y, TmpVectors.Vector3[0].z);
          if (light.direction) {
            light.direction = new Vector3(light.direction.x, light.direction.y, light.direction.z);
          }
        }
      }
    }
  }
  /**
   * refresh gizmo mesh material
   * @param gizmoMeshes
   * @param material material to apply
   */
  _setGizmoMeshMaterial(gizmoMeshes, material) {
    if (gizmoMeshes) {
      gizmoMeshes.forEach((m) => {
        m.material = material;
        if (m.color) {
          m.color = material.diffuseColor;
        }
      });
    }
  }
  /**
   * Subscribes to pointer up, down, and hover events. Used for responsive gizmos.
   * @param gizmoLayer The utility layer the gizmo will be added to
   * @param gizmoAxisCache Gizmo axis definition used for reactive gizmo UI
   * @returns {Observer<PointerInfo>} pointerObserver
   */
  static GizmoAxisPointerObserver(gizmoLayer, gizmoAxisCache) {
    let dragging = false;
    const pointerObserver = gizmoLayer.utilityLayerScene.onPointerObservable.add((pointerInfo) => {
      var _a, _b;
      if (pointerInfo.pickInfo) {
        if (pointerInfo.type === PointerEventTypes.POINTERMOVE) {
          if (dragging) {
            return;
          }
          gizmoAxisCache.forEach((cache) => {
            var _a2, _b2;
            if (cache.colliderMeshes && cache.gizmoMeshes) {
              const isHovered = ((_b2 = cache.colliderMeshes) == null ? void 0 : _b2.indexOf((_a2 = pointerInfo == null ? void 0 : pointerInfo.pickInfo) == null ? void 0 : _a2.pickedMesh)) != -1;
              const material = cache.dragBehavior.enabled ? isHovered || cache.active ? cache.hoverMaterial : cache.material : cache.disableMaterial;
              cache.gizmoMeshes.forEach((m) => {
                m.material = material;
                if (m.color) {
                  m.color = material.diffuseColor;
                }
              });
            }
          });
        }
        if (pointerInfo.type === PointerEventTypes.POINTERDOWN) {
          if (gizmoAxisCache.has((_a = pointerInfo.pickInfo.pickedMesh) == null ? void 0 : _a.parent)) {
            dragging = true;
            const statusMap = gizmoAxisCache.get((_b = pointerInfo.pickInfo.pickedMesh) == null ? void 0 : _b.parent);
            statusMap.active = true;
            gizmoAxisCache.forEach((cache) => {
              var _a2, _b2;
              const isHovered = ((_b2 = cache.colliderMeshes) == null ? void 0 : _b2.indexOf((_a2 = pointerInfo == null ? void 0 : pointerInfo.pickInfo) == null ? void 0 : _a2.pickedMesh)) != -1;
              const material = (isHovered || cache.active) && cache.dragBehavior.enabled ? cache.hoverMaterial : cache.disableMaterial;
              cache.gizmoMeshes.forEach((m) => {
                m.material = material;
                if (m.color) {
                  m.color = material.diffuseColor;
                }
              });
            });
          }
        }
        if (pointerInfo.type === PointerEventTypes.POINTERUP) {
          gizmoAxisCache.forEach((cache) => {
            cache.active = false;
            dragging = false;
            cache.gizmoMeshes.forEach((m) => {
              m.material = cache.dragBehavior.enabled ? cache.material : cache.disableMaterial;
              if (m.color) {
                m.color = cache.material.diffuseColor;
              }
            });
          });
        }
      }
    });
    return pointerObserver;
  }
  /**
   * Disposes of the gizmo
   */
  dispose() {
    this._rootMesh.dispose();
    if (this._beforeRenderObserver) {
      this.gizmoLayer.utilityLayerScene.onBeforeRenderObservable.remove(this._beforeRenderObserver);
    }
  }
};
Gizmo.PreserveScaling = false;
Gizmo.UseAbsoluteScaling = true;

// node_modules/@babylonjs/core/Misc/pivotTools.js
var PivotTools = class _PivotTools {
  /**
   * @internal
   */
  static _RemoveAndStorePivotPoint(mesh) {
    if (mesh && _PivotTools._PivotCached === 0) {
      mesh.getPivotPointToRef(_PivotTools._OldPivotPoint);
      _PivotTools._PivotPostMultiplyPivotMatrix = mesh._postMultiplyPivotMatrix;
      if (!_PivotTools._OldPivotPoint.equalsToFloats(0, 0, 0)) {
        mesh.setPivotMatrix(Matrix.IdentityReadOnly);
        _PivotTools._OldPivotPoint.subtractToRef(mesh.getPivotPoint(), _PivotTools._PivotTranslation);
        _PivotTools._PivotTmpVector.copyFromFloats(1, 1, 1);
        _PivotTools._PivotTmpVector.subtractInPlace(mesh.scaling);
        _PivotTools._PivotTmpVector.multiplyInPlace(_PivotTools._PivotTranslation);
        mesh.position.addInPlace(_PivotTools._PivotTmpVector);
      }
    }
    _PivotTools._PivotCached++;
  }
  /**
   * @internal
   */
  static _RestorePivotPoint(mesh) {
    if (mesh && !_PivotTools._OldPivotPoint.equalsToFloats(0, 0, 0) && _PivotTools._PivotCached === 1) {
      mesh.setPivotPoint(_PivotTools._OldPivotPoint);
      mesh._postMultiplyPivotMatrix = _PivotTools._PivotPostMultiplyPivotMatrix;
      _PivotTools._PivotTmpVector.copyFromFloats(1, 1, 1);
      _PivotTools._PivotTmpVector.subtractInPlace(mesh.scaling);
      _PivotTools._PivotTmpVector.multiplyInPlace(_PivotTools._PivotTranslation);
      mesh.position.subtractInPlace(_PivotTools._PivotTmpVector);
    }
    this._PivotCached--;
  }
};
PivotTools._PivotCached = 0;
PivotTools._OldPivotPoint = new Vector3();
PivotTools._PivotTranslation = new Vector3();
PivotTools._PivotTmpVector = new Vector3();
PivotTools._PivotPostMultiplyPivotMatrix = false;

// node_modules/@babylonjs/gui/3D/materials/handle/shaders/handle.vertex.js
var name8 = "handleVertexShader";
var shader7 = `precision highp float;attribute vec3 position;uniform vec3 positionOffset;uniform mat4 worldViewProjection;uniform float scale;void main(void) {vec4 vPos=vec4((vec3(position)+positionOffset)*scale,1.0);gl_Position=worldViewProjection*vPos;}`;
ShaderStore.ShadersStore[name8] = shader7;

// node_modules/@babylonjs/gui/3D/materials/handle/shaders/handle.fragment.js
var name9 = "handlePixelShader";
var shader8 = `uniform vec3 color;void main(void) {gl_FragColor=vec4(color,1.0);}`;
ShaderStore.ShadersStore[name9] = shader8;

// node_modules/@babylonjs/gui/3D/materials/handle/handleMaterial.js
var HandleMaterial = class extends ShaderMaterial {
  /**
   * Is the material indicating hovering state
   */
  get hover() {
    return this._hover;
  }
  set hover(b) {
    this._hover = b;
    this._updateInterpolationTarget();
  }
  /**
   * Is the material indicating drag state
   */
  get drag() {
    return this._drag;
  }
  set drag(b) {
    this._drag = b;
    this._updateInterpolationTarget();
  }
  /**
   * Creates a handle material
   * @param name Name of the material
   * @param scene Scene
   */
  constructor(name22, scene) {
    super(name22, scene, "handle", {
      attributes: ["position"],
      uniforms: ["worldViewProjection", "color", "scale", "positionOffset"],
      needAlphaBlending: false,
      needAlphaTesting: false
    });
    this._hover = false;
    this._drag = false;
    this._color = new Color3();
    this._scale = 1;
    this._lastTick = -1;
    this.animationLength = 100;
    this.hoverColor = new Color3(0, 0.467, 0.84);
    this.baseColor = new Color3(1, 1, 1);
    this.hoverScale = 0.75;
    this.baseScale = 0.35;
    this.dragScale = 0.55;
    this._positionOffset = Vector3.Zero();
    this._updateInterpolationTarget();
    this._lastTick = Date.now();
    this._onBeforeRender = this.getScene().onBeforeRenderObservable.add(() => {
      const tick = Date.now();
      const delta = tick - this._lastTick;
      const scaleDiff = this._targetScale - this._scale;
      const colorDiff = TmpColors.Color3[0].copyFrom(this._targetColor).subtractToRef(this._color, TmpColors.Color3[0]);
      this._scale = this._scale + scaleDiff * delta / this.animationLength;
      colorDiff.scaleToRef(delta / this.animationLength, colorDiff);
      this._color.addToRef(colorDiff, this._color);
      this.setColor3("color", this._color);
      this.setFloat("scale", this._scale);
      this.setVector3("positionOffset", this._positionOffset);
      this._lastTick = tick;
    });
  }
  _updateInterpolationTarget() {
    if (this.drag) {
      this._targetColor = this.hoverColor;
      this._targetScale = this.dragScale;
    } else if (this.hover) {
      this._targetColor = this.hoverColor;
      this._targetScale = this.hoverScale;
    } else {
      this._targetColor = this.baseColor;
      this._targetScale = this.baseScale;
    }
  }
  /**
   * Disposes the handle material
   */
  dispose() {
    super.dispose();
    this.getScene().onBeforeRenderObservable.remove(this._onBeforeRender);
  }
};

// node_modules/@babylonjs/gui/3D/gizmos/gizmoHandle.js
var HandleState;
(function(HandleState2) {
  HandleState2[HandleState2["IDLE"] = 0] = "IDLE";
  HandleState2[HandleState2["HOVER"] = 1] = "HOVER";
  HandleState2[HandleState2["DRAG"] = 2] = "DRAG";
})(HandleState || (HandleState = {}));
var GizmoHandle = class {
  /**
   * The current state of the handle
   */
  get state() {
    return this._state;
  }
  /**
   * Returns the gizmo carrying this handle
   */
  get gizmo() {
    return this._gizmo;
  }
  /**
   * Sets hover state
   */
  set hover(value) {
    if (value) {
      this._state |= 1;
    } else {
      this._state &= ~1;
    }
    this._updateMaterial();
  }
  /**
   * Sets drag state
   */
  set drag(value) {
    if (value) {
      this._state |= 2;
    } else {
      this._state &= ~2;
    }
    this._updateMaterial();
  }
  /**
   * Creates a handle for a SlateGizmo
   * @param gizmo associated SlateGizmo
   * @param scene scene
   */
  constructor(gizmo, scene) {
    this._state = 0;
    this._materials = [];
    this._scene = scene;
    this._gizmo = gizmo;
    this.node = this.createNode();
    this.node.reservedDataStore = {
      handle: this
    };
  }
  _createMaterial(positionOffset) {
    const mat = new HandleMaterial("handle", this._scene);
    if (positionOffset) {
      mat._positionOffset = positionOffset;
    }
    return mat;
  }
  _updateMaterial() {
    const state = this._state;
    for (const mat of this._materials) {
      mat.hover = false;
      mat.drag = false;
    }
    if (state & 2) {
      for (const mat of this._materials) {
        mat.drag = true;
      }
    } else if (state & 1) {
      for (const mat of this._materials) {
        mat.hover = true;
      }
    }
  }
  /**
   * Binds callbacks from dragging interaction
   * @param dragStartFn Function to call on drag start
   * @param dragFn Function to call on drag
   * @param dragEndFn Function to call on drag end
   */
  setDragBehavior(dragStartFn, dragFn, dragEndFn) {
    const dragBehavior = new BaseSixDofDragBehavior();
    this._dragBehavior = dragBehavior;
    this._dragStartObserver = dragBehavior.onDragStartObservable.add(dragStartFn);
    this._draggingObserver = dragBehavior.onDragObservable.add(dragFn);
    this._dragEndObserver = dragBehavior.onDragEndObservable.add(dragEndFn);
    this._dragBehavior.attach(this.node);
  }
  /**
   * Disposes the handle
   */
  dispose() {
    this._dragBehavior.onDragStartObservable.remove(this._dragStartObserver);
    this._dragBehavior.onDragObservable.remove(this._draggingObserver);
    this._dragBehavior.onDragEndObservable.remove(this._dragEndObserver);
    this._dragBehavior.detach();
    for (const material of this._materials) {
      material.dispose();
    }
    this.node.dispose();
  }
};
var SideHandle = class extends GizmoHandle {
  /**
   * Creates the meshes and parent node of the handle
   * @returns created node
   */
  createNode() {
    const verticalBox = CreateBox("sideVert", { width: 1, height: 10, depth: 0.1 }, this._scene);
    const sideNode = new TransformNode("side", this._scene);
    verticalBox.parent = sideNode;
    const mat = this._createMaterial();
    verticalBox.material = mat;
    verticalBox.isNearGrabbable = true;
    this._materials.push(mat);
    return sideNode;
  }
};
var CornerHandle = class extends GizmoHandle {
  /**
   * Creates the meshes and parent node of the handle
   * @returns created node
   */
  createNode() {
    const horizontalBox = CreateBox("angleHor", { width: 3, height: 1, depth: 0.1 }, this._scene);
    const verticalBox = CreateBox("angleVert", { width: 1, height: 3, depth: 0.1 }, this._scene);
    const angleNode = new TransformNode("angle", this._scene);
    horizontalBox.parent = angleNode;
    verticalBox.parent = angleNode;
    horizontalBox.material = this._createMaterial(new Vector3(1, 0, 0));
    verticalBox.material = this._createMaterial(new Vector3(0, 1, 0));
    verticalBox.isNearGrabbable = true;
    horizontalBox.isNearGrabbable = true;
    this._materials.push(horizontalBox.material);
    this._materials.push(verticalBox.material);
    return angleNode;
  }
};

// node_modules/@babylonjs/gui/3D/gizmos/slateGizmo.js
var SlateGizmo = class extends Gizmo {
  /**
   * The slate attached to this gizmo
   */
  set attachedSlate(control) {
    if (control) {
      this.attachedMesh = control.mesh;
      this.updateBoundingBox();
      this._pickedPointObserver = control._host.onPickingObservable.add((pickedMesh) => {
        if (this._handleHovered && (!pickedMesh || pickedMesh.parent !== this._handleHovered.node)) {
          this._handleHovered.hover = false;
          this._handleHovered = null;
        }
        if (pickedMesh && pickedMesh.parent && pickedMesh.parent.reservedDataStore && pickedMesh.parent.reservedDataStore.handle) {
          const handle = pickedMesh.parent.reservedDataStore.handle;
          if (handle.gizmo === this) {
            this._handleHovered = handle;
            this._handleHovered.hover = true;
          }
        }
      });
    } else if (this._attachedSlate) {
      this._attachedSlate._host.onPickingObservable.remove(this._pickedPointObserver);
    }
    this._attachedSlate = control;
  }
  get attachedSlate() {
    return this._attachedSlate;
  }
  constructor(utilityLayer) {
    super(utilityLayer);
    this._boundingDimensions = new Vector3(0, 0, 0);
    this._renderObserver = null;
    this._tmpQuaternion = new Quaternion();
    this._tmpVector = new Vector3(0, 0, 0);
    this._corners = [];
    this._sides = [];
    this._boundingBoxGizmo = {
      min: new Vector3(),
      max: new Vector3()
    };
    this._margin = 0.35;
    this._handleSize = 0.075;
    this._attachedSlate = null;
    this._existingSlateScale = new Vector3();
    this.fixedScreenSize = false;
    this.fixedScreenSizeDistanceFactor = 10;
    this._createNode();
    this.updateScale = false;
    this._renderObserver = this.gizmoLayer.originalScene.onBeforeRenderObservable.add(() => {
      if (this.attachedMesh && !this._existingSlateScale.equals(this.attachedMesh.scaling)) {
        this.updateBoundingBox();
      }
    });
  }
  _createNode() {
    this._handlesParent = new TransformNode("handlesParent", this.gizmoLayer.utilityLayerScene);
    this._handlesParent.rotationQuaternion = Quaternion.Identity();
    const masksCorners = [
      {
        dimensions: new Vector3(-1, -1, 0),
        origin: new Vector3(1, 0, 0)
      },
      {
        dimensions: new Vector3(1, -1, 0),
        origin: new Vector3(0, 0, 0)
      },
      {
        dimensions: new Vector3(1, 1, 0),
        origin: new Vector3(0, 1, 0)
      },
      {
        dimensions: new Vector3(-1, 1, 0),
        origin: new Vector3(1, 1, 0)
      }
    ];
    for (let i = 0; i < 4; i++) {
      const corner = new CornerHandle(this, this.gizmoLayer.utilityLayerScene);
      this._corners.push(corner);
      corner.node.rotation.z = Math.PI / 2 * i;
      corner.node.parent = this._handlesParent;
      this._assignDragBehaviorCorners(corner, (originStart, dimensionsStart, offset, masks) => this._moveHandle(originStart, dimensionsStart, offset, masks, true), masksCorners[i]);
    }
    for (let i = 0; i < 4; i++) {
      const side = new SideHandle(this, this.gizmoLayer.utilityLayerScene);
      this._sides.push(side);
      side.node.rotation.z = Math.PI / 2 * i;
      side.node.parent = this._handlesParent;
      this._assignDragBehaviorSides(side, i % 2 === 0 ? new Vector3(0, 1, 0) : new Vector3(1, 0, 0));
    }
    this._handlesParent.parent = this._rootMesh;
  }
  _keepAspectRatio(vector, aspectRatio, invertDiagonal = false) {
    const axis = TmpVectors.Vector3[0];
    axis.copyFromFloats(aspectRatio, 1, 0).normalize();
    if (invertDiagonal) {
      axis.y *= -1;
    }
    const dot = Vector3.Dot(vector, axis);
    vector.copyFrom(axis).scaleInPlace(dot);
  }
  _clampDimensions(vector, dimensions, mask, keepAspectRatio = false) {
    const impact = TmpVectors.Vector3[0];
    impact.copyFrom(vector).multiplyInPlace(mask);
    const clampedDimensions = TmpVectors.Vector3[1];
    clampedDimensions.copyFromFloats(Math.max(this._attachedSlate.minDimensions.x, impact.x + dimensions.x), Math.max(this._attachedSlate.minDimensions.y, impact.y + dimensions.y), 0);
    if (keepAspectRatio) {
      const ratio = dimensions.x / dimensions.y;
      clampedDimensions.x = Math.max(clampedDimensions.x, clampedDimensions.y * ratio);
      clampedDimensions.y = Math.max(clampedDimensions.y, clampedDimensions.x / ratio);
    }
    impact.copyFrom(clampedDimensions).subtractInPlace(dimensions);
    vector.x = Math.sign(vector.x) * Math.abs(impact.x);
    vector.y = Math.sign(vector.y) * Math.abs(impact.y);
  }
  _moveHandle(originStart, dimensionsStart, offset, masks, isCorner) {
    if (!this._attachedSlate) {
      return;
    }
    if (isCorner) {
      const aspectRatio = dimensionsStart.x / dimensionsStart.y;
      this._keepAspectRatio(offset, aspectRatio, masks.dimensions.x * masks.dimensions.y < 0);
    }
    this._clampDimensions(offset, dimensionsStart, masks.dimensions, isCorner);
    const offsetOriginMasked = TmpVectors.Vector3[0];
    const offsetDimensionsMasked = TmpVectors.Vector3[1];
    offsetOriginMasked.copyFrom(offset).multiplyInPlace(masks.origin);
    offsetDimensionsMasked.copyFrom(offset).multiplyInPlace(masks.dimensions);
    this._attachedSlate.origin.copyFrom(originStart).addInPlace(offsetOriginMasked);
    this._attachedSlate.dimensions.set(dimensionsStart.x + offsetDimensionsMasked.x, dimensionsStart.y + offsetDimensionsMasked.y);
  }
  _assignDragBehaviorCorners(handle, moveFn, masks) {
    const dimensionsStart = new Vector3();
    const originStart = new Vector3();
    const dragOrigin = new Vector3();
    const toObjectFrame = new Matrix();
    const dragPlaneNormal = new Vector3();
    const projectToRef = (position, normal, origin, ref) => {
      position.subtractToRef(origin, TmpVectors.Vector3[0]);
      const dot = Vector3.Dot(TmpVectors.Vector3[0], normal);
      TmpVectors.Vector3[1].copyFrom(normal).scaleInPlace(dot);
      TmpVectors.Vector3[0].subtractInPlace(TmpVectors.Vector3[1]);
      TmpVectors.Vector3[0].addToRef(origin, ref);
    };
    const dragStart = (event) => {
      if (this.attachedSlate && this.attachedMesh) {
        dimensionsStart.set(this.attachedSlate.dimensions.x, this.attachedSlate.dimensions.y, Epsilon);
        originStart.copyFrom(this.attachedSlate.origin);
        dragOrigin.copyFrom(event.position);
        toObjectFrame.copyFrom(this.attachedMesh.computeWorldMatrix(true));
        toObjectFrame.invert();
        this.attachedSlate._followButton.isToggled = false;
        Vector3.TransformNormalToRef(Vector3.Forward(), this.attachedMesh.getWorldMatrix(), dragPlaneNormal);
        dragPlaneNormal.normalize();
        if (this._handleHovered) {
          this._handleDragged = this._handleHovered;
          this._handleDragged.drag = true;
        }
      }
    };
    const dragging = (event) => {
      if (this.attachedSlate && this.attachedMesh) {
        projectToRef(event.position, dragPlaneNormal, dragOrigin, this._tmpVector);
        this._tmpVector.subtractInPlace(dragOrigin);
        Vector3.TransformNormalToRef(this._tmpVector, toObjectFrame, this._tmpVector);
        moveFn(originStart, dimensionsStart, this._tmpVector, masks);
        this.attachedSlate._positionElements();
        this.updateBoundingBox();
      }
    };
    const dragEnd = () => {
      if (this.attachedSlate && this.attachedNode) {
        this.attachedSlate._updatePivot();
        if (this._handleDragged) {
          this._handleDragged.drag = false;
          this._handleDragged = null;
        }
      }
    };
    handle.setDragBehavior(dragStart, dragging, dragEnd);
  }
  _assignDragBehaviorSides(handle, dragPlaneNormal) {
    const quaternionOrigin = new Quaternion();
    const dragOrigin = new Vector3();
    const directionOrigin = new Vector3();
    const worldPivot = new Vector3();
    const worldPlaneNormal = new Vector3();
    const dragStart = (event) => {
      if (this.attachedSlate && this.attachedMesh) {
        quaternionOrigin.copyFrom(this.attachedMesh.rotationQuaternion);
        dragOrigin.copyFrom(event.position);
        worldPivot.copyFrom(this.attachedMesh.getAbsolutePivotPoint());
        directionOrigin.copyFrom(dragOrigin).subtractInPlace(worldPivot).normalize();
        this.attachedSlate._followButton.isToggled = false;
        Vector3.TransformNormalToRef(dragPlaneNormal, this.attachedMesh.getWorldMatrix(), worldPlaneNormal);
        worldPlaneNormal.normalize();
        if (this._handleHovered) {
          this._handleDragged = this._handleHovered;
          this._handleDragged.drag = true;
        }
      }
    };
    const dragging = (event) => {
      if (this.attachedSlate && this.attachedMesh) {
        this._tmpVector.copyFrom(event.position);
        this._tmpVector.subtractInPlace(worldPivot);
        this._tmpVector.normalize();
        const angle = -Vector3.GetAngleBetweenVectorsOnPlane(this._tmpVector, directionOrigin, worldPlaneNormal);
        Quaternion.RotationAxisToRef(dragPlaneNormal, angle, this._tmpQuaternion);
        quaternionOrigin.multiplyToRef(this._tmpQuaternion, this.attachedMesh.rotationQuaternion);
      }
    };
    const dragEnd = () => {
      if (this.attachedSlate && this.attachedNode) {
        this.attachedSlate._updatePivot();
        if (this._handleDragged) {
          this._handleDragged.drag = false;
          this._handleDragged = null;
        }
      }
    };
    handle.setDragBehavior(dragStart, dragging, dragEnd);
  }
  _attachedNodeChanged(value) {
    if (value) {
      this.updateBoundingBox();
    }
  }
  /**
   * Updates the bounding box information for the gizmo
   */
  updateBoundingBox() {
    if (this.attachedMesh) {
      PivotTools._RemoveAndStorePivotPoint(this.attachedMesh);
      const originalParent = this.attachedMesh.parent;
      this.attachedMesh.setParent(null);
      this._update();
      if (!this.attachedMesh.rotationQuaternion) {
        this.attachedMesh.rotationQuaternion = Quaternion.RotationYawPitchRoll(this.attachedMesh.rotation.y, this.attachedMesh.rotation.x, this.attachedMesh.rotation.z);
      }
      this._tmpQuaternion.copyFrom(this.attachedMesh.rotationQuaternion);
      this._tmpVector.copyFrom(this.attachedMesh.position);
      this.attachedMesh.rotationQuaternion.set(0, 0, 0, 1);
      this.attachedMesh.position.set(0, 0, 0);
      const boundingMinMax = this.attachedMesh.getHierarchyBoundingVectors();
      boundingMinMax.max.subtractToRef(boundingMinMax.min, this._boundingDimensions);
      this._boundingBoxGizmo.min = boundingMinMax.min;
      this._boundingBoxGizmo.max = boundingMinMax.max;
      this._updateHandlesPosition();
      this._updateHandlesScaling();
      this.attachedMesh.rotationQuaternion.copyFrom(this._tmpQuaternion);
      this.attachedMesh.position.copyFrom(this._tmpVector);
      PivotTools._RestorePivotPoint(this.attachedMesh);
      this.attachedMesh.setParent(originalParent);
      this.attachedMesh.computeWorldMatrix(true);
      this._existingSlateScale.copyFrom(this.attachedMesh.scaling);
    }
  }
  _updateHandlesPosition() {
    const min = this._boundingBoxGizmo.min.clone();
    const max = this._boundingBoxGizmo.max.clone();
    const handleScaling = this._corners[0].node.scaling.length();
    min.x -= this._margin * handleScaling;
    min.y -= this._margin * handleScaling;
    max.x += this._margin * handleScaling;
    max.y += this._margin * handleScaling;
    const center = min.add(max).scaleInPlace(0.5);
    this._corners[0].node.position.copyFromFloats(min.x, min.y, 0);
    this._corners[1].node.position.copyFromFloats(max.x, min.y, 0);
    this._corners[2].node.position.copyFromFloats(max.x, max.y, 0);
    this._corners[3].node.position.copyFromFloats(min.x, max.y, 0);
    this._sides[0].node.position.copyFromFloats(min.x, center.y, 0);
    this._sides[1].node.position.copyFromFloats(center.x, min.y, 0);
    this._sides[2].node.position.copyFromFloats(max.x, center.y, 0);
    this._sides[3].node.position.copyFromFloats(center.x, max.y, 0);
  }
  _updateHandlesScaling() {
    if (this._attachedSlate && this._attachedSlate.mesh) {
      const scaledWidth = this._attachedSlate.mesh.scaling.x * this._attachedSlate.dimensions.x;
      const scaledHeight = this._attachedSlate.mesh.scaling.y * this._attachedSlate.dimensions.y;
      const scale = Math.min(scaledWidth, scaledHeight) * this._handleSize;
      for (let index = 0; index < this._corners.length; index++) {
        this._corners[index].node.scaling.setAll(scale);
      }
      for (let index = 0; index < this._sides.length; index++) {
        this._sides[index].node.scaling.setAll(scale);
      }
    }
  }
  _update() {
    super._update();
    if (!this.gizmoLayer.utilityLayerScene.activeCamera) {
      return;
    }
    if (this._attachedSlate && this._attachedSlate.mesh) {
      if (this.fixedScreenSize) {
        this._attachedSlate.mesh.absolutePosition.subtractToRef(this.gizmoLayer.utilityLayerScene.activeCamera.position, this._tmpVector);
        const distanceFromCamera = this._handleSize * this._tmpVector.length() / this.fixedScreenSizeDistanceFactor;
        for (let i = 0; i < this._corners.length; i++) {
          this._corners[i].node.scaling.set(distanceFromCamera, distanceFromCamera, distanceFromCamera);
        }
        for (let i = 0; i < this._sides.length; i++) {
          this._sides[i].node.scaling.set(distanceFromCamera, distanceFromCamera, distanceFromCamera);
        }
      }
      this._updateHandlesPosition();
    }
  }
  dispose() {
    this.gizmoLayer.originalScene.onBeforeRenderObservable.remove(this._renderObserver);
    super.dispose();
    for (const corner of this._corners) {
      corner.dispose();
    }
    for (const side of this._sides) {
      side.dispose();
    }
  }
};

// node_modules/@babylonjs/core/Culling/ray.core.js
var PickingCustomization = {
  internalPickerForMesh: void 0
};
var Ray = class _Ray {
  /**
   * Creates a new ray
   * @param origin origin point
   * @param direction direction
   * @param length length of the ray
   * @param epsilon The epsilon value to use when calculating the ray/triangle intersection (default: 0)
   */
  constructor(origin, direction, length = Number.MAX_VALUE, epsilon = Epsilon) {
    this.origin = origin;
    this.direction = direction;
    this.length = length;
    this.epsilon = epsilon;
  }
  // Methods
  /**
   * Clone the current ray
   * @returns a new ray
   */
  clone() {
    return new _Ray(this.origin.clone(), this.direction.clone(), this.length);
  }
  /**
   * Checks if the ray intersects a box
   * This does not account for the ray length by design to improve perfs.
   * @param minimum bound of the box
   * @param maximum bound of the box
   * @param intersectionTreshold extra extend to be added to the box in all direction
   * @returns if the box was hit
   */
  intersectsBoxMinMax(minimum, maximum, intersectionTreshold = 0) {
    const newMinimum = _Ray._TmpVector3[0].copyFromFloats(minimum.x - intersectionTreshold, minimum.y - intersectionTreshold, minimum.z - intersectionTreshold);
    const newMaximum = _Ray._TmpVector3[1].copyFromFloats(maximum.x + intersectionTreshold, maximum.y + intersectionTreshold, maximum.z + intersectionTreshold);
    let d = 0;
    let maxValue = Number.MAX_VALUE;
    let inv;
    let min;
    let max;
    let temp;
    if (Math.abs(this.direction.x) < 1e-7) {
      if (this.origin.x < newMinimum.x || this.origin.x > newMaximum.x) {
        return false;
      }
    } else {
      inv = 1 / this.direction.x;
      min = (newMinimum.x - this.origin.x) * inv;
      max = (newMaximum.x - this.origin.x) * inv;
      if (max === -Infinity) {
        max = Infinity;
      }
      if (min > max) {
        temp = min;
        min = max;
        max = temp;
      }
      d = Math.max(min, d);
      maxValue = Math.min(max, maxValue);
      if (d > maxValue) {
        return false;
      }
    }
    if (Math.abs(this.direction.y) < 1e-7) {
      if (this.origin.y < newMinimum.y || this.origin.y > newMaximum.y) {
        return false;
      }
    } else {
      inv = 1 / this.direction.y;
      min = (newMinimum.y - this.origin.y) * inv;
      max = (newMaximum.y - this.origin.y) * inv;
      if (max === -Infinity) {
        max = Infinity;
      }
      if (min > max) {
        temp = min;
        min = max;
        max = temp;
      }
      d = Math.max(min, d);
      maxValue = Math.min(max, maxValue);
      if (d > maxValue) {
        return false;
      }
    }
    if (Math.abs(this.direction.z) < 1e-7) {
      if (this.origin.z < newMinimum.z || this.origin.z > newMaximum.z) {
        return false;
      }
    } else {
      inv = 1 / this.direction.z;
      min = (newMinimum.z - this.origin.z) * inv;
      max = (newMaximum.z - this.origin.z) * inv;
      if (max === -Infinity) {
        max = Infinity;
      }
      if (min > max) {
        temp = min;
        min = max;
        max = temp;
      }
      d = Math.max(min, d);
      maxValue = Math.min(max, maxValue);
      if (d > maxValue) {
        return false;
      }
    }
    return true;
  }
  /**
   * Checks if the ray intersects a box
   * This does not account for the ray lenght by design to improve perfs.
   * @param box the bounding box to check
   * @param intersectionTreshold extra extend to be added to the BoundingBox in all direction
   * @returns if the box was hit
   */
  intersectsBox(box, intersectionTreshold = 0) {
    return this.intersectsBoxMinMax(box.minimum, box.maximum, intersectionTreshold);
  }
  /**
   * If the ray hits a sphere
   * @param sphere the bounding sphere to check
   * @param intersectionTreshold extra extend to be added to the BoundingSphere in all direction
   * @returns true if it hits the sphere
   */
  intersectsSphere(sphere, intersectionTreshold = 0) {
    const x = sphere.center.x - this.origin.x;
    const y = sphere.center.y - this.origin.y;
    const z = sphere.center.z - this.origin.z;
    const pyth = x * x + y * y + z * z;
    const radius = sphere.radius + intersectionTreshold;
    const rr = radius * radius;
    if (pyth <= rr) {
      return true;
    }
    const dot = x * this.direction.x + y * this.direction.y + z * this.direction.z;
    if (dot < 0) {
      return false;
    }
    const temp = pyth - dot * dot;
    return temp <= rr;
  }
  /**
   * If the ray hits a triange
   * @param vertex0 triangle vertex
   * @param vertex1 triangle vertex
   * @param vertex2 triangle vertex
   * @returns intersection information if hit
   */
  intersectsTriangle(vertex0, vertex1, vertex2) {
    const edge1 = _Ray._TmpVector3[0];
    const edge2 = _Ray._TmpVector3[1];
    const pvec = _Ray._TmpVector3[2];
    const tvec = _Ray._TmpVector3[3];
    const qvec = _Ray._TmpVector3[4];
    vertex1.subtractToRef(vertex0, edge1);
    vertex2.subtractToRef(vertex0, edge2);
    Vector3.CrossToRef(this.direction, edge2, pvec);
    const det = Vector3.Dot(edge1, pvec);
    if (det === 0) {
      return null;
    }
    const invdet = 1 / det;
    this.origin.subtractToRef(vertex0, tvec);
    const bv = Vector3.Dot(tvec, pvec) * invdet;
    if (bv < -this.epsilon || bv > 1 + this.epsilon) {
      return null;
    }
    Vector3.CrossToRef(tvec, edge1, qvec);
    const bw = Vector3.Dot(this.direction, qvec) * invdet;
    if (bw < -this.epsilon || bv + bw > 1 + this.epsilon) {
      return null;
    }
    const distance = Vector3.Dot(edge2, qvec) * invdet;
    if (distance > this.length) {
      return null;
    }
    return new IntersectionInfo(1 - bv - bw, bv, distance);
  }
  /**
   * Checks if ray intersects a plane
   * @param plane the plane to check
   * @returns the distance away it was hit
   */
  intersectsPlane(plane) {
    let distance;
    const result1 = Vector3.Dot(plane.normal, this.direction);
    if (Math.abs(result1) < 999999997475243e-21) {
      return null;
    } else {
      const result2 = Vector3.Dot(plane.normal, this.origin);
      distance = (-plane.d - result2) / result1;
      if (distance < 0) {
        if (distance < -999999997475243e-21) {
          return null;
        } else {
          return 0;
        }
      }
      return distance;
    }
  }
  /**
   * Calculate the intercept of a ray on a given axis
   * @param axis to check 'x' | 'y' | 'z'
   * @param offset from axis interception (i.e. an offset of 1y is intercepted above ground)
   * @returns a vector containing the coordinates where 'axis' is equal to zero (else offset), or null if there is no intercept.
   */
  intersectsAxis(axis, offset = 0) {
    switch (axis) {
      case "y": {
        const t = (this.origin.y - offset) / this.direction.y;
        if (t > 0) {
          return null;
        }
        return new Vector3(this.origin.x + this.direction.x * -t, offset, this.origin.z + this.direction.z * -t);
      }
      case "x": {
        const t = (this.origin.x - offset) / this.direction.x;
        if (t > 0) {
          return null;
        }
        return new Vector3(offset, this.origin.y + this.direction.y * -t, this.origin.z + this.direction.z * -t);
      }
      case "z": {
        const t = (this.origin.z - offset) / this.direction.z;
        if (t > 0) {
          return null;
        }
        return new Vector3(this.origin.x + this.direction.x * -t, this.origin.y + this.direction.y * -t, offset);
      }
      default:
        return null;
    }
  }
  /**
   * Checks if ray intersects a mesh. The ray is defined in WORLD space. A mesh triangle can be picked both from its front and back sides,
   * irrespective of orientation.
   * @param mesh the mesh to check
   * @param fastCheck defines if the first intersection will be used (and not the closest)
   * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected
   * @param onlyBoundingInfo defines a boolean indicating if picking should only happen using bounding info (false by default)
   * @param worldToUse defines the world matrix to use to get the world coordinate of the intersection point
   * @param skipBoundingInfo a boolean indicating if we should skip the bounding info check
   * @returns picking info of the intersection
   */
  intersectsMesh(mesh, fastCheck, trianglePredicate, onlyBoundingInfo = false, worldToUse, skipBoundingInfo = false) {
    const tm = TmpVectors.Matrix[0];
    mesh.getWorldMatrix().invertToRef(tm);
    if (this._tmpRay) {
      _Ray.TransformToRef(this, tm, this._tmpRay);
    } else {
      this._tmpRay = _Ray.Transform(this, tm);
    }
    return mesh.intersects(this._tmpRay, fastCheck, trianglePredicate, onlyBoundingInfo, worldToUse, skipBoundingInfo);
  }
  /**
   * Checks if ray intersects a mesh
   * @param meshes the meshes to check
   * @param fastCheck defines if the first intersection will be used (and not the closest)
   * @param results array to store result in
   * @returns Array of picking infos
   */
  intersectsMeshes(meshes, fastCheck, results) {
    if (results) {
      results.length = 0;
    } else {
      results = [];
    }
    for (let i = 0; i < meshes.length; i++) {
      const pickInfo = this.intersectsMesh(meshes[i], fastCheck);
      if (pickInfo.hit) {
        results.push(pickInfo);
      }
    }
    results.sort(this._comparePickingInfo);
    return results;
  }
  _comparePickingInfo(pickingInfoA, pickingInfoB) {
    if (pickingInfoA.distance < pickingInfoB.distance) {
      return -1;
    } else if (pickingInfoA.distance > pickingInfoB.distance) {
      return 1;
    } else {
      return 0;
    }
  }
  /**
   * Intersection test between the ray and a given segment within a given tolerance (threshold)
   * @param sega the first point of the segment to test the intersection against
   * @param segb the second point of the segment to test the intersection against
   * @param threshold the tolerance margin, if the ray doesn't intersect the segment but is close to the given threshold, the intersection is successful
   * @returns the distance from the ray origin to the intersection point if there's intersection, or -1 if there's no intersection
   */
  intersectionSegment(sega, segb, threshold) {
    const o = this.origin;
    const u = TmpVectors.Vector3[0];
    const rsegb = TmpVectors.Vector3[1];
    const v = TmpVectors.Vector3[2];
    const w = TmpVectors.Vector3[3];
    segb.subtractToRef(sega, u);
    this.direction.scaleToRef(_Ray._Rayl, v);
    o.addToRef(v, rsegb);
    sega.subtractToRef(o, w);
    const a = Vector3.Dot(u, u);
    const b = Vector3.Dot(u, v);
    const c = Vector3.Dot(v, v);
    const d = Vector3.Dot(u, w);
    const e = Vector3.Dot(v, w);
    const D = a * c - b * b;
    let sN, sD = D;
    let tN, tD = D;
    if (D < _Ray._Smallnum) {
      sN = 0;
      sD = 1;
      tN = e;
      tD = c;
    } else {
      sN = b * e - c * d;
      tN = a * e - b * d;
      if (sN < 0) {
        sN = 0;
        tN = e;
        tD = c;
      } else if (sN > sD) {
        sN = sD;
        tN = e + b;
        tD = c;
      }
    }
    if (tN < 0) {
      tN = 0;
      if (-d < 0) {
        sN = 0;
      } else if (-d > a) {
        sN = sD;
      } else {
        sN = -d;
        sD = a;
      }
    } else if (tN > tD) {
      tN = tD;
      if (-d + b < 0) {
        sN = 0;
      } else if (-d + b > a) {
        sN = sD;
      } else {
        sN = -d + b;
        sD = a;
      }
    }
    const sc = Math.abs(sN) < _Ray._Smallnum ? 0 : sN / sD;
    const tc = Math.abs(tN) < _Ray._Smallnum ? 0 : tN / tD;
    const qtc = TmpVectors.Vector3[4];
    v.scaleToRef(tc, qtc);
    const qsc = TmpVectors.Vector3[5];
    u.scaleToRef(sc, qsc);
    qsc.addInPlace(w);
    const dP = TmpVectors.Vector3[6];
    qsc.subtractToRef(qtc, dP);
    const isIntersected = tc > 0 && tc <= this.length && dP.lengthSquared() < threshold * threshold;
    if (isIntersected) {
      return qsc.length();
    }
    return -1;
  }
  /**
   * Update the ray from viewport position
   * @param x position
   * @param y y position
   * @param viewportWidth viewport width
   * @param viewportHeight viewport height
   * @param world world matrix
   * @param view view matrix
   * @param projection projection matrix
   * @param enableDistantPicking defines if picking should handle large values for mesh position/scaling (false by default)
   * @returns this ray updated
   */
  update(x, y, viewportWidth, viewportHeight, world, view, projection, enableDistantPicking = false) {
    if (enableDistantPicking) {
      if (!_Ray._RayDistant) {
        _Ray._RayDistant = _Ray.Zero();
      }
      _Ray._RayDistant.unprojectRayToRef(x, y, viewportWidth, viewportHeight, Matrix.IdentityReadOnly, view, projection);
      const tm = TmpVectors.Matrix[0];
      world.invertToRef(tm);
      _Ray.TransformToRef(_Ray._RayDistant, tm, this);
    } else {
      this.unprojectRayToRef(x, y, viewportWidth, viewportHeight, world, view, projection);
    }
    return this;
  }
  // Statics
  /**
   * Creates a ray with origin and direction of 0,0,0
   * @returns the new ray
   */
  static Zero() {
    return new _Ray(Vector3.Zero(), Vector3.Zero());
  }
  /**
   * Creates a new ray from screen space and viewport
   * @param x position
   * @param y y position
   * @param viewportWidth viewport width
   * @param viewportHeight viewport height
   * @param world world matrix
   * @param view view matrix
   * @param projection projection matrix
   * @returns new ray
   */
  static CreateNew(x, y, viewportWidth, viewportHeight, world, view, projection) {
    const result = _Ray.Zero();
    return result.update(x, y, viewportWidth, viewportHeight, world, view, projection);
  }
  /**
   * Function will create a new transformed ray starting from origin and ending at the end point. Ray's length will be set, and ray will be
   * transformed to the given world matrix.
   * @param origin The origin point
   * @param end The end point
   * @param world a matrix to transform the ray to. Default is the identity matrix.
   * @returns the new ray
   */
  static CreateNewFromTo(origin, end, world = Matrix.IdentityReadOnly) {
    const result = new _Ray(new Vector3(0, 0, 0), new Vector3(0, 0, 0));
    return _Ray.CreateFromToToRef(origin, end, result, world);
  }
  /**
   * Function will update a transformed ray starting from origin and ending at the end point. Ray's length will be set, and ray will be
   * transformed to the given world matrix.
   * @param origin The origin point
   * @param end The end point
   * @param result the object to store the result
   * @param world a matrix to transform the ray to. Default is the identity matrix.
   * @returns the ref ray
   */
  static CreateFromToToRef(origin, end, result, world = Matrix.IdentityReadOnly) {
    result.origin.copyFrom(origin);
    const direction = end.subtractToRef(origin, result.direction);
    const length = Math.sqrt(direction.x * direction.x + direction.y * direction.y + direction.z * direction.z);
    result.length = length;
    result.direction.normalize();
    return _Ray.TransformToRef(result, world, result);
  }
  /**
   * Transforms a ray by a matrix
   * @param ray ray to transform
   * @param matrix matrix to apply
   * @returns the resulting new ray
   */
  static Transform(ray, matrix) {
    const result = new _Ray(new Vector3(0, 0, 0), new Vector3(0, 0, 0));
    _Ray.TransformToRef(ray, matrix, result);
    return result;
  }
  /**
   * Transforms a ray by a matrix
   * @param ray ray to transform
   * @param matrix matrix to apply
   * @param result ray to store result in
   * @returns the updated result ray
   */
  static TransformToRef(ray, matrix, result) {
    Vector3.TransformCoordinatesToRef(ray.origin, matrix, result.origin);
    Vector3.TransformNormalToRef(ray.direction, matrix, result.direction);
    result.length = ray.length;
    result.epsilon = ray.epsilon;
    const dir = result.direction;
    const len = dir.length();
    if (!(len === 0 || len === 1)) {
      const num = 1 / len;
      dir.x *= num;
      dir.y *= num;
      dir.z *= num;
      result.length *= len;
    }
    return result;
  }
  /**
   * Unproject a ray from screen space to object space
   * @param sourceX defines the screen space x coordinate to use
   * @param sourceY defines the screen space y coordinate to use
   * @param viewportWidth defines the current width of the viewport
   * @param viewportHeight defines the current height of the viewport
   * @param world defines the world matrix to use (can be set to Identity to go to world space)
   * @param view defines the view matrix to use
   * @param projection defines the projection matrix to use
   */
  unprojectRayToRef(sourceX, sourceY, viewportWidth, viewportHeight, world, view, projection) {
    const matrix = TmpVectors.Matrix[0];
    world.multiplyToRef(view, matrix);
    matrix.multiplyToRef(projection, matrix);
    matrix.invert();
    const engine = EngineStore.LastCreatedEngine;
    const nearScreenSource = TmpVectors.Vector3[0];
    nearScreenSource.x = sourceX / viewportWidth * 2 - 1;
    nearScreenSource.y = -(sourceY / viewportHeight * 2 - 1);
    nearScreenSource.z = (engine == null ? void 0 : engine.useReverseDepthBuffer) ? 1 : (engine == null ? void 0 : engine.isNDCHalfZRange) ? 0 : -1;
    const farScreenSource = TmpVectors.Vector3[1].copyFromFloats(nearScreenSource.x, nearScreenSource.y, 1 - 1e-8);
    const nearVec3 = TmpVectors.Vector3[2];
    const farVec3 = TmpVectors.Vector3[3];
    Vector3._UnprojectFromInvertedMatrixToRef(nearScreenSource, matrix, nearVec3);
    Vector3._UnprojectFromInvertedMatrixToRef(farScreenSource, matrix, farVec3);
    this.origin.copyFrom(nearVec3);
    farVec3.subtractToRef(nearVec3, this.direction);
    this.direction.normalize();
  }
};
Ray._TmpVector3 = BuildArray(6, Vector3.Zero);
Ray._RayDistant = Ray.Zero();
Ray._Smallnum = 1e-8;
Ray._Rayl = 1e9;
function CreatePickingRay(scene, x, y, world, camera, cameraViewSpace = false) {
  const result = Ray.Zero();
  CreatePickingRayToRef(scene, x, y, world, result, camera, cameraViewSpace);
  return result;
}
function CreatePickingRayToRef(scene, x, y, world, result, camera, cameraViewSpace = false, enableDistantPicking = false) {
  const engine = scene.getEngine();
  if (!camera && !(camera = scene.activeCamera)) {
    return scene;
  }
  const cameraViewport = camera.viewport;
  const renderHeight = engine.getRenderHeight();
  const { x: vx, y: vy, width, height } = cameraViewport.toGlobal(engine.getRenderWidth(), renderHeight);
  const levelInv = 1 / engine.getHardwareScalingLevel();
  x = x * levelInv - vx;
  y = y * levelInv - (renderHeight - vy - height);
  result.update(x, y, width, height, world ? world : Matrix.IdentityReadOnly, cameraViewSpace ? Matrix.IdentityReadOnly : camera.getViewMatrix(), camera.getProjectionMatrix(), enableDistantPicking);
  return scene;
}
function CreatePickingRayInCameraSpace(scene, x, y, camera) {
  const result = Ray.Zero();
  CreatePickingRayInCameraSpaceToRef(scene, x, y, result, camera);
  return result;
}
function CreatePickingRayInCameraSpaceToRef(scene, x, y, result, camera) {
  if (!PickingInfo) {
    return scene;
  }
  const engine = scene.getEngine();
  if (!camera && !(camera = scene.activeCamera)) {
    throw new Error("Active camera not set");
  }
  const cameraViewport = camera.viewport;
  const renderHeight = engine.getRenderHeight();
  const { x: vx, y: vy, width, height } = cameraViewport.toGlobal(engine.getRenderWidth(), renderHeight);
  const identity = Matrix.Identity();
  const levelInv = 1 / engine.getHardwareScalingLevel();
  x = x * levelInv - vx;
  y = y * levelInv - (renderHeight - vy - height);
  result.update(x, y, width, height, identity, identity, camera.getProjectionMatrix());
  return scene;
}
function InternalPickForMesh(pickingInfo, rayFunction, mesh, world, fastCheck, onlyBoundingInfo, trianglePredicate, skipBoundingInfo) {
  const ray = rayFunction(world, mesh.enableDistantPicking);
  const result = mesh.intersects(ray, fastCheck, trianglePredicate, onlyBoundingInfo, world, skipBoundingInfo);
  if (!result || !result.hit) {
    return null;
  }
  if (!fastCheck && pickingInfo != null && result.distance >= pickingInfo.distance) {
    return null;
  }
  return result;
}
function InternalPick(scene, rayFunction, predicate, fastCheck, onlyBoundingInfo, trianglePredicate) {
  let pickingInfo = null;
  const computeWorldMatrixForCamera = !!(scene.activeCameras && scene.activeCameras.length > 1 && scene.cameraToUseForPointers !== scene.activeCamera);
  const currentCamera = scene.cameraToUseForPointers || scene.activeCamera;
  const picker = PickingCustomization.internalPickerForMesh || InternalPickForMesh;
  for (let meshIndex = 0; meshIndex < scene.meshes.length; meshIndex++) {
    const mesh = scene.meshes[meshIndex];
    if (predicate) {
      if (!predicate(mesh, -1)) {
        continue;
      }
    } else if (!mesh.isEnabled() || !mesh.isVisible || !mesh.isPickable) {
      continue;
    }
    const forceCompute = computeWorldMatrixForCamera && mesh.isWorldMatrixCameraDependent();
    const world = mesh.computeWorldMatrix(forceCompute, currentCamera);
    if (mesh.hasThinInstances && mesh.thinInstanceEnablePicking) {
      const result = picker(pickingInfo, rayFunction, mesh, world, true, true, trianglePredicate);
      if (result) {
        if (onlyBoundingInfo) {
          return result;
        }
        const tmpMatrix = TmpVectors.Matrix[1];
        const thinMatrices = mesh.thinInstanceGetWorldMatrices();
        for (let index = 0; index < thinMatrices.length; index++) {
          if (predicate && !predicate(mesh, index)) {
            continue;
          }
          const thinMatrix = thinMatrices[index];
          thinMatrix.multiplyToRef(world, tmpMatrix);
          const result2 = picker(pickingInfo, rayFunction, mesh, tmpMatrix, fastCheck, onlyBoundingInfo, trianglePredicate, true);
          if (result2) {
            pickingInfo = result2;
            pickingInfo.thinInstanceIndex = index;
            if (fastCheck) {
              return pickingInfo;
            }
          }
        }
      }
    } else {
      const result = picker(pickingInfo, rayFunction, mesh, world, fastCheck, onlyBoundingInfo, trianglePredicate);
      if (result) {
        pickingInfo = result;
        if (fastCheck) {
          return pickingInfo;
        }
      }
    }
  }
  return pickingInfo || new PickingInfo();
}
function InternalMultiPick(scene, rayFunction, predicate, trianglePredicate) {
  if (!PickingInfo) {
    return null;
  }
  const pickingInfos = [];
  const computeWorldMatrixForCamera = !!(scene.activeCameras && scene.activeCameras.length > 1 && scene.cameraToUseForPointers !== scene.activeCamera);
  const currentCamera = scene.cameraToUseForPointers || scene.activeCamera;
  const picker = PickingCustomization.internalPickerForMesh || InternalPickForMesh;
  for (let meshIndex = 0; meshIndex < scene.meshes.length; meshIndex++) {
    const mesh = scene.meshes[meshIndex];
    if (predicate) {
      if (!predicate(mesh, -1)) {
        continue;
      }
    } else if (!mesh.isEnabled() || !mesh.isVisible || !mesh.isPickable) {
      continue;
    }
    const forceCompute = computeWorldMatrixForCamera && mesh.isWorldMatrixCameraDependent();
    const world = mesh.computeWorldMatrix(forceCompute, currentCamera);
    if (mesh.hasThinInstances && mesh.thinInstanceEnablePicking) {
      const result = picker(null, rayFunction, mesh, world, true, true, trianglePredicate);
      if (result) {
        const tmpMatrix = TmpVectors.Matrix[1];
        const thinMatrices = mesh.thinInstanceGetWorldMatrices();
        for (let index = 0; index < thinMatrices.length; index++) {
          if (predicate && !predicate(mesh, index)) {
            continue;
          }
          const thinMatrix = thinMatrices[index];
          thinMatrix.multiplyToRef(world, tmpMatrix);
          const result2 = picker(null, rayFunction, mesh, tmpMatrix, false, false, trianglePredicate, true);
          if (result2) {
            result2.thinInstanceIndex = index;
            pickingInfos.push(result2);
          }
        }
      }
    } else {
      const result = picker(null, rayFunction, mesh, world, false, false, trianglePredicate);
      if (result) {
        pickingInfos.push(result);
      }
    }
  }
  return pickingInfos;
}
function PickWithBoundingInfo(scene, x, y, predicate, fastCheck, camera) {
  if (!PickingInfo) {
    return null;
  }
  const result = InternalPick(scene, (world) => {
    if (!scene._tempPickingRay) {
      scene._tempPickingRay = Ray.Zero();
    }
    CreatePickingRayToRef(scene, x, y, world, scene._tempPickingRay, camera || null);
    return scene._tempPickingRay;
  }, predicate, fastCheck, true);
  if (result) {
    result.ray = CreatePickingRay(scene, x, y, Matrix.Identity(), camera || null);
  }
  return result;
}
function Pick(scene, x, y, predicate, fastCheck, camera, trianglePredicate, _enableDistantPicking = false) {
  const result = InternalPick(scene, (world, enableDistantPicking) => {
    if (!scene._tempPickingRay) {
      scene._tempPickingRay = Ray.Zero();
    }
    CreatePickingRayToRef(scene, x, y, world, scene._tempPickingRay, camera || null, false, enableDistantPicking);
    return scene._tempPickingRay;
  }, predicate, fastCheck, false, trianglePredicate);
  if (result) {
    result.ray = CreatePickingRay(scene, x, y, Matrix.Identity(), camera || null);
  }
  return result;
}
function PickWithRay(scene, ray, predicate, fastCheck, trianglePredicate) {
  const result = InternalPick(scene, (world) => {
    if (!scene._pickWithRayInverseMatrix) {
      scene._pickWithRayInverseMatrix = Matrix.Identity();
    }
    world.invertToRef(scene._pickWithRayInverseMatrix);
    if (!scene._cachedRayForTransform) {
      scene._cachedRayForTransform = Ray.Zero();
    }
    Ray.TransformToRef(ray, scene._pickWithRayInverseMatrix, scene._cachedRayForTransform);
    return scene._cachedRayForTransform;
  }, predicate, fastCheck, false, trianglePredicate);
  if (result) {
    result.ray = ray;
  }
  return result;
}
function MultiPick(scene, x, y, predicate, camera, trianglePredicate) {
  return InternalMultiPick(scene, (world) => CreatePickingRay(scene, x, y, world, camera || null), predicate, trianglePredicate);
}
function MultiPickWithRay(scene, ray, predicate, trianglePredicate) {
  return InternalMultiPick(scene, (world) => {
    if (!scene._pickWithRayInverseMatrix) {
      scene._pickWithRayInverseMatrix = Matrix.Identity();
    }
    world.invertToRef(scene._pickWithRayInverseMatrix);
    if (!scene._cachedRayForTransform) {
      scene._cachedRayForTransform = Ray.Zero();
    }
    Ray.TransformToRef(ray, scene._pickWithRayInverseMatrix, scene._cachedRayForTransform);
    return scene._cachedRayForTransform;
  }, predicate, trianglePredicate);
}
function GetForwardRayToRef(camera, refRay, length = 100, transform, origin) {
  if (!transform) {
    transform = camera.getWorldMatrix();
  }
  refRay.length = length;
  if (origin) {
    refRay.origin.copyFrom(origin);
  } else {
    refRay.origin.copyFrom(camera.position);
  }
  const forward = TmpVectors.Vector3[2];
  forward.set(0, 0, camera._scene.useRightHandedSystem ? -1 : 1);
  const worldForward = TmpVectors.Vector3[3];
  Vector3.TransformNormalToRef(forward, transform, worldForward);
  Vector3.NormalizeToRef(worldForward, refRay.direction);
  return refRay;
}
function AddRayExtensions(sceneClass, cameraClass) {
  if (cameraClass) {
    cameraClass.prototype.getForwardRay = function(length = 100, transform, origin) {
      return GetForwardRayToRef(this, new Ray(Vector3.Zero(), Vector3.Zero(), length), length, transform, origin);
    };
    cameraClass.prototype.getForwardRayToRef = function(refRay, length = 100, transform, origin) {
      return GetForwardRayToRef(this, refRay, length, transform, origin);
    };
  }
  if (!sceneClass) {
    return;
  }
  _ImportHelper._IsPickingAvailable = true;
  sceneClass.prototype.createPickingRay = function(x, y, world, camera, cameraViewSpace = false) {
    return CreatePickingRay(this, x, y, world, camera, cameraViewSpace);
  };
}

// node_modules/@babylonjs/core/Culling/ray.js
AddRayExtensions(Scene, Camera);
Scene.prototype.createPickingRayToRef = function(x, y, world, result, camera, cameraViewSpace = false, enableDistantPicking = false) {
  return CreatePickingRayToRef(this, x, y, world, result, camera, cameraViewSpace, enableDistantPicking);
};
Scene.prototype.createPickingRayInCameraSpace = function(x, y, camera) {
  return CreatePickingRayInCameraSpace(this, x, y, camera);
};
Scene.prototype.createPickingRayInCameraSpaceToRef = function(x, y, result, camera) {
  return CreatePickingRayInCameraSpaceToRef(this, x, y, result, camera);
};
Scene.prototype.pickWithBoundingInfo = function(x, y, predicate, fastCheck, camera) {
  return PickWithBoundingInfo(this, x, y, predicate, fastCheck, camera);
};
Scene.prototype.pick = function(x, y, predicate, fastCheck, camera, trianglePredicate, _enableDistantPicking = false) {
  return Pick(this, x, y, predicate, fastCheck, camera, trianglePredicate, _enableDistantPicking);
};
Scene.prototype.pickWithRay = function(ray, predicate, fastCheck, trianglePredicate) {
  return PickWithRay(this, ray, predicate, fastCheck, trianglePredicate);
};
Scene.prototype.multiPick = function(x, y, predicate, camera, trianglePredicate) {
  return MultiPick(this, x, y, predicate, camera, trianglePredicate);
};
Scene.prototype.multiPickWithRay = function(ray, predicate, trianglePredicate) {
  return MultiPickWithRay(this, ray, predicate, trianglePredicate);
};

// node_modules/@babylonjs/core/Behaviors/Meshes/pointerDragBehavior.js
var PointerDragBehavior = class _PointerDragBehavior {
  /**
   * Get or set the currentDraggingPointerId
   * @deprecated Please use currentDraggingPointerId instead
   */
  get currentDraggingPointerID() {
    return this.currentDraggingPointerId;
  }
  set currentDraggingPointerID(currentDraggingPointerID) {
    this.currentDraggingPointerId = currentDraggingPointerID;
  }
  /**
   *  If the drag behavior will react to drag events (Default: true)
   */
  set enabled(value) {
    if (value != this._enabled) {
      this.onEnabledObservable.notifyObservers(value);
    }
    this._enabled = value;
  }
  get enabled() {
    return this._enabled;
  }
  /**
   * Gets the options used by the behavior
   */
  get options() {
    return this._options;
  }
  /**
   * Sets the options used by the behavior
   */
  set options(options) {
    this._options = options;
  }
  /**
   * Creates a pointer drag behavior that can be attached to a mesh
   * @param options The drag axis or normal of the plane that will be dragged across. If no options are specified the drag plane will always face the ray's origin (eg. camera)
   * @param options.dragAxis
   * @param options.dragPlaneNormal
   */
  constructor(options) {
    this._useAlternatePickedPointAboveMaxDragAngleDragSpeed = -1.1;
    this._activeDragButton = -1;
    this.maxDragAngle = 0;
    this.dragButtons = [0, 1, 2];
    this._useAlternatePickedPointAboveMaxDragAngle = false;
    this.currentDraggingPointerId = -1;
    this.dragging = false;
    this.dragDeltaRatio = 0.2;
    this.updateDragPlane = true;
    this._debugMode = false;
    this._moving = false;
    this.onDragObservable = new Observable();
    this.onDragStartObservable = new Observable();
    this.onDragEndObservable = new Observable();
    this.onEnabledObservable = new Observable();
    this.moveAttached = true;
    this._enabled = true;
    this.startAndReleaseDragOnPointerEvents = true;
    this.detachCameraControls = true;
    this.useObjectOrientationForDragging = true;
    this.validateDrag = (target) => {
      return true;
    };
    this._tmpVector = new Vector3(0, 0, 0);
    this._alternatePickedPoint = new Vector3(0, 0, 0);
    this._worldDragAxis = new Vector3(0, 0, 0);
    this._targetPosition = new Vector3(0, 0, 0);
    this._attachedToElement = false;
    this._startDragRay = new Ray(new Vector3(), new Vector3());
    this._lastPointerRay = {};
    this._dragDelta = new Vector3();
    this._pointA = new Vector3(0, 0, 0);
    this._pointC = new Vector3(0, 0, 0);
    this._localAxis = new Vector3(0, 0, 0);
    this._lookAt = new Vector3(0, 0, 0);
    this._options = options ? options : {};
    let optionCount = 0;
    if (this._options.dragAxis) {
      optionCount++;
    }
    if (this._options.dragPlaneNormal) {
      optionCount++;
    }
    if (optionCount > 1) {
      throw "Multiple drag modes specified in dragBehavior options. Only one expected";
    }
  }
  /**
   *  The name of the behavior
   */
  get name() {
    return "PointerDrag";
  }
  /**
   *  Initializes the behavior
   */
  init() {
  }
  /**
   * Attaches the drag behavior the passed in mesh
   * @param ownerNode The mesh that will be dragged around once attached
   * @param predicate Predicate to use for pick filtering
   */
  attach(ownerNode, predicate) {
    this._scene = ownerNode.getScene();
    ownerNode.isNearGrabbable = true;
    this.attachedNode = ownerNode;
    if (!_PointerDragBehavior._PlaneScene) {
      if (this._debugMode) {
        _PointerDragBehavior._PlaneScene = this._scene;
      } else {
        _PointerDragBehavior._PlaneScene = new Scene(this._scene.getEngine(), { virtual: true });
        _PointerDragBehavior._PlaneScene.detachControl();
        this._scene.onDisposeObservable.addOnce(() => {
          _PointerDragBehavior._PlaneScene.dispose();
          _PointerDragBehavior._PlaneScene = null;
        });
      }
    }
    this._dragPlane = CreatePlane("pointerDragPlane", { size: this._debugMode ? 1 : 1e4, updatable: false, sideOrientation: Mesh.DOUBLESIDE }, _PointerDragBehavior._PlaneScene);
    this.lastDragPosition = new Vector3(0, 0, 0);
    const pickPredicate = predicate ? predicate : (m) => {
      return this.attachedNode == m || m.isDescendantOf(this.attachedNode);
    };
    this._pointerObserver = this._scene.onPointerObservable.add((pointerInfo) => {
      if (!this.enabled) {
        if (this._attachedToElement) {
          this.releaseDrag();
        }
        return;
      }
      if (pointerInfo.type == PointerEventTypes.POINTERDOWN) {
        if (this.startAndReleaseDragOnPointerEvents && !this.dragging && pointerInfo.pickInfo && pointerInfo.pickInfo.hit && pointerInfo.pickInfo.pickedMesh && pointerInfo.pickInfo.pickedPoint && pointerInfo.pickInfo.ray && pickPredicate(pointerInfo.pickInfo.pickedMesh)) {
          if (this._activeDragButton === -1 && this.dragButtons.indexOf(pointerInfo.event.button) !== -1) {
            this._activeDragButton = pointerInfo.event.button;
            this._activePointerInfo = pointerInfo;
            this._startDrag(pointerInfo.event.pointerId, pointerInfo.pickInfo.ray, pointerInfo.pickInfo.pickedPoint);
          }
        }
      } else if (pointerInfo.type == PointerEventTypes.POINTERUP) {
        if (this.startAndReleaseDragOnPointerEvents && this.currentDraggingPointerId == pointerInfo.event.pointerId && (this._activeDragButton === pointerInfo.event.button || this._activeDragButton === -1)) {
          this.releaseDrag();
        }
      } else if (pointerInfo.type == PointerEventTypes.POINTERMOVE) {
        const pointerId = pointerInfo.event.pointerId;
        if (this.currentDraggingPointerId === _PointerDragBehavior._AnyMouseId && pointerId !== _PointerDragBehavior._AnyMouseId) {
          const evt = pointerInfo.event;
          const isMouseEvent = evt.pointerType === "mouse" || !this._scene.getEngine().hostInformation.isMobile && evt instanceof MouseEvent;
          if (isMouseEvent) {
            if (this._lastPointerRay[this.currentDraggingPointerId]) {
              this._lastPointerRay[pointerId] = this._lastPointerRay[this.currentDraggingPointerId];
              delete this._lastPointerRay[this.currentDraggingPointerId];
            }
            this.currentDraggingPointerId = pointerId;
          }
        }
        if (!this._lastPointerRay[pointerId]) {
          this._lastPointerRay[pointerId] = new Ray(new Vector3(), new Vector3());
        }
        if (pointerInfo.pickInfo && pointerInfo.pickInfo.ray) {
          this._lastPointerRay[pointerId].origin.copyFrom(pointerInfo.pickInfo.ray.origin);
          this._lastPointerRay[pointerId].direction.copyFrom(pointerInfo.pickInfo.ray.direction);
          if (this.currentDraggingPointerId == pointerId && this.dragging) {
            this._moveDrag(pointerInfo.pickInfo.ray);
          }
        }
      }
    });
    this._beforeRenderObserver = this._scene.onBeforeRenderObservable.add(() => {
      if (this._moving && this.moveAttached) {
        let needMatrixUpdate = false;
        PivotTools._RemoveAndStorePivotPoint(this.attachedNode);
        this._targetPosition.subtractToRef(this.attachedNode.absolutePosition, this._tmpVector);
        this._tmpVector.scaleInPlace(this.dragDeltaRatio);
        this.attachedNode.getAbsolutePosition().addToRef(this._tmpVector, this._tmpVector);
        if (this.validateDrag(this._tmpVector)) {
          this.attachedNode.setAbsolutePosition(this._tmpVector);
          needMatrixUpdate = true;
        }
        PivotTools._RestorePivotPoint(this.attachedNode);
        if (needMatrixUpdate) {
          this.attachedNode.computeWorldMatrix();
        }
      }
    });
  }
  /**
   * Force release the drag action by code.
   */
  releaseDrag() {
    if (this.dragging) {
      this.dragging = false;
      this.onDragEndObservable.notifyObservers({ dragPlanePoint: this.lastDragPosition, pointerId: this.currentDraggingPointerId, pointerInfo: this._activePointerInfo });
    }
    this.currentDraggingPointerId = -1;
    this._activeDragButton = -1;
    this._activePointerInfo = null;
    this._moving = false;
    if (this.detachCameraControls && this._attachedToElement && this._scene.activeCamera && !this._scene.activeCamera.leftCamera) {
      if (this._scene.activeCamera.getClassName() === "ArcRotateCamera") {
        const arcRotateCamera = this._scene.activeCamera;
        arcRotateCamera.attachControl(arcRotateCamera.inputs ? arcRotateCamera.inputs.noPreventDefault : true, arcRotateCamera._useCtrlForPanning, arcRotateCamera._panningMouseButton);
      } else {
        this._scene.activeCamera.attachControl(this._scene.activeCamera.inputs ? this._scene.activeCamera.inputs.noPreventDefault : true);
      }
      this._attachedToElement = false;
    }
  }
  /**
   * Simulates the start of a pointer drag event on the behavior
   * @param pointerId pointerID of the pointer that should be simulated (Default: Any mouse pointer ID)
   * @param fromRay initial ray of the pointer to be simulated (Default: Ray from camera to attached mesh)
   * @param startPickedPoint picked point of the pointer to be simulated (Default: attached mesh position)
   */
  startDrag(pointerId = _PointerDragBehavior._AnyMouseId, fromRay, startPickedPoint) {
    this._startDrag(pointerId, fromRay, startPickedPoint);
    let lastRay = this._lastPointerRay[pointerId];
    if (pointerId === _PointerDragBehavior._AnyMouseId) {
      lastRay = this._lastPointerRay[Object.keys(this._lastPointerRay)[0]];
    }
    if (lastRay) {
      this._moveDrag(lastRay);
    }
  }
  _startDrag(pointerId, fromRay, startPickedPoint) {
    if (!this._scene.activeCamera || this.dragging || !this.attachedNode) {
      return;
    }
    PivotTools._RemoveAndStorePivotPoint(this.attachedNode);
    if (fromRay) {
      this._startDragRay.direction.copyFrom(fromRay.direction);
      this._startDragRay.origin.copyFrom(fromRay.origin);
    } else {
      this._startDragRay.origin.copyFrom(this._scene.activeCamera.position);
      this.attachedNode.getWorldMatrix().getTranslationToRef(this._tmpVector);
      this._tmpVector.subtractToRef(this._scene.activeCamera.position, this._startDragRay.direction);
    }
    this._updateDragPlanePosition(this._startDragRay, startPickedPoint ? startPickedPoint : this._tmpVector);
    const pickedPoint = this._pickWithRayOnDragPlane(this._startDragRay);
    if (pickedPoint) {
      this.dragging = true;
      this.currentDraggingPointerId = pointerId;
      this.lastDragPosition.copyFrom(pickedPoint);
      this.onDragStartObservable.notifyObservers({ dragPlanePoint: pickedPoint, pointerId: this.currentDraggingPointerId, pointerInfo: this._activePointerInfo });
      this._targetPosition.copyFrom(this.attachedNode.getAbsolutePosition());
      if (this.detachCameraControls && this._scene.activeCamera && this._scene.activeCamera.inputs && !this._scene.activeCamera.leftCamera) {
        if (this._scene.activeCamera.inputs.attachedToElement) {
          this._scene.activeCamera.detachControl();
          this._attachedToElement = true;
        } else {
          this._attachedToElement = false;
        }
      }
    } else {
      this.releaseDrag();
    }
    PivotTools._RestorePivotPoint(this.attachedNode);
  }
  _moveDrag(ray) {
    this._moving = true;
    const pickedPoint = this._pickWithRayOnDragPlane(ray);
    if (pickedPoint) {
      PivotTools._RemoveAndStorePivotPoint(this.attachedNode);
      if (this.updateDragPlane) {
        this._updateDragPlanePosition(ray, pickedPoint);
      }
      let dragLength = 0;
      if (this._options.dragAxis) {
        this.useObjectOrientationForDragging ? Vector3.TransformCoordinatesToRef(this._options.dragAxis, this.attachedNode.getWorldMatrix().getRotationMatrix(), this._worldDragAxis) : this._worldDragAxis.copyFrom(this._options.dragAxis);
        pickedPoint.subtractToRef(this.lastDragPosition, this._tmpVector);
        dragLength = Vector3.Dot(this._tmpVector, this._worldDragAxis);
        this._worldDragAxis.scaleToRef(dragLength, this._dragDelta);
      } else {
        dragLength = this._dragDelta.length();
        pickedPoint.subtractToRef(this.lastDragPosition, this._dragDelta);
      }
      this._targetPosition.addInPlace(this._dragDelta);
      this.onDragObservable.notifyObservers({
        dragDistance: dragLength,
        delta: this._dragDelta,
        dragPlanePoint: pickedPoint,
        dragPlaneNormal: this._dragPlane.forward,
        pointerId: this.currentDraggingPointerId,
        pointerInfo: this._activePointerInfo
      });
      this.lastDragPosition.copyFrom(pickedPoint);
      PivotTools._RestorePivotPoint(this.attachedNode);
    }
  }
  _pickWithRayOnDragPlane(ray) {
    if (!ray) {
      return null;
    }
    let angle = Math.acos(Vector3.Dot(this._dragPlane.forward, ray.direction));
    if (angle > Math.PI / 2) {
      angle = Math.PI - angle;
    }
    if (this.maxDragAngle > 0 && angle > this.maxDragAngle) {
      if (this._useAlternatePickedPointAboveMaxDragAngle) {
        this._tmpVector.copyFrom(ray.direction);
        this.attachedNode.absolutePosition.subtractToRef(ray.origin, this._alternatePickedPoint);
        this._alternatePickedPoint.normalize();
        this._alternatePickedPoint.scaleInPlace(this._useAlternatePickedPointAboveMaxDragAngleDragSpeed * Vector3.Dot(this._alternatePickedPoint, this._tmpVector));
        this._tmpVector.addInPlace(this._alternatePickedPoint);
        const dot = Vector3.Dot(this._dragPlane.forward, this._tmpVector);
        this._dragPlane.forward.scaleToRef(-dot, this._alternatePickedPoint);
        this._alternatePickedPoint.addInPlace(this._tmpVector);
        this._alternatePickedPoint.addInPlace(this.attachedNode.absolutePosition);
        return this._alternatePickedPoint;
      } else {
        return null;
      }
    }
    const planeNormal = this._dragPlane.forward;
    const planePosition = this._dragPlane.position;
    const dotProduct = ray.direction.dot(planeNormal);
    if (Math.abs(dotProduct) < Epsilon) {
      return null;
    }
    planePosition.subtractToRef(ray.origin, TmpVectors.Vector3[0]);
    const t = TmpVectors.Vector3[0].dot(planeNormal) / dotProduct;
    if (t < 0) {
      return null;
    }
    ray.direction.scaleToRef(t, TmpVectors.Vector3[0]);
    const intersectionPoint = ray.origin.add(TmpVectors.Vector3[0]);
    return intersectionPoint;
  }
  // Position the drag plane based on the attached mesh position, for single axis rotate the plane along the axis to face the camera
  _updateDragPlanePosition(ray, dragPlanePosition) {
    this._pointA.copyFrom(dragPlanePosition);
    if (this._options.dragAxis) {
      this.useObjectOrientationForDragging ? Vector3.TransformCoordinatesToRef(this._options.dragAxis, this.attachedNode.getWorldMatrix().getRotationMatrix(), this._localAxis) : this._localAxis.copyFrom(this._options.dragAxis);
      ray.origin.subtractToRef(this._pointA, this._pointC);
      this._pointC.normalize();
      if (Math.abs(Vector3.Dot(this._localAxis, this._pointC)) > 0.999) {
        if (Math.abs(Vector3.Dot(Vector3.UpReadOnly, this._pointC)) > 0.999) {
          this._lookAt.copyFrom(Vector3.Right());
        } else {
          this._lookAt.copyFrom(Vector3.UpReadOnly);
        }
      } else {
        Vector3.CrossToRef(this._localAxis, this._pointC, this._lookAt);
        Vector3.CrossToRef(this._localAxis, this._lookAt, this._lookAt);
        this._lookAt.normalize();
      }
      this._dragPlane.position.copyFrom(this._pointA);
      this._pointA.addToRef(this._lookAt, this._lookAt);
      this._dragPlane.lookAt(this._lookAt);
    } else if (this._options.dragPlaneNormal) {
      this.useObjectOrientationForDragging ? Vector3.TransformCoordinatesToRef(this._options.dragPlaneNormal, this.attachedNode.getWorldMatrix().getRotationMatrix(), this._localAxis) : this._localAxis.copyFrom(this._options.dragPlaneNormal);
      this._dragPlane.position.copyFrom(this._pointA);
      this._pointA.addToRef(this._localAxis, this._lookAt);
      this._dragPlane.lookAt(this._lookAt);
    } else {
      this._dragPlane.position.copyFrom(this._pointA);
      this._dragPlane.lookAt(ray.origin);
    }
    this._dragPlane.position.copyFrom(this.attachedNode.getAbsolutePosition());
    this._dragPlane.computeWorldMatrix(true);
  }
  /**
   *  Detaches the behavior from the mesh
   */
  detach() {
    this._lastPointerRay = {};
    if (this.attachedNode) {
      this.attachedNode.isNearGrabbable = false;
    }
    if (this._pointerObserver) {
      this._scene.onPointerObservable.remove(this._pointerObserver);
    }
    if (this._beforeRenderObserver) {
      this._scene.onBeforeRenderObservable.remove(this._beforeRenderObserver);
    }
    if (this._dragPlane) {
      this._dragPlane.dispose();
    }
    this.releaseDrag();
  }
};
PointerDragBehavior._AnyMouseId = -2;

// node_modules/@babylonjs/gui/3D/controls/holographicSlate.js
var HolographicSlate = class _HolographicSlate extends ContentDisplay3D {
  /**
   * Regroups all mesh behaviors for the slate
   */
  get defaultBehavior() {
    return this._defaultBehavior;
  }
  /**
   * 2D dimensions of the slate
   */
  get dimensions() {
    return this._dimensions;
  }
  set dimensions(value) {
    let scale = 1;
    if (value.x < this.minDimensions.x || value.y < this.minDimensions.y) {
      const newRatio = value.x / value.y;
      const minRatio = this.minDimensions.x / this.minDimensions.y;
      if (minRatio > newRatio) {
        scale = this.minDimensions.x / value.x;
      } else {
        scale = this.minDimensions.y / value.y;
      }
    }
    this._dimensions.copyFrom(value).scaleInPlace(scale);
    this._updatePivot();
    this._positionElements();
  }
  /**
   * Height of the title bar component
   */
  get titleBarHeight() {
    return this._titleBarHeight;
  }
  set titleBarHeight(value) {
    this._titleBarHeight = value;
  }
  /**
   * Rendering ground id of all the meshes
   */
  set renderingGroupId(id) {
    this._titleBar.renderingGroupId = id;
    this._titleBarTitle.renderingGroupId = id;
    this._contentPlate.renderingGroupId = id;
    this._backPlate.renderingGroupId = id;
  }
  get renderingGroupId() {
    return this._titleBar.renderingGroupId;
  }
  /**
   * The title text displayed at the top of the slate
   */
  set title(title) {
    this._titleText = title;
    if (this._titleTextComponent) {
      this._titleTextComponent.text = title;
    }
  }
  get title() {
    return this._titleText;
  }
  /**
   * Creates a new slate
   * @param name defines the control name
   */
  constructor(name22) {
    super(name22);
    this.titleBarMargin = 5e-3;
    this.origin = new Vector3(0, 0, 0);
    this._dimensions = new Vector2(21.875, 12.5);
    this._titleBarHeight = 0.625;
    this._titleText = "";
    this.fitContentToDimensions = false;
    this._contentScaleRatio = 1;
    this.minDimensions = new Vector2(15.625, 6.25);
    this.defaultDimensions = this._dimensions.clone();
    this._followButton = new TouchHolographicButton("followButton" + this.name);
    this._followButton.isToggleButton = true;
    this._closeButton = new TouchHolographicButton("closeButton" + this.name);
    this._contentViewport = new Viewport(0, 0, 1, 1);
    this._contentDragBehavior = new PointerDragBehavior({
      dragPlaneNormal: new Vector3(0, 0, -1)
    });
  }
  /**
   * Apply the facade texture (created from the content property).
   * This function can be overloaded by child classes
   * @param facadeTexture defines the AdvancedDynamicTexture to use
   */
  _applyFacade(facadeTexture) {
    this._contentMaterial.albedoTexture = facadeTexture;
    this._resetContentPositionAndZoom();
    this._applyContentViewport();
    facadeTexture.attachToMesh(this._contentPlate, true);
  }
  _addControl(control) {
    control._host = this._host;
    if (this._host.utilityLayer) {
      control._prepareNode(this._host.utilityLayer.utilityLayerScene);
    }
  }
  _getTypeName() {
    return "HolographicSlate";
  }
  /**
   * @internal
   */
  _positionElements() {
    const followButton = this._followButton;
    const closeButton = this._closeButton;
    const titleBar = this._titleBar;
    const titleBarTitle = this._titleBarTitle;
    const contentPlate = this._contentPlate;
    const backPlate = this._backPlate;
    if (followButton && closeButton && titleBar) {
      closeButton.scaling.setAll(this.titleBarHeight);
      followButton.scaling.setAll(this.titleBarHeight);
      closeButton.position.copyFromFloats(this.dimensions.x - this.titleBarHeight / 2, -this.titleBarHeight / 2, 0).addInPlace(this.origin);
      followButton.position.copyFromFloats(this.dimensions.x - 3 * this.titleBarHeight / 2, -this.titleBarHeight / 2, 0).addInPlace(this.origin);
      const contentPlateHeight = this.dimensions.y - this.titleBarHeight - this.titleBarMargin;
      const rightHandScene = contentPlate.getScene().useRightHandedSystem;
      titleBar.scaling.set(this.dimensions.x, this.titleBarHeight, Epsilon);
      titleBarTitle.scaling.set(this.dimensions.x - 2 * this.titleBarHeight, this.titleBarHeight, Epsilon);
      contentPlate.scaling.copyFromFloats(this.dimensions.x, contentPlateHeight, Epsilon);
      backPlate.scaling.copyFromFloats(this.dimensions.x, contentPlateHeight, Epsilon);
      titleBar.position.copyFromFloats(this.dimensions.x / 2, -(this.titleBarHeight / 2), 0).addInPlace(this.origin);
      titleBarTitle.position.copyFromFloats(this.dimensions.x / 2 - this.titleBarHeight, -(this.titleBarHeight / 2), rightHandScene ? Epsilon : -Epsilon).addInPlace(this.origin);
      contentPlate.position.copyFromFloats(this.dimensions.x / 2, -(this.titleBarHeight + this.titleBarMargin + contentPlateHeight / 2), 0).addInPlace(this.origin);
      backPlate.position.copyFromFloats(this.dimensions.x / 2, -(this.titleBarHeight + this.titleBarMargin + contentPlateHeight / 2), rightHandScene ? -Epsilon : Epsilon).addInPlace(this.origin);
      this._titleTextComponent.host.scaleTo(_HolographicSlate._DEFAULT_TEXT_RESOLUTION_Y * titleBarTitle.scaling.x / titleBarTitle.scaling.y, _HolographicSlate._DEFAULT_TEXT_RESOLUTION_Y);
      const aspectRatio = this.dimensions.x / contentPlateHeight;
      this._contentViewport.width = this._contentScaleRatio;
      this._contentViewport.height = this._contentScaleRatio / aspectRatio;
      this._applyContentViewport();
      if (this._gizmo) {
        this._gizmo.updateBoundingBox();
      }
    }
  }
  _applyContentViewport() {
    var _a;
    if (((_a = this._contentPlate) == null ? void 0 : _a.material) && this._contentPlate.material.albedoTexture) {
      const tex = this._contentPlate.material.albedoTexture;
      tex.uScale = this._contentScaleRatio;
      tex.vScale = this.fitContentToDimensions ? this._contentScaleRatio : this._contentScaleRatio / this._contentViewport.width * this._contentViewport.height;
      tex.uOffset = this._contentViewport.x;
      tex.vOffset = this._contentViewport.y;
    }
  }
  _resetContentPositionAndZoom() {
    this._contentViewport.x = 0;
    this._contentViewport.y = 0;
    this._contentScaleRatio = 1;
  }
  /**
   * @internal
   */
  _updatePivot() {
    if (!this.mesh) {
      return;
    }
    const center = new Vector3(this.dimensions.x * 0.5, -this.dimensions.y * 0.5, Epsilon);
    center.addInPlace(this.origin);
    center.z = 0;
    const origin = new Vector3(0, 0, 0);
    Vector3.TransformCoordinatesToRef(origin, this.mesh.computeWorldMatrix(true), origin);
    this.mesh.setPivotPoint(center);
    const origin2 = new Vector3(0, 0, 0);
    Vector3.TransformCoordinatesToRef(origin2, this.mesh.computeWorldMatrix(true), origin2);
    this.mesh.position.addInPlace(origin).subtractInPlace(origin2);
  }
  // Mesh association
  _createNode(scene) {
    const node = new Mesh("slate_" + this.name, scene);
    this._titleBar = CreateBox("titleBar_" + this.name, { size: 1 }, scene);
    this._titleBarTitle = CreatePlane("titleText_" + this.name, { size: 1 }, scene);
    this._titleBarTitle.parent = node;
    this._titleBarTitle.isPickable = false;
    const adt = AdvancedDynamicTexture.CreateForMesh(this._titleBarTitle);
    this._titleTextComponent = new TextBlock("titleText_" + this.name, this._titleText);
    this._titleTextComponent.textWrapping = 2;
    this._titleTextComponent.textHorizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;
    this._titleTextComponent.color = "white";
    this._titleTextComponent.fontSize = _HolographicSlate._DEFAULT_TEXT_RESOLUTION_Y / 2;
    this._titleTextComponent.paddingLeft = _HolographicSlate._DEFAULT_TEXT_RESOLUTION_Y / 4;
    adt.addControl(this._titleTextComponent);
    if (scene.useRightHandedSystem) {
      const faceUV = new Vector4(0, 0, 1, 1);
      this._contentPlate = CreatePlane("contentPlate_" + this.name, { size: 1, sideOrientation: VertexData.BACKSIDE, frontUVs: faceUV }, scene);
      this._backPlate = CreatePlane("backPlate_" + this.name, { size: 1, sideOrientation: VertexData.FRONTSIDE }, scene);
    } else {
      const faceUV = new Vector4(0, 0, 1, 1);
      this._contentPlate = CreatePlane("contentPlate_" + this.name, { size: 1, sideOrientation: VertexData.FRONTSIDE, frontUVs: faceUV }, scene);
      this._backPlate = CreatePlane("backPlate_" + this.name, { size: 1, sideOrientation: VertexData.BACKSIDE }, scene);
    }
    this._titleBar.parent = node;
    this._titleBar.isNearGrabbable = true;
    this._contentPlate.parent = node;
    this._backPlate.parent = node;
    this._attachContentPlateBehavior();
    this._addControl(this._followButton);
    this._addControl(this._closeButton);
    const followButton = this._followButton;
    const closeButton = this._closeButton;
    followButton.node.parent = node;
    closeButton.node.parent = node;
    this._positionElements();
    this._followButton.imageUrl = _HolographicSlate.ASSETS_BASE_URL + _HolographicSlate.FOLLOW_ICON_FILENAME;
    this._closeButton.imageUrl = _HolographicSlate.ASSETS_BASE_URL + _HolographicSlate.CLOSE_ICON_FILENAME;
    this._followButton.isBackplateVisible = false;
    this._closeButton.isBackplateVisible = false;
    this._followButton.onToggleObservable.add((isToggled) => {
      this._defaultBehavior.followBehaviorEnabled = isToggled;
      if (this._defaultBehavior.followBehaviorEnabled) {
        this._defaultBehavior.followBehavior.recenter();
      }
    });
    this._closeButton.onPointerClickObservable.add(() => {
      this.dispose();
    });
    node.rotationQuaternion = Quaternion.Identity();
    node.isVisible = false;
    return node;
  }
  _attachContentPlateBehavior() {
    this._contentDragBehavior.attach(this._contentPlate);
    this._contentDragBehavior.moveAttached = false;
    this._contentDragBehavior.useObjectOrientationForDragging = true;
    this._contentDragBehavior.updateDragPlane = false;
    const origin = new Vector3();
    const worldDimensions = new Vector3();
    const upWorld = new Vector3();
    const rightWorld = new Vector3();
    const projectedOffset = new Vector2();
    let startViewport;
    let worldMatrix;
    this._contentDragBehavior.onDragStartObservable.add((event) => {
      if (!this.node) {
        return;
      }
      startViewport = this._contentViewport.clone();
      worldMatrix = this.node.computeWorldMatrix(true);
      origin.copyFrom(event.dragPlanePoint);
      worldDimensions.set(this.dimensions.x, this.dimensions.y, Epsilon);
      worldDimensions.y -= this.titleBarHeight + this.titleBarMargin;
      Vector3.TransformNormalToRef(worldDimensions, worldMatrix, worldDimensions);
      upWorld.copyFromFloats(0, 1, 0);
      Vector3.TransformNormalToRef(upWorld, worldMatrix, upWorld);
      rightWorld.copyFromFloats(1, 0, 0);
      Vector3.TransformNormalToRef(rightWorld, worldMatrix, rightWorld);
      upWorld.normalize();
      upWorld.scaleInPlace(1 / Vector3.Dot(upWorld, worldDimensions));
      rightWorld.normalize();
      rightWorld.scaleInPlace(1 / Vector3.Dot(rightWorld, worldDimensions));
    });
    const offset = new Vector3();
    this._contentDragBehavior.onDragObservable.add((event) => {
      if (this.fitContentToDimensions) {
        return;
      }
      offset.copyFrom(event.dragPlanePoint);
      offset.subtractInPlace(origin);
      projectedOffset.copyFromFloats(Vector3.Dot(offset, rightWorld), Vector3.Dot(offset, upWorld));
      this._contentViewport.x = Scalar.Clamp(startViewport.x - offset.x, 0, 1 - this._contentViewport.width * this._contentScaleRatio);
      this._contentViewport.y = Scalar.Clamp(startViewport.y - offset.y, 0, 1 - this._contentViewport.height * this._contentScaleRatio);
      this._applyContentViewport();
    });
  }
  _affectMaterial(mesh) {
    this._titleBarMaterial = new FluentBackplateMaterial(`${this.name} plateMaterial`, mesh.getScene());
    this._contentMaterial = new FluentMaterial(`${this.name} contentMaterial`, mesh.getScene());
    this._contentMaterial.renderBorders = true;
    this._backMaterial = new FluentBackplateMaterial(`${this.name} backPlate`, mesh.getScene());
    this._backMaterial.lineWidth = Epsilon;
    this._backMaterial.radius = 5e-3;
    this._backMaterial.backFaceCulling = true;
    this._titleBar.material = this._titleBarMaterial;
    this._contentPlate.material = this._contentMaterial;
    this._backPlate.material = this._backMaterial;
    this._resetContent();
    this._applyContentViewport();
  }
  /**
   * @internal
   */
  _prepareNode(scene) {
    super._prepareNode(scene);
    this._gizmo = new SlateGizmo(this._host.utilityLayer);
    this._gizmo.attachedSlate = this;
    this._defaultBehavior = new DefaultBehavior();
    this._defaultBehavior.attach(this.node, [this._titleBar]);
    this._defaultBehavior.sixDofDragBehavior.onDragStartObservable.add(() => {
      this._followButton.isToggled = false;
    });
    this._positionChangedObserver = this._defaultBehavior.sixDofDragBehavior.onPositionChangedObservable.add(() => {
      this._gizmo.updateBoundingBox();
    });
    this._updatePivot();
    this.resetDefaultAspectAndPose(false);
  }
  /**
   * Resets the aspect and pose of the slate so it is right in front of the active camera, facing towards it.
   * @param resetAspect Should the slate's dimensions/aspect ratio be reset as well
   */
  resetDefaultAspectAndPose(resetAspect = true) {
    if (!this._host || !this._host.utilityLayer || !this.node) {
      return;
    }
    const scene = this._host.utilityLayer.utilityLayerScene;
    const camera = scene.activeCamera;
    if (camera) {
      const worldMatrix = camera.getWorldMatrix();
      const backward = Vector3.TransformNormal(Vector3.Backward(scene.useRightHandedSystem), worldMatrix);
      this.origin.setAll(0);
      this._gizmo.updateBoundingBox();
      const pivot = this.node.getAbsolutePivotPoint();
      if (this.node.position.equalsToFloats(0, 0, 0)) {
        this.node.position.copyFrom(camera.position).subtractInPlace(backward).subtractInPlace(pivot);
      }
      this.node.rotationQuaternion = Quaternion.FromLookDirectionLH(backward, new Vector3(0, 1, 0));
      if (resetAspect) {
        this.dimensions = this.defaultDimensions;
      }
    }
  }
  /**
   * Releases all associated resources
   */
  dispose() {
    super.dispose();
    this._titleBarMaterial.dispose();
    this._contentMaterial.dispose();
    this._titleBar.dispose();
    this._titleBarTitle.dispose();
    this._contentPlate.dispose();
    this._backPlate.dispose();
    this._followButton.dispose();
    this._closeButton.dispose();
    this._host.onPickedPointChangedObservable.remove(this._pickedPointObserver);
    this._defaultBehavior.sixDofDragBehavior.onPositionChangedObservable.remove(this._positionChangedObserver);
    this._defaultBehavior.detach();
    this._gizmo.dispose();
    this._contentDragBehavior.detach();
  }
};
HolographicSlate.ASSETS_BASE_URL = "https://assets.babylonjs.com/meshes/MRTK/";
HolographicSlate.CLOSE_ICON_FILENAME = "IconClose.png";
HolographicSlate.FOLLOW_ICON_FILENAME = "IconFollowMe.png";
HolographicSlate._DEFAULT_TEXT_RESOLUTION_Y = 102.4;

// node_modules/@babylonjs/gui/3D/controls/meshButton3D.js
var MeshButton3D = class extends Button3D {
  /**
   * Creates a new 3D button based on a mesh
   * @param mesh mesh to become a 3D button
   * @param name defines the control name
   */
  constructor(mesh, name22) {
    super(name22);
    this._currentMesh = mesh;
    this.pointerEnterAnimation = () => {
      if (!this.mesh) {
        return;
      }
      this.mesh.scaling.scaleInPlace(1.1);
    };
    this.pointerOutAnimation = () => {
      if (!this.mesh) {
        return;
      }
      this.mesh.scaling.scaleInPlace(1 / 1.1);
    };
    this.pointerDownAnimation = () => {
      if (!this.mesh) {
        return;
      }
      this.mesh.scaling.scaleInPlace(0.95);
    };
    this.pointerUpAnimation = () => {
      if (!this.mesh) {
        return;
      }
      this.mesh.scaling.scaleInPlace(1 / 0.95);
    };
  }
  _getTypeName() {
    return "MeshButton3D";
  }
  // Mesh association
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _createNode(scene) {
    this._currentMesh.getChildMeshes().forEach((mesh) => {
      this._injectGUI3DReservedDataStore(mesh).control = this;
    });
    return this._currentMesh;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _affectMaterial(mesh) {
  }
};

// node_modules/@babylonjs/gui/3D/controls/nearMenu.js
var NearMenu = class _NearMenu extends TouchHolographicMenu {
  /**
   * Regroups all mesh behaviors for the near menu
   */
  get defaultBehavior() {
    return this._defaultBehavior;
  }
  /**
   * Indicates if the near menu is world-pinned
   */
  get isPinned() {
    return this._isPinned;
  }
  set isPinned(value) {
    if (this._pinButton.isToggled !== value) {
      this._pinButton.isToggled = value;
      return;
    }
    this._isPinned = value;
    if (value) {
      this._defaultBehavior.followBehaviorEnabled = false;
    } else {
      this._defaultBehavior.followBehaviorEnabled = true;
    }
  }
  _createPinButton(parent) {
    const control = new TouchHolographicButton("pin" + this.name, false);
    control.imageUrl = _NearMenu._ASSETS_BASE_URL + _NearMenu._PIN_ICON_FILENAME;
    control.parent = this;
    control._host = this._host;
    control.isToggleButton = true;
    control.onToggleObservable.add((newState) => {
      this.isPinned = newState;
    });
    if (this._host.utilityLayer) {
      control._prepareNode(this._host.utilityLayer.utilityLayerScene);
      control.scaling.scaleInPlace(TouchHolographicMenu.MENU_BUTTON_SCALE);
      if (control.node) {
        control.node.parent = parent;
      }
    }
    return control;
  }
  _createNode(scene) {
    const node = super._createNode(scene);
    this._pinButton = this._createPinButton(node);
    this.isPinned = false;
    this._defaultBehavior.attach(node, [this._backPlate]);
    this._defaultBehavior.followBehavior.ignoreCameraPitchAndRoll = true;
    this._defaultBehavior.followBehavior.pitchOffset = -15;
    this._defaultBehavior.followBehavior.minimumDistance = 0.3;
    this._defaultBehavior.followBehavior.defaultDistance = 0.4;
    this._defaultBehavior.followBehavior.maximumDistance = 0.6;
    this._backPlate.isNearGrabbable = true;
    node.isVisible = false;
    return node;
  }
  _finalProcessing() {
    super._finalProcessing();
    this._pinButton.position.copyFromFloats((this._backPlate.scaling.x + TouchHolographicMenu.MENU_BUTTON_SCALE) / 2, this._backPlate.scaling.y / 2, 0);
  }
  /**
   * Creates a near menu GUI 3D control
   * @param name name of the near menu
   */
  constructor(name22) {
    super(name22);
    this._isPinned = false;
    this._defaultBehavior = new DefaultBehavior();
    this._dragObserver = this._defaultBehavior.sixDofDragBehavior.onDragObservable.add(() => {
      this.isPinned = true;
    });
    this.backPlateMargin = 1;
  }
  /**
   * Disposes the near menu
   */
  dispose() {
    super.dispose();
    this._defaultBehavior.sixDofDragBehavior.onDragObservable.remove(this._dragObserver);
    this._defaultBehavior.detach();
  }
};
NearMenu._ASSETS_BASE_URL = "https://assets.babylonjs.com/meshes/MRTK/";
NearMenu._PIN_ICON_FILENAME = "IconPin.png";

// node_modules/@babylonjs/gui/3D/controls/planePanel.js
var PlanePanel = class extends VolumeBasedPanel {
  _mapGridNode(control, nodePosition) {
    const mesh = control.mesh;
    if (!mesh) {
      return;
    }
    control.position = nodePosition.clone();
    const target = TmpVectors.Vector3[0];
    target.copyFrom(nodePosition);
    switch (this.orientation) {
      case Container3D.FACEORIGIN_ORIENTATION:
      case Container3D.FACEFORWARD_ORIENTATION:
        target.addInPlace(new Vector3(0, 0, 1));
        mesh.lookAt(target);
        break;
      case Container3D.FACEFORWARDREVERSED_ORIENTATION:
      case Container3D.FACEORIGINREVERSED_ORIENTATION:
        target.addInPlace(new Vector3(0, 0, -1));
        mesh.lookAt(target);
        break;
    }
  }
};

// node_modules/@babylonjs/gui/3D/controls/scatterPanel.js
var ScatterPanel = class extends VolumeBasedPanel {
  constructor() {
    super(...arguments);
    this._iteration = 100;
  }
  /**
   * Gets or sets the number of iteration to use to scatter the controls (100 by default)
   */
  get iteration() {
    return this._iteration;
  }
  set iteration(value) {
    if (this._iteration === value) {
      return;
    }
    this._iteration = value;
    Tools.SetImmediate(() => {
      this._arrangeChildren();
    });
  }
  _mapGridNode(control, nodePosition) {
    const mesh = control.mesh;
    const newPos = this._scatterMapping(nodePosition);
    if (!mesh) {
      return;
    }
    switch (this.orientation) {
      case Container3D.FACEORIGIN_ORIENTATION:
      case Container3D.FACEFORWARD_ORIENTATION:
        mesh.lookAt(new Vector3(0, 0, 1));
        break;
      case Container3D.FACEFORWARDREVERSED_ORIENTATION:
      case Container3D.FACEORIGINREVERSED_ORIENTATION:
        mesh.lookAt(new Vector3(0, 0, -1));
        break;
    }
    control.position = newPos;
  }
  _scatterMapping(source) {
    source.x = (1 - Math.random() * 2) * this._cellWidth;
    source.y = (1 - Math.random() * 2) * this._cellHeight;
    return source;
  }
  _finalProcessing() {
    const meshes = [];
    for (const child of this._children) {
      if (!child.mesh) {
        continue;
      }
      meshes.push(child.mesh);
    }
    for (let count = 0; count < this._iteration; count++) {
      meshes.sort((a, b) => {
        const distance1 = a.position.lengthSquared();
        const distance2 = b.position.lengthSquared();
        if (distance1 < distance2) {
          return 1;
        } else if (distance1 > distance2) {
          return -1;
        }
        return 0;
      });
      const radiusPaddingSquared = Math.pow(this.margin, 2);
      const cellSize = Math.max(this._cellWidth, this._cellHeight);
      const difference2D = TmpVectors.Vector2[0];
      const difference = TmpVectors.Vector3[0];
      for (let i = 0; i < meshes.length - 1; i++) {
        for (let j = i + 1; j < meshes.length; j++) {
          if (i != j) {
            meshes[j].position.subtractToRef(meshes[i].position, difference);
            difference2D.x = difference.x;
            difference2D.y = difference.y;
            const combinedRadius = cellSize;
            let distance = difference2D.lengthSquared() - radiusPaddingSquared;
            const minSeparation = Math.min(distance, radiusPaddingSquared);
            distance -= minSeparation;
            if (distance < Math.pow(combinedRadius, 2)) {
              difference2D.normalize();
              difference.scaleInPlace((combinedRadius - Math.sqrt(distance)) * 0.5);
              meshes[j].position.addInPlace(difference);
              meshes[i].position.subtractInPlace(difference);
            }
          }
        }
      }
    }
  }
};

// node_modules/@babylonjs/gui/3D/materials/mrdl/shaders/mrdlSliderBar.fragment.js
var name10 = "mrdlSliderBarPixelShader";
var shader9 = `uniform vec3 cameraPosition;varying vec3 vPosition;varying vec3 vNormal;varying vec2 vUV;varying vec3 vTangent;varying vec3 vBinormal;varying vec4 vColor;varying vec4 vExtra1;varying vec4 vExtra2;varying vec4 vExtra3;uniform float _Radius_;uniform float _Bevel_Front_;uniform float _Bevel_Front_Stretch_;uniform float _Bevel_Back_;uniform float _Bevel_Back_Stretch_;uniform float _Radius_Top_Left_;uniform float _Radius_Top_Right_;uniform float _Radius_Bottom_Left_;uniform float _Radius_Bottom_Right_;uniform bool _Bulge_Enabled_;uniform float _Bulge_Height_;uniform float _Bulge_Radius_;uniform float _Sun_Intensity_;uniform float _Sun_Theta_;uniform float _Sun_Phi_;uniform float _Indirect_Diffuse_;uniform vec4 _Albedo_;uniform float _Specular_;uniform float _Shininess_;uniform float _Sharpness_;uniform float _Subsurface_;uniform vec4 _Left_Color_;uniform vec4 _Right_Color_;uniform float _Reflection_;uniform float _Front_Reflect_;uniform float _Edge_Reflect_;uniform float _Power_;uniform vec4 _Sky_Color_;uniform vec4 _Horizon_Color_;uniform vec4 _Ground_Color_;uniform float _Horizon_Power_;uniform sampler2D _Reflection_Map_;uniform sampler2D _Indirect_Environment_;uniform float _Width_;uniform float _Fuzz_;uniform float _Min_Fuzz_;uniform float _Clip_Fade_;uniform float _Hue_Shift_;uniform float _Saturation_Shift_;uniform float _Value_Shift_;uniform vec3 _Blob_Position_;uniform float _Blob_Intensity_;uniform float _Blob_Near_Size_;uniform float _Blob_Far_Size_;uniform float _Blob_Near_Distance_;uniform float _Blob_Far_Distance_;uniform float _Blob_Fade_Length_;uniform float _Blob_Pulse_;uniform float _Blob_Fade_;uniform sampler2D _Blob_Texture_;uniform vec3 _Blob_Position_2_;uniform float _Blob_Near_Size_2_;uniform float _Blob_Pulse_2_;uniform float _Blob_Fade_2_;uniform vec3 _Left_Index_Pos_;uniform vec3 _Right_Index_Pos_;uniform vec3 _Left_Index_Middle_Pos_;uniform vec3 _Right_Index_Middle_Pos_;uniform sampler2D _Decal_;uniform vec2 _Decal_Scale_XY_;uniform bool _Decal_Front_Only_;uniform float _Rim_Intensity_;uniform sampler2D _Rim_Texture_;uniform float _Rim_Hue_Shift_;uniform float _Rim_Saturation_Shift_;uniform float _Rim_Value_Shift_;uniform float _Iridescence_Intensity_;uniform sampler2D _Iridescence_Texture_;uniform bool Use_Global_Left_Index;uniform bool Use_Global_Right_Index;uniform vec4 Global_Left_Index_Tip_Position;uniform vec4 Global_Right_Index_Tip_Position;uniform vec4 Global_Left_Thumb_Tip_Position;uniform vec4 Global_Right_Thumb_Tip_Position;uniform vec4 Global_Left_Index_Middle_Position;uniform vec4 Global_Right_Index_Middle_Position;uniform float Global_Left_Index_Tip_Proximity;uniform float Global_Right_Index_Tip_Proximity;void Blob_Fragment_B30(
sampler2D Blob_Texture,
vec4 Blob_Info1,
vec4 Blob_Info2,
out vec4 Blob_Color)
{float k1=dot(Blob_Info1.xy,Blob_Info1.xy);float k2=dot(Blob_Info2.xy,Blob_Info2.xy);vec3 closer=k1<k2 ? vec3(k1,Blob_Info1.z,Blob_Info1.w) : vec3(k2,Blob_Info2.z,Blob_Info2.w);Blob_Color=closer.z*texture(Blob_Texture,vec2(vec2(sqrt(closer.x),closer.y).x,1.0-vec2(sqrt(closer.x),closer.y).y))*clamp(1.0-closer.x,0.0,1.0);}
void FastLinearTosRGB_B42(
vec4 Linear,
out vec4 sRGB)
{sRGB.rgb=sqrt(clamp(Linear.rgb,0.0,1.0));sRGB.a=Linear.a;}
void Scale_RGB_B59(
vec4 Color,
float Scalar,
out vec4 Result)
{Result=vec4(Scalar,Scalar,Scalar,1)*Color;}
void Fragment_Main_B121(
float Sun_Intensity,
float Sun_Theta,
float Sun_Phi,
vec3 Normal,
vec4 Albedo,
float Fresnel_Reflect,
float Shininess,
vec3 Incident,
vec4 Horizon_Color,
vec4 Sky_Color,
vec4 Ground_Color,
float Indirect_Diffuse,
float Specular,
float Horizon_Power,
float Reflection,
vec4 Reflection_Sample,
vec4 Indirect_Sample,
float Sharpness,
float SSS,
float Subsurface,
vec4 Translucence,
vec4 Rim_Light,
vec4 Iridescence,
out vec4 Result)
{float theta=Sun_Theta*2.0*3.14159;float phi=Sun_Phi*3.14159;vec3 lightDir= vec3(cos(phi)*cos(theta),sin(phi),cos(phi)*sin(theta));float NdotL=max(dot(lightDir,Normal),0.0);vec3 R=reflect(Incident,Normal);float RdotL=max(0.0,dot(R,lightDir));float specular=pow(RdotL,Shininess);specular=mix(specular,smoothstep(0.495*Sharpness,1.0-0.495*Sharpness,specular),Sharpness);vec4 gi=mix(Ground_Color,Sky_Color,Normal.y*0.5+0.5);Result=((Sun_Intensity*NdotL+Indirect_Sample*Indirect_Diffuse+Translucence)*(1.0+SSS*Subsurface))*Albedo*(1.0-Fresnel_Reflect)+(Sun_Intensity*specular*Specular+Fresnel_Reflect*Reflection*Reflection_Sample)+Fresnel_Reflect*Rim_Light+Iridescence;}
void Bulge_B79(
bool Enabled,
vec3 Normal,
vec3 Tangent,
float Bulge_Height,
vec4 UV,
float Bulge_Radius,
vec3 ButtonN,
out vec3 New_Normal)
{vec2 xy=clamp(UV.xy*2.0,vec2(-1,-1),vec2(1,1));vec3 B=(cross(Normal,Tangent));float k=-clamp(1.0-length(xy)/Bulge_Radius,0.0,1.0)*Bulge_Height;k=sin(k*3.14159*0.5);k*=smoothstep(0.9998,0.9999,abs(dot(ButtonN,Normal)));New_Normal=Normal*sqrt(1.0-k*k)+(xy.x*Tangent+xy.y*B)*k;New_Normal=Enabled ? New_Normal : Normal;}
void SSS_B77(
vec3 ButtonN,
vec3 Normal,
vec3 Incident,
out float Result)
{float NdotI=abs(dot(Normal,Incident));float BdotI=abs(dot(ButtonN,Incident));Result=(abs(NdotI-BdotI)); }
void FingerOcclusion_B67(
float Width,
float DistToCenter,
float Fuzz,
float Min_Fuzz,
vec3 Position,
vec3 Forward,
vec3 Nearest,
float Fade_Out,
out float NotInShadow)
{float d=dot((Nearest-Position),Forward);float sh=smoothstep(Width*0.5,Width*0.5+Fuzz*max(d,0.0)+Min_Fuzz,DistToCenter);NotInShadow=1.0-(1.0-sh)*smoothstep(-Fade_Out,0.0,d);}
void FingerOcclusion_B68(
float Width,
float DistToCenter,
float Fuzz,
float Min_Fuzz,
vec3 Position,
vec3 Forward,
vec3 Nearest,
float Fade_Out,
out float NotInShadow)
{float d=dot((Nearest-Position),Forward);float sh=smoothstep(Width*0.5,Width*0.5+Fuzz*max(d,0.0)+Min_Fuzz,DistToCenter);NotInShadow=1.0-(1.0-sh)*smoothstep(-Fade_Out,0.0,d);}
void Scale_Color_B91(
vec4 Color,
float Scalar,
out vec4 Result)
{Result=Scalar*Color;}
void From_HSV_B73(
float Hue,
float Saturation,
float Value,
float Alpha,
out vec4 Color)
{vec4 K=vec4(1.0,2.0/3.0,1.0/3.0,3.0);vec3 p=abs(fract(vec3(Hue,Hue,Hue)+K.xyz)*6.0-K.www);Color.rgb=Value*mix(K.xxx,clamp(p-K.xxx,0.0,1.0),Saturation);Color.a=Alpha;}
void Fast_Fresnel_B122(
float Front_Reflect,
float Edge_Reflect,
float Power,
vec3 Normal,
vec3 Incident,
out float Transmit,
out float Reflect)
{float d=max(-dot(Incident,Normal),0.0);Reflect=Front_Reflect+(Edge_Reflect-Front_Reflect)*pow(.01-d,Power);Transmit=1.0-Reflect;}
void Mapped_Environment_B51(
sampler2D Reflected_Environment,
sampler2D Indirect_Environment,
vec3 Dir,
out vec4 Reflected_Color,
out vec4 Indirect_Diffuse)
{Reflected_Color=texture(Reflected_Environment,vec2(atan(Dir.z,Dir.x)/3.14159*0.5,asin(Dir.y)/3.14159+0.5));Indirect_Diffuse=texture(Indirect_Environment,vec2(atan(Dir.z,Dir.x)/3.14159*0.5,asin(Dir.y)/3.14159+0.5));}
vec4 SampleEnv_Bid50(vec3 D,vec4 S,vec4 H,vec4 G,float exponent)
{float k=pow(abs(D.y),exponent);vec4 C;if (D.y>0.0) {C=mix(H,S,k);} else {C=mix(H,G,k); }
return C;}
void Sky_Environment_B50(
vec3 Normal,
vec3 Reflected,
vec4 Sky_Color,
vec4 Horizon_Color,
vec4 Ground_Color,
float Horizon_Power,
out vec4 Reflected_Color,
out vec4 Indirect_Color)
{Reflected_Color=SampleEnv_Bid50(Reflected,Sky_Color,Horizon_Color,Ground_Color,Horizon_Power);Indirect_Color=mix(Ground_Color,Sky_Color,Normal.y*0.5+0.5);}
void Min_Segment_Distance_B65(
vec3 P0,
vec3 P1,
vec3 Q0,
vec3 Q1,
out vec3 NearP,
out vec3 NearQ,
out float Distance)
{vec3 u=P1-P0;vec3 v=Q1-Q0;vec3 w=P0-Q0;float a=dot(u,u);float b=dot(u,v);float c=dot(v,v);float d=dot(u,w);float e=dot(v,w);float D=a*c-b*b;float sD=D;float tD=D;float sc,sN,tc,tN;if (D<0.00001) {sN=0.0;sD=1.0;tN=e;tD=c;} else {sN=(b*e-c*d);tN=(a*e-b*d);if (sN<0.0) {sN=0.0;tN=e;tD=c;} else if (sN>sD) {sN=sD;tN=e+b;tD=c;}}
if (tN<0.0) {tN=0.0;if (-d<0.0) {sN=0.0;} else if (-d>a) {sN=sD;} else {sN=-d;sD=a;}} else if (tN>tD) {tN=tD;if ((-d+b)<0.0) {sN=0.0;} else if ((-d+b)>a) {sN=sD;} else {sN=(-d+b);sD=a;}}
sc=abs(sN)<0.000001 ? 0.0 : sN/sD;tc=abs(tN)<0.000001 ? 0.0 : tN/tD;NearP=P0+sc*u;NearQ=Q0+tc*v;Distance=distance(NearP,NearQ);}
void To_XYZ_B74(
vec3 Vec3,
out float X,
out float Y,
out float Z)
{X=Vec3.x;Y=Vec3.y;Z=Vec3.z;}
void Finger_Positions_B64(
vec3 Left_Index_Pos,
vec3 Right_Index_Pos,
vec3 Left_Index_Middle_Pos,
vec3 Right_Index_Middle_Pos,
out vec3 Left_Index,
out vec3 Right_Index,
out vec3 Left_Index_Middle,
out vec3 Right_Index_Middle)
{Left_Index= (Use_Global_Left_Index ? Global_Left_Index_Tip_Position.xyz : Left_Index_Pos);Right_Index= (Use_Global_Right_Index ? Global_Right_Index_Tip_Position.xyz : Right_Index_Pos);Left_Index_Middle= (Use_Global_Left_Index ? Global_Left_Index_Middle_Position.xyz : Left_Index_Middle_Pos);Right_Index_Middle= (Use_Global_Right_Index ? Global_Right_Index_Middle_Position.xyz : Right_Index_Middle_Pos);}
void VaryHSV_B108(
vec3 HSV_In,
float Hue_Shift,
float Saturation_Shift,
float Value_Shift,
out vec3 HSV_Out)
{HSV_Out=vec3(fract(HSV_In.x+Hue_Shift),clamp(HSV_In.y+Saturation_Shift,0.0,1.0),clamp(HSV_In.z+Value_Shift,0.0,1.0));}
void Remap_Range_B114(
float In_Min,
float In_Max,
float Out_Min,
float Out_Max,
float In,
out float Out)
{Out=mix(Out_Min,Out_Max,clamp((In-In_Min)/(In_Max-In_Min),0.0,1.0));}
void To_HSV_B75(
vec4 Color,
out float Hue,
out float Saturation,
out float Value,
out float Alpha,
out vec3 HSV)
{vec4 K=vec4(0.0,-1.0/3.0,2.0/3.0,-1.0);vec4 p=Color.g<Color.b ? vec4(Color.bg,K.wz) : vec4(Color.gb,K.xy);vec4 q=Color.r<p.x ? vec4(p.xyw,Color.r) : vec4(Color.r,p.yzx);float d=q.x-min(q.w,q.y);float e=1.0e-10;Hue=abs(q.z+(q.w-q.y)/(6.0*d+e));Saturation=d/(q.x+e);Value=q.x;Alpha=Color.a;HSV=vec3(Hue,Saturation,Value);}
void Code_B110(
float X,
out float Result)
{Result=(acos(X)/3.14159-0.5)*2.0;}
void Rim_Light_B132(
vec3 Front,
vec3 Normal,
vec3 Incident,
float Rim_Intensity,
sampler2D Texture,
out vec4 Result)
{vec3 R=reflect(Incident,Normal);float RdotF=dot(R,Front);float RdotL=sqrt(1.0-RdotF*RdotF);vec2 UV=vec2(R.y*0.5+0.5,0.5);vec4 Color=texture(Texture,UV);Result=Color;}
void main()
{vec4 Blob_Color_Q30;
#if BLOB_ENABLE
Blob_Fragment_B30(_Blob_Texture_,vExtra2,vExtra3,Blob_Color_Q30);
#else
Blob_Color_Q30=vec4(0,0,0,0);
#endif
vec3 Incident_Q39=normalize(vPosition-cameraPosition);vec3 Normalized_Q38=normalize(vNormal);vec3 Normalized_Q71=normalize(vTangent);vec4 Color_Q83;
#if DECAL_ENABLE
Color_Q83=texture(_Decal_,vUV);
#else
Color_Q83=vec4(0,0,0,0);
#endif
float X_Q90;float Y_Q90;float Z_Q90;float W_Q90;X_Q90=vExtra1.x;Y_Q90=vExtra1.y;Z_Q90=vExtra1.z;W_Q90=vExtra1.w;vec4 Linear_Q43;Linear_Q43.rgb=clamp(_Sky_Color_.rgb*_Sky_Color_.rgb,0.0,1.0);Linear_Q43.a=_Sky_Color_.a;vec4 Linear_Q44;Linear_Q44.rgb=clamp(_Horizon_Color_.rgb*_Horizon_Color_.rgb,0.0,1.0);Linear_Q44.a=_Horizon_Color_.a;vec4 Linear_Q45;Linear_Q45.rgb=clamp(_Ground_Color_.rgb*_Ground_Color_.rgb,0.0,1.0);Linear_Q45.a=_Ground_Color_.a;vec3 Left_Index_Q64;vec3 Right_Index_Q64;vec3 Left_Index_Middle_Q64;vec3 Right_Index_Middle_Q64;Finger_Positions_B64(_Left_Index_Pos_,_Right_Index_Pos_,_Left_Index_Middle_Pos_,_Right_Index_Middle_Pos_,Left_Index_Q64,Right_Index_Q64,Left_Index_Middle_Q64,Right_Index_Middle_Q64);vec4 Linear_Q46;Linear_Q46.rgb=clamp(_Albedo_.rgb*_Albedo_.rgb,0.0,1.0);Linear_Q46.a=_Albedo_.a;vec3 Normalized_Q107=normalize(vBinormal);vec3 Incident_Q70=normalize(vPosition-cameraPosition);vec3 New_Normal_Q79;Bulge_B79(_Bulge_Enabled_,Normalized_Q38,Normalized_Q71,_Bulge_Height_,vColor,_Bulge_Radius_,vBinormal,New_Normal_Q79);float Result_Q77;SSS_B77(vBinormal,New_Normal_Q79,Incident_Q39,Result_Q77);vec4 Result_Q91;Scale_Color_B91(Color_Q83,X_Q90,Result_Q91);float Transmit_Q122;float Reflect_Q122;Fast_Fresnel_B122(_Front_Reflect_,_Edge_Reflect_,_Power_,New_Normal_Q79,Incident_Q39,Transmit_Q122,Reflect_Q122);float Product_Q125=Y_Q90*Y_Q90;vec3 NearP_Q65;vec3 NearQ_Q65;float Distance_Q65;Min_Segment_Distance_B65(Left_Index_Q64,Left_Index_Middle_Q64,vPosition,cameraPosition,NearP_Q65,NearQ_Q65,Distance_Q65);vec3 NearP_Q63;vec3 NearQ_Q63;float Distance_Q63;Min_Segment_Distance_B65(Right_Index_Q64,Right_Index_Middle_Q64,vPosition,cameraPosition,NearP_Q63,NearQ_Q63,Distance_Q63);vec3 Reflected_Q47=reflect(Incident_Q39,New_Normal_Q79);vec4 Product_Q103=Linear_Q46*vec4(1,1,1,1);vec4 Result_Q132;Rim_Light_B132(Normalized_Q107,Normalized_Q38,Incident_Q70,_Rim_Intensity_,_Rim_Texture_,Result_Q132);float Dot_Q72=dot(Incident_Q70, Normalized_Q71);float MaxAB_Q123=max(Reflect_Q122,Product_Q125);float NotInShadow_Q67;
#if OCCLUSION_ENABLED
FingerOcclusion_B67(_Width_,Distance_Q65,_Fuzz_,_Min_Fuzz_,vPosition,vBinormal,NearP_Q65,_Clip_Fade_,NotInShadow_Q67);
#else
NotInShadow_Q67=1.0;
#endif
float NotInShadow_Q68;
#if OCCLUSION_ENABLED
FingerOcclusion_B68(_Width_,Distance_Q63,_Fuzz_,_Min_Fuzz_,vPosition,vBinormal,NearP_Q63,_Clip_Fade_,NotInShadow_Q68);
#else
NotInShadow_Q68=1.0;
#endif
vec4 Reflected_Color_Q51;vec4 Indirect_Diffuse_Q51;
#if ENV_ENABLE
Mapped_Environment_B51(_Reflection_Map_,_Indirect_Environment_,Reflected_Q47,Reflected_Color_Q51,Indirect_Diffuse_Q51);
#else
Reflected_Color_Q51=vec4(0,0,0,1);Indirect_Diffuse_Q51=vec4(0,0,0,1);
#endif
vec4 Reflected_Color_Q50;vec4 Indirect_Color_Q50;
#if SKY_ENABLED
Sky_Environment_B50(New_Normal_Q79,Reflected_Q47,Linear_Q43,Linear_Q44,Linear_Q45,_Horizon_Power_,Reflected_Color_Q50,Indirect_Color_Q50);
#else
Reflected_Color_Q50=vec4(0,0,0,1);Indirect_Color_Q50=vec4(0,0,0,1);
#endif
float Hue_Q75;float Saturation_Q75;float Value_Q75;float Alpha_Q75;vec3 HSV_Q75;To_HSV_B75(Product_Q103,Hue_Q75,Saturation_Q75,Value_Q75,Alpha_Q75,HSV_Q75);float Hue_Q127;float Saturation_Q127;float Value_Q127;float Alpha_Q127;vec3 HSV_Q127;To_HSV_B75(Result_Q132,Hue_Q127,Saturation_Q127,Value_Q127,Alpha_Q127,HSV_Q127);float Result_Q110;Code_B110(Dot_Q72,Result_Q110);float AbsA_Q76=abs(Result_Q110);float MinAB_Q58=min(NotInShadow_Q67,NotInShadow_Q68);vec4 Sum_Q48=Reflected_Color_Q51+Reflected_Color_Q50;vec4 Sum_Q49=Indirect_Diffuse_Q51+Indirect_Color_Q50;vec3 HSV_Out_Q126;VaryHSV_B108(HSV_Q127,_Rim_Hue_Shift_,_Rim_Saturation_Shift_,_Rim_Value_Shift_,HSV_Out_Q126);float Out_Q114;Remap_Range_B114(-1.0,1.0,0.0,1.0,Result_Q110,Out_Q114);float Product_Q106;Product_Q106=AbsA_Q76*_Hue_Shift_;float X_Q128;float Y_Q128;float Z_Q128;To_XYZ_B74(HSV_Out_Q126,X_Q128,Y_Q128,Z_Q128);vec2 Vec2_Q112=vec2(Out_Q114,0.5);vec3 HSV_Out_Q108;VaryHSV_B108(HSV_Q75,Product_Q106,_Saturation_Shift_,_Value_Shift_,HSV_Out_Q108);vec4 Color_Q129;From_HSV_B73(X_Q128,Y_Q128,Z_Q128,0.0,Color_Q129);vec4 Color_Q111;
#if IRIDESCENCE_ENABLED
Color_Q111=texture(_Iridescence_Texture_,Vec2_Q112);
#else
Color_Q111=vec4(0,0,0,0);
#endif
float X_Q74;float Y_Q74;float Z_Q74;To_XYZ_B74(HSV_Out_Q108,X_Q74,Y_Q74,Z_Q74);vec4 Result_Q131=_Rim_Intensity_*Color_Q129;vec4 Result_Q113=_Iridescence_Intensity_*Color_Q111;vec4 Color_Q73;From_HSV_B73(X_Q74,Y_Q74,Z_Q74,0.0,Color_Q73);vec4 Result_Q84=Result_Q91+(1.0-Result_Q91.a)*Color_Q73;vec4 Result_Q121;Fragment_Main_B121(_Sun_Intensity_,_Sun_Theta_,_Sun_Phi_,New_Normal_Q79,Result_Q84,MaxAB_Q123,_Shininess_,Incident_Q39,_Horizon_Color_,_Sky_Color_,_Ground_Color_,_Indirect_Diffuse_,_Specular_,_Horizon_Power_,_Reflection_,Sum_Q48,Sum_Q49,_Sharpness_,Result_Q77,_Subsurface_,vec4(0,0,0,0),Result_Q131,Result_Q113,Result_Q121);vec4 Result_Q59;Scale_RGB_B59(Result_Q121,MinAB_Q58,Result_Q59);vec4 sRGB_Q42;FastLinearTosRGB_B42(Result_Q59,sRGB_Q42);vec4 Result_Q31=Blob_Color_Q30+(1.0-Blob_Color_Q30.a)*sRGB_Q42;vec4 Result_Q40=Result_Q31; Result_Q40.a=1.0;vec4 Out_Color=Result_Q40;float Clip_Threshold=0.001;bool To_sRGB=false;gl_FragColor=Out_Color;}`;
ShaderStore.ShadersStore[name10] = shader9;

// node_modules/@babylonjs/gui/3D/materials/mrdl/shaders/mrdlSliderBar.vertex.js
var name11 = "mrdlSliderBarVertexShader";
var shader10 = `uniform mat4 world;uniform mat4 viewProjection;uniform vec3 cameraPosition;attribute vec3 position;attribute vec3 normal;attribute vec2 uv;
#ifdef TANGENT
attribute vec3 tangent;
#else
const vec3 tangent=vec3(0.);
#endif
uniform float _Radius_;uniform float _Bevel_Front_;uniform float _Bevel_Front_Stretch_;uniform float _Bevel_Back_;uniform float _Bevel_Back_Stretch_;uniform float _Radius_Top_Left_;uniform float _Radius_Top_Right_;uniform float _Radius_Bottom_Left_;uniform float _Radius_Bottom_Right_;uniform bool _Bulge_Enabled_;uniform float _Bulge_Height_;uniform float _Bulge_Radius_;uniform float _Sun_Intensity_;uniform float _Sun_Theta_;uniform float _Sun_Phi_;uniform float _Indirect_Diffuse_;uniform vec4 _Albedo_;uniform float _Specular_;uniform float _Shininess_;uniform float _Sharpness_;uniform float _Subsurface_;uniform vec4 _Left_Color_;uniform vec4 _Right_Color_;uniform float _Reflection_;uniform float _Front_Reflect_;uniform float _Edge_Reflect_;uniform float _Power_;uniform vec4 _Sky_Color_;uniform vec4 _Horizon_Color_;uniform vec4 _Ground_Color_;uniform float _Horizon_Power_;uniform sampler2D _Reflection_Map_;uniform sampler2D _Indirect_Environment_;uniform float _Width_;uniform float _Fuzz_;uniform float _Min_Fuzz_;uniform float _Clip_Fade_;uniform float _Hue_Shift_;uniform float _Saturation_Shift_;uniform float _Value_Shift_;uniform vec3 _Blob_Position_;uniform float _Blob_Intensity_;uniform float _Blob_Near_Size_;uniform float _Blob_Far_Size_;uniform float _Blob_Near_Distance_;uniform float _Blob_Far_Distance_;uniform float _Blob_Fade_Length_;uniform float _Blob_Pulse_;uniform float _Blob_Fade_;uniform sampler2D _Blob_Texture_;uniform vec3 _Blob_Position_2_;uniform float _Blob_Near_Size_2_;uniform float _Blob_Pulse_2_;uniform float _Blob_Fade_2_;uniform vec3 _Left_Index_Pos_;uniform vec3 _Right_Index_Pos_;uniform vec3 _Left_Index_Middle_Pos_;uniform vec3 _Right_Index_Middle_Pos_;uniform sampler2D _Decal_;uniform vec2 _Decal_Scale_XY_;uniform bool _Decal_Front_Only_;uniform float _Rim_Intensity_;uniform sampler2D _Rim_Texture_;uniform float _Rim_Hue_Shift_;uniform float _Rim_Saturation_Shift_;uniform float _Rim_Value_Shift_;uniform float _Iridescence_Intensity_;uniform sampler2D _Iridescence_Texture_;uniform bool Use_Global_Left_Index;uniform bool Use_Global_Right_Index;uniform vec4 Global_Left_Index_Tip_Position;uniform vec4 Global_Right_Index_Tip_Position;uniform vec4 Global_Left_Thumb_Tip_Position;uniform vec4 Global_Right_Thumb_Tip_Position;uniform float Global_Left_Index_Tip_Proximity;uniform float Global_Right_Index_Tip_Proximity;varying vec3 vPosition;varying vec3 vNormal;varying vec2 vUV;varying vec3 vTangent;varying vec3 vBinormal;varying vec4 vColor;varying vec4 vExtra1;varying vec4 vExtra2;varying vec4 vExtra3;void Object_To_World_Pos_B12(
vec3 Pos_Object,
out vec3 Pos_World)
{Pos_World=(world*vec4(Pos_Object,1.0)).xyz;}
void Object_To_World_Normal_B32(
vec3 Nrm_Object,
out vec3 Nrm_World)
{Nrm_World=(vec4(Nrm_Object,0.0)).xyz;}
void Blob_Vertex_B23(
vec3 Position,
vec3 Normal,
vec3 Tangent,
vec3 Bitangent,
vec3 Blob_Position,
float Intensity,
float Blob_Near_Size,
float Blob_Far_Size,
float Blob_Near_Distance,
float Blob_Far_Distance,
float Blob_Fade_Length,
float Blob_Pulse,
float Blob_Fade,
out vec4 Blob_Info)
{vec3 blob= (Use_Global_Left_Index ? Global_Left_Index_Tip_Position.xyz : Blob_Position);vec3 delta=blob-Position;float dist=dot(Normal,delta);float lerpValue=clamp((abs(dist)-Blob_Near_Distance)/(Blob_Far_Distance-Blob_Near_Distance),0.0,1.0);float fadeValue=1.0-clamp((abs(dist)-Blob_Far_Distance)/Blob_Fade_Length,0.0,1.0);float size=Blob_Near_Size+(Blob_Far_Size-Blob_Near_Size)*lerpValue;vec2 blobXY=vec2(dot(delta,Tangent),dot(delta,Bitangent))/(0.0001+size);float Fade=fadeValue*Intensity*Blob_Fade;float Distance=(lerpValue*0.5+0.5)*(1.0-Blob_Pulse);Blob_Info=vec4(blobXY.x,blobXY.y,Distance,Fade);}
void Blob_Vertex_B24(
vec3 Position,
vec3 Normal,
vec3 Tangent,
vec3 Bitangent,
vec3 Blob_Position,
float Intensity,
float Blob_Near_Size,
float Blob_Far_Size,
float Blob_Near_Distance,
float Blob_Far_Distance,
float Blob_Fade_Length,
float Blob_Pulse,
float Blob_Fade,
out vec4 Blob_Info)
{vec3 blob= (Use_Global_Right_Index ? Global_Right_Index_Tip_Position.xyz : Blob_Position);vec3 delta=blob-Position;float dist=dot(Normal,delta);float lerpValue=clamp((abs(dist)-Blob_Near_Distance)/(Blob_Far_Distance-Blob_Near_Distance),0.0,1.0);float fadeValue=1.0-clamp((abs(dist)-Blob_Far_Distance)/Blob_Fade_Length,0.0,1.0);float size=Blob_Near_Size+(Blob_Far_Size-Blob_Near_Size)*lerpValue;vec2 blobXY=vec2(dot(delta,Tangent),dot(delta,Bitangent))/(0.0001+size);float Fade=fadeValue*Intensity*Blob_Fade;float Distance=(lerpValue*0.5+0.5)*(1.0-Blob_Pulse);Blob_Info=vec4(blobXY.x,blobXY.y,Distance,Fade);}
void Move_Verts_B130(
float Anisotropy,
vec3 P,
float Radius,
float Bevel,
vec3 Normal_Object,
float ScaleZ,
float Stretch,
out vec3 New_P,
out vec2 New_UV,
out float Radial_Gradient,
out vec3 Radial_Dir,
out vec3 New_Normal)
{vec2 UV=P.xy*2.0+0.5;vec2 center=clamp(UV,0.0,1.0);vec2 delta=UV-center;float deltad=(length(delta)*2.0);float f=(Bevel+(Radius-Bevel)*Stretch)/Radius;float innerd=clamp(deltad*2.0,0.0,1.0);float outerd=clamp(deltad*2.0-1.0,0.0,1.0);float bevelAngle=outerd*3.14159*0.5;float sinb=sin(bevelAngle);float cosb=cos(bevelAngle);float beveld=(1.0-f)*innerd+f*sinb;float br=outerd;vec2 r2=2.0*vec2(Radius/Anisotropy,Radius);float dir=P.z<0.0001 ? 1.0 : -1.0;New_UV=center+r2*((0.5-center)+normalize(delta+vec2(0.0,0.000001))*beveld*0.5);New_P=vec3(New_UV-0.5,P.z+dir*(1.0-cosb)*Bevel*ScaleZ);Radial_Gradient=clamp((deltad-0.5)*2.0,0.0,1.0);Radial_Dir=vec3(delta*r2,0.0);vec3 beveledNormal=cosb*Normal_Object+sinb*vec3(delta.x,delta.y,0.0);New_Normal=Normal_Object.z==0.0 ? Normal_Object : beveledNormal;}
void Object_To_World_Dir_B60(
vec3 Dir_Object,
out vec3 Normal_World,
out vec3 Normal_World_N,
out float Normal_Length)
{Normal_World=(world*vec4(Dir_Object,0.0)).xyz;Normal_Length=length(Normal_World);Normal_World_N=Normal_World/Normal_Length;}
void To_XYZ_B78(
vec3 Vec3,
out float X,
out float Y,
out float Z)
{X=Vec3.x;Y=Vec3.y;Z=Vec3.z;}
void Conditional_Float_B93(
bool Which,
float If_True,
float If_False,
out float Result)
{Result=Which ? If_True : If_False;}
void Object_To_World_Dir_B28(
vec3 Dir_Object,
out vec3 Binormal_World,
out vec3 Binormal_World_N,
out float Binormal_Length)
{Binormal_World=(world*vec4(Dir_Object,0.0)).xyz;Binormal_Length=length(Binormal_World);Binormal_World_N=Binormal_World/Binormal_Length;}
void Pick_Radius_B69(
float Radius,
float Radius_Top_Left,
float Radius_Top_Right,
float Radius_Bottom_Left,
float Radius_Bottom_Right,
vec3 Position,
out float Result)
{bool whichY=Position.y>0.0;Result=Position.x<0.0 ? (whichY ? Radius_Top_Left : Radius_Bottom_Left) : (whichY ? Radius_Top_Right : Radius_Bottom_Right);Result*=Radius;}
void Conditional_Float_B36(
bool Which,
float If_True,
float If_False,
out float Result)
{Result=Which ? If_True : If_False;}
void Greater_Than_B37(
float Left,
float Right,
out bool Not_Greater_Than,
out bool Greater_Than)
{Greater_Than=Left>Right;Not_Greater_Than=!Greater_Than;}
void Remap_Range_B105(
float In_Min,
float In_Max,
float Out_Min,
float Out_Max,
float In,
out float Out)
{Out=mix(Out_Min,Out_Max,clamp((In-In_Min)/(In_Max-In_Min),0.0,1.0));}
void main()
{vec2 XY_Q85;XY_Q85=(uv-vec2(0.5,0.5))*_Decal_Scale_XY_+vec2(0.5,0.5);vec3 Tangent_World_Q27;vec3 Tangent_World_N_Q27;float Tangent_Length_Q27;Tangent_World_Q27=(world*vec4(vec3(1,0,0),0.0)).xyz;Tangent_Length_Q27=length(Tangent_World_Q27);Tangent_World_N_Q27=Tangent_World_Q27/Tangent_Length_Q27;vec3 Normal_World_Q60;vec3 Normal_World_N_Q60;float Normal_Length_Q60;Object_To_World_Dir_B60(vec3(0,0,1),Normal_World_Q60,Normal_World_N_Q60,Normal_Length_Q60);float X_Q78;float Y_Q78;float Z_Q78;To_XYZ_B78(position,X_Q78,Y_Q78,Z_Q78);vec3 Nrm_World_Q26;Nrm_World_Q26=normalize((world*vec4(normal,0.0)).xyz);vec3 Binormal_World_Q28;vec3 Binormal_World_N_Q28;float Binormal_Length_Q28;Object_To_World_Dir_B28(vec3(0,1,0),Binormal_World_Q28,Binormal_World_N_Q28,Binormal_Length_Q28);float Anisotropy_Q29=Tangent_Length_Q27/Binormal_Length_Q28;float Result_Q69;Pick_Radius_B69(_Radius_,_Radius_Top_Left_,_Radius_Top_Right_,_Radius_Bottom_Left_,_Radius_Bottom_Right_,position,Result_Q69);float Anisotropy_Q53=Binormal_Length_Q28/Normal_Length_Q60;bool Not_Greater_Than_Q37;bool Greater_Than_Q37;Greater_Than_B37(Z_Q78,0.0,Not_Greater_Than_Q37,Greater_Than_Q37);vec4 Linear_Q101;Linear_Q101.rgb=clamp(_Left_Color_.rgb*_Left_Color_.rgb,0.0,1.0);Linear_Q101.a=_Left_Color_.a;vec4 Linear_Q102;Linear_Q102.rgb=clamp(_Right_Color_.rgb*_Right_Color_.rgb,0.0,1.0);Linear_Q102.a=_Right_Color_.a;vec3 Difference_Q61=vec3(0,0,0)-Normal_World_N_Q60;vec4 Out_Color_Q34=vec4(X_Q78,Y_Q78,Z_Q78,1);float Result_Q36;Conditional_Float_B36(Greater_Than_Q37,_Bevel_Back_,_Bevel_Front_,Result_Q36);float Result_Q94;Conditional_Float_B36(Greater_Than_Q37,_Bevel_Back_Stretch_,_Bevel_Front_Stretch_,Result_Q94);vec3 New_P_Q130;vec2 New_UV_Q130;float Radial_Gradient_Q130;vec3 Radial_Dir_Q130;vec3 New_Normal_Q130;Move_Verts_B130(Anisotropy_Q29,position,Result_Q69,Result_Q36,normal,Anisotropy_Q53,Result_Q94,New_P_Q130,New_UV_Q130,Radial_Gradient_Q130,Radial_Dir_Q130,New_Normal_Q130);float X_Q98;float Y_Q98;X_Q98=New_UV_Q130.x;Y_Q98=New_UV_Q130.y;vec3 Pos_World_Q12;Object_To_World_Pos_B12(New_P_Q130,Pos_World_Q12);vec3 Nrm_World_Q32;Object_To_World_Normal_B32(New_Normal_Q130,Nrm_World_Q32);vec4 Blob_Info_Q23;
#if BLOB_ENABLE
Blob_Vertex_B23(Pos_World_Q12,Nrm_World_Q26,Tangent_World_N_Q27,Binormal_World_N_Q28,_Blob_Position_,_Blob_Intensity_,_Blob_Near_Size_,_Blob_Far_Size_,_Blob_Near_Distance_,_Blob_Far_Distance_,_Blob_Fade_Length_,_Blob_Pulse_,_Blob_Fade_,Blob_Info_Q23);
#else
Blob_Info_Q23=vec4(0,0,0,0);
#endif
vec4 Blob_Info_Q24;
#if BLOB_ENABLE_2
Blob_Vertex_B24(Pos_World_Q12,Nrm_World_Q26,Tangent_World_N_Q27,Binormal_World_N_Q28,_Blob_Position_2_,_Blob_Intensity_,_Blob_Near_Size_2_,_Blob_Far_Size_,_Blob_Near_Distance_,_Blob_Far_Distance_,_Blob_Fade_Length_,_Blob_Pulse_2_,_Blob_Fade_2_,Blob_Info_Q24);
#else
Blob_Info_Q24=vec4(0,0,0,0);
#endif
float Out_Q105;Remap_Range_B105(0.0,1.0,0.0,1.0,X_Q98,Out_Q105);float X_Q86;float Y_Q86;float Z_Q86;To_XYZ_B78(Nrm_World_Q32,X_Q86,Y_Q86,Z_Q86);vec4 Color_At_T_Q97=mix(Linear_Q101,Linear_Q102,Out_Q105);float Minus_F_Q87=-Z_Q86;float R_Q99;float G_Q99;float B_Q99;float A_Q99;R_Q99=Color_At_T_Q97.r; G_Q99=Color_At_T_Q97.g; B_Q99=Color_At_T_Q97.b; A_Q99=Color_At_T_Q97.a;float ClampF_Q88=clamp(0.0,Minus_F_Q87,1.0);float Result_Q93;Conditional_Float_B93(_Decal_Front_Only_,ClampF_Q88,1.0,Result_Q93);vec4 Vec4_Q89=vec4(Result_Q93,Radial_Gradient_Q130,G_Q99,B_Q99);vec3 Position=Pos_World_Q12;vec3 Normal=Nrm_World_Q32;vec2 UV=XY_Q85;vec3 Tangent=Tangent_World_N_Q27;vec3 Binormal=Difference_Q61;vec4 Color=Out_Color_Q34;vec4 Extra1=Vec4_Q89;vec4 Extra2=Blob_Info_Q23;vec4 Extra3=Blob_Info_Q24;gl_Position=viewProjection*vec4(Position,1);vPosition=Position;vNormal=Normal;vUV=UV;vTangent=Tangent;vBinormal=Binormal;vColor=Color;vExtra1=Extra1;vExtra2=Extra2;vExtra3=Extra3;}`;
ShaderStore.ShadersStore[name11] = shader10;

// node_modules/@babylonjs/gui/3D/materials/mrdl/mrdlSliderBarMaterial.js
var MRDLSliderBarMaterialDefines = class extends MaterialDefines {
  constructor() {
    super();
    this.SKY_ENABLED = true;
    this.BLOB_ENABLE_2 = true;
    this.IRIDESCENCE_ENABLED = true;
    this._needNormals = true;
    this._needUVs = true;
    this.rebuild();
  }
};
var MRDLSliderBarMaterial = class _MRDLSliderBarMaterial extends PushMaterial {
  constructor(name22, scene) {
    super(name22, scene);
    this.radius = 0.6;
    this.bevelFront = 0.6;
    this.bevelFrontStretch = 0.077;
    this.bevelBack = 0;
    this.bevelBackStretch = 0;
    this.radiusTopLeft = 1;
    this.radiusTopRight = 1;
    this.radiusBottomLeft = 1;
    this.radiusBottomRight = 1;
    this.bulgeEnabled = false;
    this.bulgeHeight = -0.323;
    this.bulgeRadius = 0.73;
    this.sunIntensity = 1.102;
    this.sunTheta = 0.76;
    this.sunPhi = 0.526;
    this.indirectDiffuse = 0.658;
    this.albedo = new Color4(0.0117647, 0.505882, 0.996078, 1);
    this.specular = 0;
    this.shininess = 10;
    this.sharpness = 0;
    this.subsurface = 0;
    this.leftGradientColor = new Color4(0.0117647, 0.505882, 0.996078, 1);
    this.rightGradientColor = new Color4(0.0117647, 0.505882, 0.996078, 1);
    this.reflection = 0.749;
    this.frontReflect = 0;
    this.edgeReflect = 0.09;
    this.power = 8.13;
    this.skyColor = new Color4(0.0117647, 0.964706, 0.996078, 1);
    this.horizonColor = new Color4(0.0117647, 0.333333, 0.996078, 1);
    this.groundColor = new Color4(0, 0.254902, 0.996078, 1);
    this.horizonPower = 1;
    this.width = 0.02;
    this.fuzz = 0.5;
    this.minFuzz = 1e-3;
    this.clipFade = 0.01;
    this.hueShift = 0;
    this.saturationShift = 0;
    this.valueShift = 0;
    this.blobPosition = new Vector3(0, 0, 0.1);
    this.blobIntensity = 0.5;
    this.blobNearSize = 0.01;
    this.blobFarSize = 0.03;
    this.blobNearDistance = 0;
    this.blobFarDistance = 0.08;
    this.blobFadeLength = 0.576;
    this.blobPulse = 0;
    this.blobFade = 1;
    this.blobPosition2 = new Vector3(0.2, 0, 0.1);
    this.blobNearSize2 = 0.01;
    this.blobPulse2 = 0;
    this.blobFade2 = 1;
    this.blobTexture = new Texture("", this.getScene());
    this.leftIndexPosition = new Vector3(0, 0, 1);
    this.rightIndexPosition = new Vector3(-1, -1, -1);
    this.leftIndexMiddlePosition = new Vector3(0, 0, 0);
    this.rightIndexMiddlePosition = new Vector3(0, 0, 0);
    this.decalScaleXY = new Vector2(1.5, 1.5);
    this.decalFrontOnly = true;
    this.rimIntensity = 0.287;
    this.rimHueShift = 0;
    this.rimSaturationShift = 0;
    this.rimValueShift = -1;
    this.iridescenceIntensity = 0;
    this.useGlobalLeftIndex = 1;
    this.useGlobalRightIndex = 1;
    this.globalLeftIndexTipProximity = 0;
    this.globalRightIndexTipProximity = 0;
    this.globalLeftIndexTipPosition = new Vector4(0.5, 0, -0.55, 1);
    this.globaRightIndexTipPosition = new Vector4(0, 0, 0, 1);
    this.globalLeftThumbTipPosition = new Vector4(0.5, 0, -0.55, 1);
    this.globalRightThumbTipPosition = new Vector4(0, 0, 0, 1);
    this.globalLeftIndexMiddlePosition = new Vector4(0.5, 0, -0.55, 1);
    this.globalRightIndexMiddlePosition = new Vector4(0, 0, 0, 1);
    this.alphaMode = Constants.ALPHA_DISABLE;
    this.backFaceCulling = false;
    this._blueGradientTexture = new Texture(_MRDLSliderBarMaterial.BLUE_GRADIENT_TEXTURE_URL, this.getScene(), true, false, Texture.NEAREST_SAMPLINGMODE);
    this._decalTexture = new Texture("", this.getScene());
    this._reflectionMapTexture = new Texture("", this.getScene());
    this._indirectEnvTexture = new Texture("", this.getScene());
  }
  needAlphaBlending() {
    return false;
  }
  needAlphaTesting() {
    return false;
  }
  getAlphaTestTexture() {
    return null;
  }
  // Methods
  isReadyForSubMesh(mesh, subMesh) {
    const drawWrapper = subMesh._drawWrapper;
    if (this.isFrozen) {
      if (drawWrapper.effect && drawWrapper._wasPreviouslyReady) {
        return true;
      }
    }
    if (!subMesh.materialDefines) {
      subMesh.materialDefines = new MRDLSliderBarMaterialDefines();
    }
    const defines = subMesh.materialDefines;
    const scene = this.getScene();
    if (this._isReadyForSubMesh(subMesh)) {
      return true;
    }
    const engine = scene.getEngine();
    PrepareDefinesForAttributes(mesh, defines, false, false);
    if (defines.isDirty) {
      defines.markAsProcessed();
      scene.resetCachedMaterial();
      const fallbacks = new EffectFallbacks();
      if (defines.FOG) {
        fallbacks.addFallback(1, "FOG");
      }
      HandleFallbacksForShadows(defines, fallbacks);
      defines.IMAGEPROCESSINGPOSTPROCESS = scene.imageProcessingConfiguration.applyByPostProcess;
      const attribs = [VertexBuffer.PositionKind];
      if (defines.NORMAL) {
        attribs.push(VertexBuffer.NormalKind);
      }
      if (defines.UV1) {
        attribs.push(VertexBuffer.UVKind);
      }
      if (defines.UV2) {
        attribs.push(VertexBuffer.UV2Kind);
      }
      if (defines.VERTEXCOLOR) {
        attribs.push(VertexBuffer.ColorKind);
      }
      if (defines.TANGENT) {
        attribs.push(VertexBuffer.TangentKind);
      }
      PrepareAttributesForInstances(attribs, defines);
      const shaderName = "mrdlSliderBar";
      const join = defines.toString();
      const uniforms = [
        "world",
        "viewProjection",
        "cameraPosition",
        "_Radius_",
        "_Bevel_Front_",
        "_Bevel_Front_Stretch_",
        "_Bevel_Back_",
        "_Bevel_Back_Stretch_",
        "_Radius_Top_Left_",
        "_Radius_Top_Right_",
        "_Radius_Bottom_Left_",
        "_Radius_Bottom_Right_",
        "_Bulge_Enabled_",
        "_Bulge_Height_",
        "_Bulge_Radius_",
        "_Sun_Intensity_",
        "_Sun_Theta_",
        "_Sun_Phi_",
        "_Indirect_Diffuse_",
        "_Albedo_",
        "_Specular_",
        "_Shininess_",
        "_Sharpness_",
        "_Subsurface_",
        "_Left_Color_",
        "_Right_Color_",
        "_Reflection_",
        "_Front_Reflect_",
        "_Edge_Reflect_",
        "_Power_",
        "_Sky_Color_",
        "_Horizon_Color_",
        "_Ground_Color_",
        "_Horizon_Power_",
        "_Reflection_Map_",
        "_Indirect_Environment_",
        "_Width_",
        "_Fuzz_",
        "_Min_Fuzz_",
        "_Clip_Fade_",
        "_Hue_Shift_",
        "_Saturation_Shift_",
        "_Value_Shift_",
        "_Blob_Position_",
        "_Blob_Intensity_",
        "_Blob_Near_Size_",
        "_Blob_Far_Size_",
        "_Blob_Near_Distance_",
        "_Blob_Far_Distance_",
        "_Blob_Fade_Length_",
        "_Blob_Pulse_",
        "_Blob_Fade_",
        "_Blob_Texture_",
        "_Blob_Position_2_",
        "_Blob_Near_Size_2_",
        "_Blob_Pulse_2_",
        "_Blob_Fade_2_",
        "_Left_Index_Pos_",
        "_Right_Index_Pos_",
        "_Left_Index_Middle_Pos_",
        "_Right_Index_Middle_Pos_",
        "_Decal_",
        "_Decal_Scale_XY_",
        "_Decal_Front_Only_",
        "_Rim_Intensity_",
        "_Rim_Texture_",
        "_Rim_Hue_Shift_",
        "_Rim_Saturation_Shift_",
        "_Rim_Value_Shift_",
        "_Iridescence_Intensity_",
        "_Iridescence_Texture_",
        "Use_Global_Left_Index",
        "Use_Global_Right_Index",
        "Global_Left_Index_Tip_Position",
        "Global_Right_Index_Tip_Position",
        "Global_Left_Thumb_Tip_Position",
        "Global_Right_Thumb_Tip_Position",
        "Global_Left_Index_Middle_Position;",
        "Global_Right_Index_Middle_Position",
        "Global_Left_Index_Tip_Proximity",
        "Global_Right_Index_Tip_Proximity"
      ];
      const samplers = ["_Rim_Texture_", "_Iridescence_Texture_"];
      const uniformBuffers = [];
      PrepareUniformsAndSamplersList({
        uniformsNames: uniforms,
        uniformBuffersNames: uniformBuffers,
        samplers,
        defines,
        maxSimultaneousLights: 4
      });
      subMesh.setEffect(scene.getEngine().createEffect(shaderName, {
        attributes: attribs,
        uniformsNames: uniforms,
        uniformBuffersNames: uniformBuffers,
        samplers,
        defines: join,
        fallbacks,
        onCompiled: this.onCompiled,
        onError: this.onError,
        indexParameters: { maxSimultaneousLights: 4 }
      }, engine), defines, this._materialContext);
    }
    if (!subMesh.effect || !subMesh.effect.isReady()) {
      return false;
    }
    defines._renderId = scene.getRenderId();
    drawWrapper._wasPreviouslyReady = true;
    return true;
  }
  bindForSubMesh(world, mesh, subMesh) {
    const defines = subMesh.materialDefines;
    if (!defines) {
      return;
    }
    const effect = subMesh.effect;
    if (!effect) {
      return;
    }
    this._activeEffect = effect;
    this.bindOnlyWorldMatrix(world);
    this._activeEffect.setMatrix("viewProjection", this.getScene().getTransformMatrix());
    this._activeEffect.setVector3("cameraPosition", this.getScene().activeCamera.position);
    this._activeEffect.setFloat("_Radius_", this.radius);
    this._activeEffect.setFloat("_Bevel_Front_", this.bevelFront);
    this._activeEffect.setFloat("_Bevel_Front_Stretch_", this.bevelFrontStretch);
    this._activeEffect.setFloat("_Bevel_Back_", this.bevelBack);
    this._activeEffect.setFloat("_Bevel_Back_Stretch_", this.bevelBackStretch);
    this._activeEffect.setFloat("_Radius_Top_Left_", this.radiusTopLeft);
    this._activeEffect.setFloat("_Radius_Top_Right_", this.radiusTopRight);
    this._activeEffect.setFloat("_Radius_Bottom_Left_", this.radiusBottomLeft);
    this._activeEffect.setFloat("_Radius_Bottom_Right_", this.radiusBottomRight);
    this._activeEffect.setFloat("_Bulge_Enabled_", this.bulgeEnabled ? 1 : 0);
    this._activeEffect.setFloat("_Bulge_Height_", this.bulgeHeight);
    this._activeEffect.setFloat("_Bulge_Radius_", this.bulgeRadius);
    this._activeEffect.setFloat("_Sun_Intensity_", this.sunIntensity);
    this._activeEffect.setFloat("_Sun_Theta_", this.sunTheta);
    this._activeEffect.setFloat("_Sun_Phi_", this.sunPhi);
    this._activeEffect.setFloat("_Indirect_Diffuse_", this.indirectDiffuse);
    this._activeEffect.setDirectColor4("_Albedo_", this.albedo);
    this._activeEffect.setFloat("_Specular_", this.specular);
    this._activeEffect.setFloat("_Shininess_", this.shininess);
    this._activeEffect.setFloat("_Sharpness_", this.sharpness);
    this._activeEffect.setFloat("_Subsurface_", this.subsurface);
    this._activeEffect.setDirectColor4("_Left_Color_", this.leftGradientColor);
    this._activeEffect.setDirectColor4("_Right_Color_", this.rightGradientColor);
    this._activeEffect.setFloat("_Reflection_", this.reflection);
    this._activeEffect.setFloat("_Front_Reflect_", this.frontReflect);
    this._activeEffect.setFloat("_Edge_Reflect_", this.edgeReflect);
    this._activeEffect.setFloat("_Power_", this.power);
    this._activeEffect.setDirectColor4("_Sky_Color_", this.skyColor);
    this._activeEffect.setDirectColor4("_Horizon_Color_", this.horizonColor);
    this._activeEffect.setDirectColor4("_Ground_Color_", this.groundColor);
    this._activeEffect.setFloat("_Horizon_Power_", this.horizonPower);
    this._activeEffect.setTexture("_Reflection_Map_", this._reflectionMapTexture);
    this._activeEffect.setTexture("_Indirect_Environment_", this._indirectEnvTexture);
    this._activeEffect.setFloat("_Width_", this.width);
    this._activeEffect.setFloat("_Fuzz_", this.fuzz);
    this._activeEffect.setFloat("_Min_Fuzz_", this.minFuzz);
    this._activeEffect.setFloat("_Clip_Fade_", this.clipFade);
    this._activeEffect.setFloat("_Hue_Shift_", this.hueShift);
    this._activeEffect.setFloat("_Saturation_Shift_", this.saturationShift);
    this._activeEffect.setFloat("_Value_Shift_", this.valueShift);
    this._activeEffect.setVector3("_Blob_Position_", this.blobPosition);
    this._activeEffect.setFloat("_Blob_Intensity_", this.blobIntensity);
    this._activeEffect.setFloat("_Blob_Near_Size_", this.blobNearSize);
    this._activeEffect.setFloat("_Blob_Far_Size_", this.blobFarSize);
    this._activeEffect.setFloat("_Blob_Near_Distance_", this.blobNearDistance);
    this._activeEffect.setFloat("_Blob_Far_Distance_", this.blobFarDistance);
    this._activeEffect.setFloat("_Blob_Fade_Length_", this.blobFadeLength);
    this._activeEffect.setFloat("_Blob_Pulse_", this.blobPulse);
    this._activeEffect.setFloat("_Blob_Fade_", this.blobFade);
    this._activeEffect.setTexture("_Blob_Texture_", this.blobTexture);
    this._activeEffect.setVector3("_Blob_Position_2_", this.blobPosition2);
    this._activeEffect.setFloat("_Blob_Near_Size_2_", this.blobNearSize2);
    this._activeEffect.setFloat("_Blob_Pulse_2_", this.blobPulse2);
    this._activeEffect.setFloat("_Blob_Fade_2_", this.blobFade2);
    this._activeEffect.setVector3("_Left_Index_Pos_", this.leftIndexPosition);
    this._activeEffect.setVector3("_Right_Index_Pos_", this.rightIndexPosition);
    this._activeEffect.setVector3("_Left_Index_Middle_Pos_", this.leftIndexMiddlePosition);
    this._activeEffect.setVector3("_Right_Index_Middle_Pos_", this.rightIndexMiddlePosition);
    this._activeEffect.setTexture("_Decal_", this._decalTexture);
    this._activeEffect.setVector2("_Decal_Scale_XY_", this.decalScaleXY);
    this._activeEffect.setFloat("_Decal_Front_Only_", this.decalFrontOnly ? 1 : 0);
    this._activeEffect.setFloat("_Rim_Intensity_", this.rimIntensity);
    this._activeEffect.setTexture("_Rim_Texture_", this._blueGradientTexture);
    this._activeEffect.setFloat("_Rim_Hue_Shift_", this.rimHueShift);
    this._activeEffect.setFloat("_Rim_Saturation_Shift_", this.rimSaturationShift);
    this._activeEffect.setFloat("_Rim_Value_Shift_", this.rimValueShift);
    this._activeEffect.setFloat("_Iridescence_Intensity_", this.iridescenceIntensity);
    this._activeEffect.setTexture("_Iridescence_Texture_", this._blueGradientTexture);
    this._activeEffect.setFloat("Use_Global_Left_Index", this.useGlobalLeftIndex);
    this._activeEffect.setFloat("Use_Global_Right_Index", this.useGlobalRightIndex);
    this._activeEffect.setVector4("Global_Left_Index_Tip_Position", this.globalLeftIndexTipPosition);
    this._activeEffect.setVector4("Global_Right_Index_Tip_Position", this.globaRightIndexTipPosition);
    this._activeEffect.setVector4("Global_Left_Thumb_Tip_Position", this.globalLeftThumbTipPosition);
    this._activeEffect.setVector4("Global_Right_Thumb_Tip_Position", this.globalRightThumbTipPosition);
    this._activeEffect.setVector4("Global_Left_Index_Middle_Position", this.globalLeftIndexMiddlePosition);
    this._activeEffect.setVector4("Global_Right_Index_Middle_Position", this.globalRightIndexMiddlePosition);
    this._activeEffect.setFloat("Global_Left_Index_Tip_Proximity", this.globalLeftIndexTipProximity);
    this._activeEffect.setFloat("Global_Right_Index_Tip_Proximity", this.globalRightIndexTipProximity);
    this._afterBind(mesh, this._activeEffect, subMesh);
  }
  /**
   * Get the list of animatables in the material.
   * @returns the list of animatables object used in the material
   */
  getAnimatables() {
    return [];
  }
  dispose(forceDisposeEffect) {
    super.dispose(forceDisposeEffect);
    this._reflectionMapTexture.dispose();
    this._indirectEnvTexture.dispose();
    this._blueGradientTexture.dispose();
    this._decalTexture.dispose();
  }
  clone(name22) {
    return SerializationHelper.Clone(() => new _MRDLSliderBarMaterial(name22, this.getScene()), this);
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.customType = "BABYLON.MRDLSliderBarMaterial";
    return serializationObject;
  }
  getClassName() {
    return "MRDLSliderBarMaterial";
  }
  // Statics
  static Parse(source, scene, rootUrl) {
    return SerializationHelper.Parse(() => new _MRDLSliderBarMaterial(source.name, scene), source, scene, rootUrl);
  }
};
MRDLSliderBarMaterial.BLUE_GRADIENT_TEXTURE_URL = "https://assets.babylonjs.com/meshes/MRTK/MRDL/mrtk-mrdl-blue-gradient.png";
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "radius", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "bevelFront", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "bevelFrontStretch", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "bevelBack", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "bevelBackStretch", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "radiusTopLeft", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "radiusTopRight", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "radiusBottomLeft", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "radiusBottomRight", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "bulgeEnabled", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "bulgeHeight", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "bulgeRadius", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "sunIntensity", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "sunTheta", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "sunPhi", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "indirectDiffuse", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "albedo", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "specular", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "shininess", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "sharpness", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "subsurface", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "leftGradientColor", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "rightGradientColor", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "reflection", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "frontReflect", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "edgeReflect", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "power", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "skyColor", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "horizonColor", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "groundColor", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "horizonPower", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "width", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "fuzz", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "minFuzz", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "clipFade", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "hueShift", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "saturationShift", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "valueShift", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "blobPosition", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "blobIntensity", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "blobNearSize", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "blobFarSize", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "blobNearDistance", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "blobFarDistance", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "blobFadeLength", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "blobPulse", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "blobFade", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "blobPosition2", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "blobNearSize2", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "blobPulse2", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "blobFade2", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "blobTexture", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "leftIndexPosition", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "rightIndexPosition", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "leftIndexMiddlePosition", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "rightIndexMiddlePosition", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "decalScaleXY", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "decalFrontOnly", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "rimIntensity", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "rimHueShift", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "rimSaturationShift", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "rimValueShift", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "iridescenceIntensity", void 0);
RegisterClass("BABYLON.GUI.MRDLSliderBarMaterial", MRDLSliderBarMaterial);

// node_modules/@babylonjs/gui/3D/materials/mrdl/shaders/mrdlSliderThumb.fragment.js
var name12 = "mrdlSliderThumbPixelShader";
var shader11 = `uniform vec3 cameraPosition;varying vec3 vPosition;varying vec3 vNormal;varying vec2 vUV;varying vec3 vTangent;varying vec3 vBinormal;varying vec4 vColor;varying vec4 vExtra1;varying vec4 vExtra2;varying vec4 vExtra3;uniform float _Radius_;uniform float _Bevel_Front_;uniform float _Bevel_Front_Stretch_;uniform float _Bevel_Back_;uniform float _Bevel_Back_Stretch_;uniform float _Radius_Top_Left_;uniform float _Radius_Top_Right_;uniform float _Radius_Bottom_Left_;uniform float _Radius_Bottom_Right_;uniform bool _Bulge_Enabled_;uniform float _Bulge_Height_;uniform float _Bulge_Radius_;uniform float _Sun_Intensity_;uniform float _Sun_Theta_;uniform float _Sun_Phi_;uniform float _Indirect_Diffuse_;uniform vec4 _Albedo_;uniform float _Specular_;uniform float _Shininess_;uniform float _Sharpness_;uniform float _Subsurface_;uniform vec4 _Left_Color_;uniform vec4 _Right_Color_;uniform float _Reflection_;uniform float _Front_Reflect_;uniform float _Edge_Reflect_;uniform float _Power_;uniform vec4 _Sky_Color_;uniform vec4 _Horizon_Color_;uniform vec4 _Ground_Color_;uniform float _Horizon_Power_;uniform sampler2D _Reflection_Map_;uniform sampler2D _Indirect_Environment_;uniform float _Width_;uniform float _Fuzz_;uniform float _Min_Fuzz_;uniform float _Clip_Fade_;uniform float _Hue_Shift_;uniform float _Saturation_Shift_;uniform float _Value_Shift_;uniform vec3 _Blob_Position_;uniform float _Blob_Intensity_;uniform float _Blob_Near_Size_;uniform float _Blob_Far_Size_;uniform float _Blob_Near_Distance_;uniform float _Blob_Far_Distance_;uniform float _Blob_Fade_Length_;uniform float _Blob_Pulse_;uniform float _Blob_Fade_;uniform sampler2D _Blob_Texture_;uniform vec3 _Blob_Position_2_;uniform float _Blob_Near_Size_2_;uniform float _Blob_Pulse_2_;uniform float _Blob_Fade_2_;uniform vec3 _Left_Index_Pos_;uniform vec3 _Right_Index_Pos_;uniform vec3 _Left_Index_Middle_Pos_;uniform vec3 _Right_Index_Middle_Pos_;uniform sampler2D _Decal_;uniform vec2 _Decal_Scale_XY_;uniform bool _Decal_Front_Only_;uniform float _Rim_Intensity_;uniform sampler2D _Rim_Texture_;uniform float _Rim_Hue_Shift_;uniform float _Rim_Saturation_Shift_;uniform float _Rim_Value_Shift_;uniform float _Iridescence_Intensity_;uniform sampler2D _Iridescence_Texture_;uniform bool Use_Global_Left_Index;uniform bool Use_Global_Right_Index;uniform vec4 Global_Left_Index_Tip_Position;uniform vec4 Global_Right_Index_Tip_Position;uniform vec4 Global_Left_Thumb_Tip_Position;uniform vec4 Global_Right_Thumb_Tip_Position;uniform vec4 Global_Left_Index_Middle_Position;uniform vec4 Global_Right_Index_Middle_Position;uniform float Global_Left_Index_Tip_Proximity;uniform float Global_Right_Index_Tip_Proximity;void Blob_Fragment_B180(
sampler2D Blob_Texture,
vec4 Blob_Info1,
vec4 Blob_Info2,
out vec4 Blob_Color)
{float k1=dot(Blob_Info1.xy,Blob_Info1.xy);float k2=dot(Blob_Info2.xy,Blob_Info2.xy);vec3 closer=k1<k2 ? vec3(k1,Blob_Info1.z,Blob_Info1.w) : vec3(k2,Blob_Info2.z,Blob_Info2.w);Blob_Color=closer.z*texture(Blob_Texture,vec2(vec2(sqrt(closer.x),closer.y).x,1.0-vec2(sqrt(closer.x),closer.y).y))*clamp(1.0-closer.x,0.0,1.0);}
void FastLinearTosRGB_B192(
vec4 Linear,
out vec4 sRGB)
{sRGB.rgb=sqrt(clamp(Linear.rgb,0.0,1.0));sRGB.a=Linear.a;}
void Scale_RGB_B209(
vec4 Color,
float Scalar,
out vec4 Result)
{Result=vec4(Scalar,Scalar,Scalar,1)*Color;}
void Fragment_Main_B271(
float Sun_Intensity,
float Sun_Theta,
float Sun_Phi,
vec3 Normal,
vec4 Albedo,
float Fresnel_Reflect,
float Shininess,
vec3 Incident,
vec4 Horizon_Color,
vec4 Sky_Color,
vec4 Ground_Color,
float Indirect_Diffuse,
float Specular,
float Horizon_Power,
float Reflection,
vec4 Reflection_Sample,
vec4 Indirect_Sample,
float Sharpness,
float SSS,
float Subsurface,
vec4 Translucence,
vec4 Rim_Light,
vec4 Iridescence,
out vec4 Result)
{float theta=Sun_Theta*2.0*3.14159;float phi=Sun_Phi*3.14159;vec3 lightDir= vec3(cos(phi)*cos(theta),sin(phi),cos(phi)*sin(theta));float NdotL=max(dot(lightDir,Normal),0.0);vec3 R=reflect(Incident,Normal);float RdotL=max(0.0,dot(R,lightDir));float specular=pow(RdotL,Shininess);specular=mix(specular,smoothstep(0.495*Sharpness,1.0-0.495*Sharpness,specular),Sharpness);vec4 gi=mix(Ground_Color,Sky_Color,Normal.y*0.5+0.5);Result=((Sun_Intensity*NdotL+Indirect_Sample*Indirect_Diffuse+Translucence)*(1.0+SSS*Subsurface))*Albedo*(1.0-Fresnel_Reflect)+(Sun_Intensity*specular*Specular+Fresnel_Reflect*Reflection*Reflection_Sample)+Fresnel_Reflect*Rim_Light+Iridescence;}
void Bulge_B229(
bool Enabled,
vec3 Normal,
vec3 Tangent,
float Bulge_Height,
vec4 UV,
float Bulge_Radius,
vec3 ButtonN,
out vec3 New_Normal)
{vec2 xy=clamp(UV.xy*2.0,vec2(-1,-1),vec2(1,1));vec3 B=(cross(Normal,Tangent));float k=-clamp(1.0-length(xy)/Bulge_Radius,0.0,1.0)*Bulge_Height;k=sin(k*3.14159*0.5);k*=smoothstep(0.9998,0.9999,abs(dot(ButtonN,Normal)));New_Normal=Normal*sqrt(1.0-k*k)+(xy.x*Tangent+xy.y*B)*k;New_Normal=Enabled ? New_Normal : Normal;}
void SSS_B227(
vec3 ButtonN,
vec3 Normal,
vec3 Incident,
out float Result)
{float NdotI=abs(dot(Normal,Incident));float BdotI=abs(dot(ButtonN,Incident));Result=(abs(NdotI-BdotI)); }
void FingerOcclusion_B217(
float Width,
float DistToCenter,
float Fuzz,
float Min_Fuzz,
vec3 Position,
vec3 Forward,
vec3 Nearest,
float Fade_Out,
out float NotInShadow)
{float d=dot((Nearest-Position),Forward);float sh=smoothstep(Width*0.5,Width*0.5+Fuzz*max(d,0.0)+Min_Fuzz,DistToCenter);NotInShadow=1.0-(1.0-sh)*smoothstep(-Fade_Out,0.0,d);}
void FingerOcclusion_B218(
float Width,
float DistToCenter,
float Fuzz,
float Min_Fuzz,
vec3 Position,
vec3 Forward,
vec3 Nearest,
float Fade_Out,
out float NotInShadow)
{float d=dot((Nearest-Position),Forward);float sh=smoothstep(Width*0.5,Width*0.5+Fuzz*max(d,0.0)+Min_Fuzz,DistToCenter);NotInShadow=1.0-(1.0-sh)*smoothstep(-Fade_Out,0.0,d);}
void Scale_Color_B241(
vec4 Color,
float Scalar,
out vec4 Result)
{Result=Scalar*Color;}
void From_HSV_B223(
float Hue,
float Saturation,
float Value,
float Alpha,
out vec4 Color)
{vec4 K=vec4(1.0,2.0/3.0,1.0/3.0,3.0);vec3 p=abs(fract(vec3(Hue,Hue,Hue)+K.xyz)*6.0-K.www);Color.rgb=Value*mix(K.xxx,clamp(p-K.xxx,0.0,1.0),Saturation);Color.a=Alpha;}
void Fast_Fresnel_B272(
float Front_Reflect,
float Edge_Reflect,
float Power,
vec3 Normal,
vec3 Incident,
out float Transmit,
out float Reflect)
{float d=max(-dot(Incident,Normal),0.0);Reflect=Front_Reflect+(Edge_Reflect-Front_Reflect)*pow(1.0-d,Power);Transmit=1.0-Reflect;}
void Mapped_Environment_B201(
sampler2D Reflected_Environment,
sampler2D Indirect_Environment,
vec3 Dir,
out vec4 Reflected_Color,
out vec4 Indirect_Diffuse)
{Reflected_Color=texture(Reflected_Environment,vec2(atan(Dir.z,Dir.x)/3.14159*0.5,asin(Dir.y)/3.14159+0.5));Indirect_Diffuse=texture(Indirect_Environment,vec2(atan(Dir.z,Dir.x)/3.14159*0.5,asin(Dir.y)/3.14159+0.5));}
vec4 SampleEnv_Bid200(vec3 D,vec4 S,vec4 H,vec4 G,float exponent)
{float k=pow(abs(D.y),exponent);vec4 C;if (D.y>0.0) {C=mix(H,S,k);} else {C=mix(H,G,k); }
return C;}
void Sky_Environment_B200(
vec3 Normal,
vec3 Reflected,
vec4 Sky_Color,
vec4 Horizon_Color,
vec4 Ground_Color,
float Horizon_Power,
out vec4 Reflected_Color,
out vec4 Indirect_Color)
{Reflected_Color=SampleEnv_Bid200(Reflected,Sky_Color,Horizon_Color,Ground_Color,Horizon_Power);Indirect_Color=mix(Ground_Color,Sky_Color,Normal.y*0.5+0.5);}
void Min_Segment_Distance_B215(
vec3 P0,
vec3 P1,
vec3 Q0,
vec3 Q1,
out vec3 NearP,
out vec3 NearQ,
out float Distance)
{vec3 u=P1-P0;vec3 v=Q1-Q0;vec3 w=P0-Q0;float a=dot(u,u);float b=dot(u,v);float c=dot(v,v);float d=dot(u,w);float e=dot(v,w);float D=a*c-b*b;float sD=D;float tD=D;float sc,sN,tc,tN;if (D<0.00001) {sN=0.0;sD=1.0;tN=e;tD=c;} else {sN=(b*e-c*d);tN=(a*e-b*d);if (sN<0.0) {sN=0.0;tN=e;tD=c;} else if (sN>sD) {sN=sD;tN=e+b;tD=c;}}
if (tN<0.0) {tN=0.0;if (-d<0.0) {sN=0.0;} else if (-d>a) {sN=sD;} else {sN=-d;sD=a;}} else if (tN>tD) {tN=tD;if ((-d+b)<0.0) {sN=0.0;} else if ((-d+b)>a) {sN=sD;} else {sN=(-d+b);sD=a;}}
sc=abs(sN)<0.000001 ? 0.0 : sN/sD;tc=abs(tN)<0.000001 ? 0.0 : tN/tD;NearP=P0+sc*u;NearQ=Q0+tc*v;Distance=distance(NearP,NearQ);}
void To_XYZ_B224(
vec3 Vec3,
out float X,
out float Y,
out float Z)
{X=Vec3.x;Y=Vec3.y;Z=Vec3.z;}
void Finger_Positions_B214(
vec3 Left_Index_Pos,
vec3 Right_Index_Pos,
vec3 Left_Index_Middle_Pos,
vec3 Right_Index_Middle_Pos,
out vec3 Left_Index,
out vec3 Right_Index,
out vec3 Left_Index_Middle,
out vec3 Right_Index_Middle)
{Left_Index= (Use_Global_Left_Index ? Global_Left_Index_Tip_Position.xyz : Left_Index_Pos);Right_Index= (Use_Global_Right_Index ? Global_Right_Index_Tip_Position.xyz : Right_Index_Pos);Left_Index_Middle= (Use_Global_Left_Index ? Global_Left_Index_Middle_Position.xyz : Left_Index_Middle_Pos);Right_Index_Middle= (Use_Global_Right_Index ? Global_Right_Index_Middle_Position.xyz : Right_Index_Middle_Pos);}
void VaryHSV_B258(
vec3 HSV_In,
float Hue_Shift,
float Saturation_Shift,
float Value_Shift,
out vec3 HSV_Out)
{HSV_Out=vec3(fract(HSV_In.x+Hue_Shift),clamp(HSV_In.y+Saturation_Shift,0.0,1.0),clamp(HSV_In.z+Value_Shift,0.0,1.0));}
void Remap_Range_B264(
float In_Min,
float In_Max,
float Out_Min,
float Out_Max,
float In,
out float Out)
{Out=mix(Out_Min,Out_Max,clamp((In-In_Min)/(In_Max-In_Min),0.0,1.0));}
void To_HSV_B225(
vec4 Color,
out float Hue,
out float Saturation,
out float Value,
out float Alpha,
out vec3 HSV)
{vec4 K=vec4(0.0,-1.0/3.0,2.0/3.0,-1.0);vec4 p=Color.g<Color.b ? vec4(Color.bg,K.wz) : vec4(Color.gb,K.xy);vec4 q=Color.r<p.x ? vec4(p.xyw,Color.r) : vec4(Color.r,p.yzx);float d=q.x-min(q.w,q.y);float e=1.0e-10;Hue=abs(q.z+(q.w-q.y)/(6.0*d+e));Saturation=d/(q.x+e);Value=q.x;Alpha=Color.a;HSV=vec3(Hue,Saturation,Value);}
void Code_B260(
float X,
out float Result)
{Result=(acos(X)/3.14159-0.5)*2.0;}
void Rim_Light_B282(
vec3 Front,
vec3 Normal,
vec3 Incident,
float Rim_Intensity,
sampler2D Texture,
out vec4 Result)
{vec3 R=reflect(Incident,Normal);float RdotF=dot(R,Front);float RdotL=sqrt(1.0-RdotF*RdotF);vec2 UV=vec2(R.y*0.5+0.5,0.5);vec4 Color=texture(Texture,UV);Result=Color;}
void main()
{vec4 Blob_Color_Q180;
#if BLOB_ENABLE
Blob_Fragment_B180(_Blob_Texture_,vExtra2,vExtra3,Blob_Color_Q180);
#else
Blob_Color_Q180=vec4(0,0,0,0);
#endif
vec3 Incident_Q189=normalize(vPosition-cameraPosition);vec3 Normalized_Q188=normalize(vNormal);vec3 Normalized_Q221=normalize(vTangent);vec4 Color_Q233;
#if DECAL_ENABLE
Color_Q233=texture(_Decal_,vUV);
#else
Color_Q233=vec4(0,0,0,0);
#endif
float X_Q240;float Y_Q240;float Z_Q240;float W_Q240;X_Q240=vExtra1.x;Y_Q240=vExtra1.y;Z_Q240=vExtra1.z;W_Q240=vExtra1.w;vec4 Linear_Q193;Linear_Q193.rgb=clamp(_Sky_Color_.rgb*_Sky_Color_.rgb,0.0,1.0);Linear_Q193.a=_Sky_Color_.a;vec4 Linear_Q194;Linear_Q194.rgb=clamp(_Horizon_Color_.rgb*_Horizon_Color_.rgb,0.0,1.0);Linear_Q194.a=_Horizon_Color_.a;vec4 Linear_Q195;Linear_Q195.rgb=clamp(_Ground_Color_.rgb*_Ground_Color_.rgb,0.0,1.0);Linear_Q195.a=_Ground_Color_.a;vec3 Left_Index_Q214;vec3 Right_Index_Q214;vec3 Left_Index_Middle_Q214;vec3 Right_Index_Middle_Q214;Finger_Positions_B214(_Left_Index_Pos_,_Right_Index_Pos_,_Left_Index_Middle_Pos_,_Right_Index_Middle_Pos_,Left_Index_Q214,Right_Index_Q214,Left_Index_Middle_Q214,Right_Index_Middle_Q214);vec4 Linear_Q196;Linear_Q196.rgb=clamp(_Albedo_.rgb*_Albedo_.rgb,0.0,1.0);Linear_Q196.a=_Albedo_.a;vec3 Normalized_Q257=normalize(vBinormal);vec3 Incident_Q220=normalize(vPosition-cameraPosition);vec3 New_Normal_Q229;Bulge_B229(_Bulge_Enabled_,Normalized_Q188,Normalized_Q221,_Bulge_Height_,vColor,_Bulge_Radius_,vBinormal,New_Normal_Q229);float Result_Q227;SSS_B227(vBinormal,New_Normal_Q229,Incident_Q189,Result_Q227);vec4 Result_Q241;Scale_Color_B241(Color_Q233,X_Q240,Result_Q241);float Transmit_Q272;float Reflect_Q272;Fast_Fresnel_B272(_Front_Reflect_,_Edge_Reflect_,_Power_,New_Normal_Q229,Incident_Q189,Transmit_Q272,Reflect_Q272);float Product_Q275=Y_Q240*Y_Q240;vec3 NearP_Q215;vec3 NearQ_Q215;float Distance_Q215;Min_Segment_Distance_B215(Left_Index_Q214,Left_Index_Middle_Q214,vPosition,cameraPosition,NearP_Q215,NearQ_Q215,Distance_Q215);vec3 NearP_Q213;vec3 NearQ_Q213;float Distance_Q213;Min_Segment_Distance_B215(Right_Index_Q214,Right_Index_Middle_Q214,vPosition,cameraPosition,NearP_Q213,NearQ_Q213,Distance_Q213);vec3 Reflected_Q197=reflect(Incident_Q189,New_Normal_Q229);vec4 Product_Q253=Linear_Q196*vec4(1,1,1,1);vec4 Result_Q282;Rim_Light_B282(Normalized_Q257,Normalized_Q188,Incident_Q220,_Rim_Intensity_,_Rim_Texture_,Result_Q282);float Dot_Q222=dot(Incident_Q220, Normalized_Q221);float MaxAB_Q273=max(Reflect_Q272,Product_Q275);float NotInShadow_Q217;
#if OCCLUSION_ENABLED
FingerOcclusion_B217(_Width_,Distance_Q215,_Fuzz_,_Min_Fuzz_,vPosition,vBinormal,NearP_Q215,_Clip_Fade_,NotInShadow_Q217);
#else
NotInShadow_Q217=1.0;
#endif
float NotInShadow_Q218;
#if OCCLUSION_ENABLED
FingerOcclusion_B218(_Width_,Distance_Q213,_Fuzz_,_Min_Fuzz_,vPosition,vBinormal,NearP_Q213,_Clip_Fade_,NotInShadow_Q218);
#else
NotInShadow_Q218=1.0;
#endif
vec4 Reflected_Color_Q201;vec4 Indirect_Diffuse_Q201;
#if ENV_ENABLE
Mapped_Environment_B201(_Reflection_Map_,_Indirect_Environment_,Reflected_Q197,Reflected_Color_Q201,Indirect_Diffuse_Q201);
#else
Reflected_Color_Q201=vec4(0,0,0,1);Indirect_Diffuse_Q201=vec4(0,0,0,1);
#endif
vec4 Reflected_Color_Q200;vec4 Indirect_Color_Q200;
#if SKY_ENABLED
Sky_Environment_B200(New_Normal_Q229,Reflected_Q197,Linear_Q193,Linear_Q194,Linear_Q195,_Horizon_Power_,Reflected_Color_Q200,Indirect_Color_Q200);
#else
Reflected_Color_Q200=vec4(0,0,0,1);Indirect_Color_Q200=vec4(0,0,0,1);
#endif
float Hue_Q225;float Saturation_Q225;float Value_Q225;float Alpha_Q225;vec3 HSV_Q225;To_HSV_B225(Product_Q253,Hue_Q225,Saturation_Q225,Value_Q225,Alpha_Q225,HSV_Q225);float Hue_Q277;float Saturation_Q277;float Value_Q277;float Alpha_Q277;vec3 HSV_Q277;To_HSV_B225(Result_Q282,Hue_Q277,Saturation_Q277,Value_Q277,Alpha_Q277,HSV_Q277);float Result_Q260;Code_B260(Dot_Q222,Result_Q260);float AbsA_Q226=abs(Result_Q260);float MinAB_Q208=min(NotInShadow_Q217,NotInShadow_Q218);vec4 Sum_Q198=Reflected_Color_Q201+Reflected_Color_Q200;vec4 Sum_Q199=Indirect_Diffuse_Q201+Indirect_Color_Q200;vec3 HSV_Out_Q276;VaryHSV_B258(HSV_Q277,_Rim_Hue_Shift_,_Rim_Saturation_Shift_,_Rim_Value_Shift_,HSV_Out_Q276);float Out_Q264;Remap_Range_B264(-1.0,1.0,0.0,1.0,Result_Q260,Out_Q264);float Product_Q256;Product_Q256=AbsA_Q226*_Hue_Shift_;float X_Q278;float Y_Q278;float Z_Q278;To_XYZ_B224(HSV_Out_Q276,X_Q278,Y_Q278,Z_Q278);vec2 Vec2_Q262=vec2(Out_Q264,0.5);vec3 HSV_Out_Q258;VaryHSV_B258(HSV_Q225,Product_Q256,_Saturation_Shift_,_Value_Shift_,HSV_Out_Q258);vec4 Color_Q279;From_HSV_B223(X_Q278,Y_Q278,Z_Q278,0.0,Color_Q279);vec4 Color_Q261;
#if IRIDESCENCE_ENABLED
Color_Q261=texture(_Iridescence_Texture_,Vec2_Q262);
#else
Color_Q261=vec4(0,0,0,0);
#endif
float X_Q224;float Y_Q224;float Z_Q224;To_XYZ_B224(HSV_Out_Q258,X_Q224,Y_Q224,Z_Q224);vec4 Result_Q281=_Rim_Intensity_*Color_Q279;vec4 Result_Q263=_Iridescence_Intensity_*Color_Q261;vec4 Color_Q223;From_HSV_B223(X_Q224,Y_Q224,Z_Q224,0.0,Color_Q223);vec4 Result_Q234=Result_Q241+(1.0-Result_Q241.a)*Color_Q223;vec4 Result_Q271;Fragment_Main_B271(_Sun_Intensity_,_Sun_Theta_,_Sun_Phi_,New_Normal_Q229,Result_Q234,MaxAB_Q273,_Shininess_,Incident_Q189,_Horizon_Color_,_Sky_Color_,_Ground_Color_,_Indirect_Diffuse_,_Specular_,_Horizon_Power_,_Reflection_,Sum_Q198,Sum_Q199,_Sharpness_,Result_Q227,_Subsurface_,vec4(0,0,0,0),Result_Q281,Result_Q263,Result_Q271);vec4 Result_Q209;Scale_RGB_B209(Result_Q271,MinAB_Q208,Result_Q209);vec4 sRGB_Q192;FastLinearTosRGB_B192(Result_Q209,sRGB_Q192);vec4 Result_Q181=Blob_Color_Q180+(1.0-Blob_Color_Q180.a)*sRGB_Q192;vec4 Result_Q190=Result_Q181; Result_Q190.a=1.0;vec4 Out_Color=Result_Q190;float Clip_Threshold=0.001;bool To_sRGB=false;gl_FragColor=Out_Color;}`;
ShaderStore.ShadersStore[name12] = shader11;

// node_modules/@babylonjs/gui/3D/materials/mrdl/shaders/mrdlSliderThumb.vertex.js
var name13 = "mrdlSliderThumbVertexShader";
var shader12 = `uniform mat4 world;uniform mat4 viewProjection;uniform vec3 cameraPosition;attribute vec3 position;attribute vec3 normal;attribute vec2 uv;
#ifdef TANGENT
attribute vec3 tangent;
#else
const vec3 tangent=vec3(0.);
#endif
uniform float _Radius_;uniform float _Bevel_Front_;uniform float _Bevel_Front_Stretch_;uniform float _Bevel_Back_;uniform float _Bevel_Back_Stretch_;uniform float _Radius_Top_Left_;uniform float _Radius_Top_Right_;uniform float _Radius_Bottom_Left_;uniform float _Radius_Bottom_Right_;uniform bool _Bulge_Enabled_;uniform float _Bulge_Height_;uniform float _Bulge_Radius_;uniform float _Sun_Intensity_;uniform float _Sun_Theta_;uniform float _Sun_Phi_;uniform float _Indirect_Diffuse_;uniform vec4 _Albedo_;uniform float _Specular_;uniform float _Shininess_;uniform float _Sharpness_;uniform float _Subsurface_;uniform vec4 _Left_Color_;uniform vec4 _Right_Color_;uniform float _Reflection_;uniform float _Front_Reflect_;uniform float _Edge_Reflect_;uniform float _Power_;uniform vec4 _Sky_Color_;uniform vec4 _Horizon_Color_;uniform vec4 _Ground_Color_;uniform float _Horizon_Power_;uniform sampler2D _Reflection_Map_;uniform sampler2D _Indirect_Environment_;uniform float _Width_;uniform float _Fuzz_;uniform float _Min_Fuzz_;uniform float _Clip_Fade_;uniform float _Hue_Shift_;uniform float _Saturation_Shift_;uniform float _Value_Shift_;uniform vec3 _Blob_Position_;uniform float _Blob_Intensity_;uniform float _Blob_Near_Size_;uniform float _Blob_Far_Size_;uniform float _Blob_Near_Distance_;uniform float _Blob_Far_Distance_;uniform float _Blob_Fade_Length_;uniform float _Blob_Pulse_;uniform float _Blob_Fade_;uniform sampler2D _Blob_Texture_;uniform vec3 _Blob_Position_2_;uniform float _Blob_Near_Size_2_;uniform float _Blob_Pulse_2_;uniform float _Blob_Fade_2_;uniform vec3 _Left_Index_Pos_;uniform vec3 _Right_Index_Pos_;uniform vec3 _Left_Index_Middle_Pos_;uniform vec3 _Right_Index_Middle_Pos_;uniform sampler2D _Decal_;uniform vec2 _Decal_Scale_XY_;uniform bool _Decal_Front_Only_;uniform float _Rim_Intensity_;uniform sampler2D _Rim_Texture_;uniform float _Rim_Hue_Shift_;uniform float _Rim_Saturation_Shift_;uniform float _Rim_Value_Shift_;uniform float _Iridescence_Intensity_;uniform sampler2D _Iridescence_Texture_;uniform bool Use_Global_Left_Index;uniform bool Use_Global_Right_Index;uniform vec4 Global_Left_Index_Tip_Position;uniform vec4 Global_Right_Index_Tip_Position;uniform vec4 Global_Left_Thumb_Tip_Position;uniform vec4 Global_Right_Thumb_Tip_Position;uniform float Global_Left_Index_Tip_Proximity;uniform float Global_Right_Index_Tip_Proximity;varying vec3 vPosition;varying vec3 vNormal;varying vec2 vUV;varying vec3 vTangent;varying vec3 vBinormal;varying vec4 vColor;varying vec4 vExtra1;varying vec4 vExtra2;varying vec4 vExtra3;void Object_To_World_Pos_B162(
vec3 Pos_Object,
out vec3 Pos_World)
{Pos_World=(world*vec4(Pos_Object,1.0)).xyz;}
void Object_To_World_Normal_B182(
vec3 Nrm_Object,
out vec3 Nrm_World)
{Nrm_World=(vec4(Nrm_Object,0.0)).xyz;}
void Blob_Vertex_B173(
vec3 Position,
vec3 Normal,
vec3 Tangent,
vec3 Bitangent,
vec3 Blob_Position,
float Intensity,
float Blob_Near_Size,
float Blob_Far_Size,
float Blob_Near_Distance,
float Blob_Far_Distance,
float Blob_Fade_Length,
float Blob_Pulse,
float Blob_Fade,
out vec4 Blob_Info)
{vec3 blob= (Use_Global_Left_Index ? Global_Left_Index_Tip_Position.xyz : Blob_Position);vec3 delta=blob-Position;float dist=dot(Normal,delta);float lerpValue=clamp((abs(dist)-Blob_Near_Distance)/(Blob_Far_Distance-Blob_Near_Distance),0.0,1.0);float fadeValue=1.0-clamp((abs(dist)-Blob_Far_Distance)/Blob_Fade_Length,0.0,1.0);float size=Blob_Near_Size+(Blob_Far_Size-Blob_Near_Size)*lerpValue;vec2 blobXY=vec2(dot(delta,Tangent),dot(delta,Bitangent))/(0.0001+size);float Fade=fadeValue*Intensity*Blob_Fade;float Distance=(lerpValue*0.5+0.5)*(1.0-Blob_Pulse);Blob_Info=vec4(blobXY.x,blobXY.y,Distance,Fade);}
void Blob_Vertex_B174(
vec3 Position,
vec3 Normal,
vec3 Tangent,
vec3 Bitangent,
vec3 Blob_Position,
float Intensity,
float Blob_Near_Size,
float Blob_Far_Size,
float Blob_Near_Distance,
float Blob_Far_Distance,
float Blob_Fade_Length,
float Blob_Pulse,
float Blob_Fade,
out vec4 Blob_Info)
{vec3 blob= (Use_Global_Right_Index ? Global_Right_Index_Tip_Position.xyz : Blob_Position);vec3 delta=blob-Position;float dist=dot(Normal,delta);float lerpValue=clamp((abs(dist)-Blob_Near_Distance)/(Blob_Far_Distance-Blob_Near_Distance),0.0,1.0);float fadeValue=1.0-clamp((abs(dist)-Blob_Far_Distance)/Blob_Fade_Length,0.0,1.0);float size=Blob_Near_Size+(Blob_Far_Size-Blob_Near_Size)*lerpValue;vec2 blobXY=vec2(dot(delta,Tangent),dot(delta,Bitangent))/(0.0001+size);float Fade=fadeValue*Intensity*Blob_Fade;float Distance=(lerpValue*0.5+0.5)*(1.0-Blob_Pulse);Blob_Info=vec4(blobXY.x,blobXY.y,Distance,Fade);}
void Move_Verts_B280(
float Anisotropy,
vec3 P,
float Radius,
float Bevel,
vec3 Normal_Object,
float ScaleZ,
float Stretch,
out vec3 New_P,
out vec2 New_UV,
out float Radial_Gradient,
out vec3 Radial_Dir,
out vec3 New_Normal)
{vec2 UV=P.xy*2.0+0.5;vec2 center=clamp(UV,0.0,1.0);vec2 delta=UV-center;float deltad=(length(delta)*2.0);float f=(Bevel+(Radius-Bevel)*Stretch)/Radius;float innerd=clamp(deltad*2.0,0.0,1.0);float outerd=clamp(deltad*2.0-1.0,0.0,1.0);float bevelAngle=outerd*3.14159*0.5;float sinb=sin(bevelAngle);float cosb=cos(bevelAngle);float beveld=(1.0-f)*innerd+f*sinb;float br=outerd;vec2 r2=2.0*vec2(Radius/Anisotropy,Radius);float dir=P.z<0.0001 ? 1.0 : -1.0;New_UV=center+r2*((0.5-center)+normalize(delta+vec2(0.0,0.000001))*beveld*0.5);New_P=vec3(New_UV-0.5,P.z+dir*(1.0-cosb)*Bevel*ScaleZ);Radial_Gradient=clamp((deltad-0.5)*2.0,0.0,1.0);Radial_Dir=vec3(delta*r2,0.0);vec3 beveledNormal=cosb*Normal_Object+sinb*vec3(delta.x,delta.y,0.0);New_Normal=Normal_Object.z==0.0 ? Normal_Object : beveledNormal;}
void Object_To_World_Dir_B210(
vec3 Dir_Object,
out vec3 Normal_World,
out vec3 Normal_World_N,
out float Normal_Length)
{Normal_World=(world*vec4(Dir_Object,0.0)).xyz;Normal_Length=length(Normal_World);Normal_World_N=Normal_World/Normal_Length;}
void To_XYZ_B228(
vec3 Vec3,
out float X,
out float Y,
out float Z)
{X=Vec3.x;Y=Vec3.y;Z=Vec3.z;}
void Conditional_Float_B243(
bool Which,
float If_True,
float If_False,
out float Result)
{Result=Which ? If_True : If_False;}
void Object_To_World_Dir_B178(
vec3 Dir_Object,
out vec3 Binormal_World,
out vec3 Binormal_World_N,
out float Binormal_Length)
{Binormal_World=(world*vec4(Dir_Object,0.0)).xyz;Binormal_Length=length(Binormal_World);Binormal_World_N=Binormal_World/Binormal_Length;}
void Pick_Radius_B219(
float Radius,
float Radius_Top_Left,
float Radius_Top_Right,
float Radius_Bottom_Left,
float Radius_Bottom_Right,
vec3 Position,
out float Result)
{bool whichY=Position.y>0.0;Result=Position.x<0.0 ? (whichY ? Radius_Top_Left : Radius_Bottom_Left) : (whichY ? Radius_Top_Right : Radius_Bottom_Right);Result*=Radius;}
void Conditional_Float_B186(
bool Which,
float If_True,
float If_False,
out float Result)
{Result=Which ? If_True : If_False;}
void Greater_Than_B187(
float Left,
float Right,
out bool Not_Greater_Than,
out bool Greater_Than)
{Greater_Than=Left>Right;Not_Greater_Than=!Greater_Than;}
void Remap_Range_B255(
float In_Min,
float In_Max,
float Out_Min,
float Out_Max,
float In,
out float Out)
{Out=mix(Out_Min,Out_Max,clamp((In-In_Min)/(In_Max-In_Min),0.0,1.0));}
void main()
{vec2 XY_Q235;XY_Q235=(uv-vec2(0.5,0.5))*_Decal_Scale_XY_+vec2(0.5,0.5);vec3 Tangent_World_Q177;vec3 Tangent_World_N_Q177;float Tangent_Length_Q177;Tangent_World_Q177=(world*vec4(vec3(1,0,0),0.0)).xyz;Tangent_Length_Q177=length(Tangent_World_Q177);Tangent_World_N_Q177=Tangent_World_Q177/Tangent_Length_Q177;vec3 Normal_World_Q210;vec3 Normal_World_N_Q210;float Normal_Length_Q210;Object_To_World_Dir_B210(vec3(0,0,1),Normal_World_Q210,Normal_World_N_Q210,Normal_Length_Q210);float X_Q228;float Y_Q228;float Z_Q228;To_XYZ_B228(position,X_Q228,Y_Q228,Z_Q228);vec3 Nrm_World_Q176;Nrm_World_Q176=normalize((world*vec4(normal,0.0)).xyz);vec3 Binormal_World_Q178;vec3 Binormal_World_N_Q178;float Binormal_Length_Q178;Object_To_World_Dir_B178(vec3(0,1,0),Binormal_World_Q178,Binormal_World_N_Q178,Binormal_Length_Q178);float Anisotropy_Q179=Tangent_Length_Q177/Binormal_Length_Q178;float Result_Q219;Pick_Radius_B219(_Radius_,_Radius_Top_Left_,_Radius_Top_Right_,_Radius_Bottom_Left_,_Radius_Bottom_Right_,position,Result_Q219);float Anisotropy_Q203=Binormal_Length_Q178/Normal_Length_Q210;bool Not_Greater_Than_Q187;bool Greater_Than_Q187;Greater_Than_B187(Z_Q228,0.0,Not_Greater_Than_Q187,Greater_Than_Q187);vec4 Linear_Q251;Linear_Q251.rgb=clamp(_Left_Color_.rgb*_Left_Color_.rgb,0.0,1.0);Linear_Q251.a=_Left_Color_.a;vec4 Linear_Q252;Linear_Q252.rgb=clamp(_Right_Color_.rgb*_Right_Color_.rgb,0.0,1.0);Linear_Q252.a=_Right_Color_.a;vec3 Difference_Q211=vec3(0,0,0)-Normal_World_N_Q210;vec4 Out_Color_Q184=vec4(X_Q228,Y_Q228,Z_Q228,1);float Result_Q186;Conditional_Float_B186(Greater_Than_Q187,_Bevel_Back_,_Bevel_Front_,Result_Q186);float Result_Q244;Conditional_Float_B186(Greater_Than_Q187,_Bevel_Back_Stretch_,_Bevel_Front_Stretch_,Result_Q244);vec3 New_P_Q280;vec2 New_UV_Q280;float Radial_Gradient_Q280;vec3 Radial_Dir_Q280;vec3 New_Normal_Q280;Move_Verts_B280(Anisotropy_Q179,position,Result_Q219,Result_Q186,normal,Anisotropy_Q203,Result_Q244,New_P_Q280,New_UV_Q280,Radial_Gradient_Q280,Radial_Dir_Q280,New_Normal_Q280);float X_Q248;float Y_Q248;X_Q248=New_UV_Q280.x;Y_Q248=New_UV_Q280.y;vec3 Pos_World_Q162;Object_To_World_Pos_B162(New_P_Q280,Pos_World_Q162);vec3 Nrm_World_Q182;Object_To_World_Normal_B182(New_Normal_Q280,Nrm_World_Q182);vec4 Blob_Info_Q173;
#if BLOB_ENABLE
Blob_Vertex_B173(Pos_World_Q162,Nrm_World_Q176,Tangent_World_N_Q177,Binormal_World_N_Q178,_Blob_Position_,_Blob_Intensity_,_Blob_Near_Size_,_Blob_Far_Size_,_Blob_Near_Distance_,_Blob_Far_Distance_,_Blob_Fade_Length_,_Blob_Pulse_,_Blob_Fade_,Blob_Info_Q173);
#else
Blob_Info_Q173=vec4(0,0,0,0);
#endif
vec4 Blob_Info_Q174;
#if BLOB_ENABLE_2
Blob_Vertex_B174(Pos_World_Q162,Nrm_World_Q176,Tangent_World_N_Q177,Binormal_World_N_Q178,_Blob_Position_2_,_Blob_Intensity_,_Blob_Near_Size_2_,_Blob_Far_Size_,_Blob_Near_Distance_,_Blob_Far_Distance_,_Blob_Fade_Length_,_Blob_Pulse_2_,_Blob_Fade_2_,Blob_Info_Q174);
#else
Blob_Info_Q174=vec4(0,0,0,0);
#endif
float Out_Q255;Remap_Range_B255(0.0,1.0,0.0,1.0,X_Q248,Out_Q255);float X_Q236;float Y_Q236;float Z_Q236;To_XYZ_B228(Nrm_World_Q182,X_Q236,Y_Q236,Z_Q236);vec4 Color_At_T_Q247=mix(Linear_Q251,Linear_Q252,Out_Q255);float Minus_F_Q237=-Z_Q236;float R_Q249;float G_Q249;float B_Q249;float A_Q249;R_Q249=Color_At_T_Q247.r; G_Q249=Color_At_T_Q247.g; B_Q249=Color_At_T_Q247.b; A_Q249=Color_At_T_Q247.a;float ClampF_Q238=clamp(0.0,Minus_F_Q237,1.0);float Result_Q243;Conditional_Float_B243(_Decal_Front_Only_,ClampF_Q238,1.0,Result_Q243);vec4 Vec4_Q239=vec4(Result_Q243,Radial_Gradient_Q280,G_Q249,B_Q249);vec3 Position=Pos_World_Q162;vec3 Normal=Nrm_World_Q182;vec2 UV=XY_Q235;vec3 Tangent=Tangent_World_N_Q177;vec3 Binormal=Difference_Q211;vec4 Color=Out_Color_Q184;vec4 Extra1=Vec4_Q239;vec4 Extra2=Blob_Info_Q173;vec4 Extra3=Blob_Info_Q174;gl_Position=viewProjection*vec4(Position,1);vPosition=Position;vNormal=Normal;vUV=UV;vTangent=Tangent;vBinormal=Binormal;vColor=Color;vExtra1=Extra1;vExtra2=Extra2;vExtra3=Extra3;}`;
ShaderStore.ShadersStore[name13] = shader12;

// node_modules/@babylonjs/gui/3D/materials/mrdl/mrdlSliderThumbMaterial.js
var MRDLSliderThumbMaterialDefines = class extends MaterialDefines {
  constructor() {
    super();
    this.SKY_ENABLED = true;
    this.BLOB_ENABLE_2 = true;
    this.IRIDESCENCE_ENABLED = true;
    this._needNormals = true;
    this._needUVs = true;
    this.rebuild();
  }
};
var MRDLSliderThumbMaterial = class _MRDLSliderThumbMaterial extends PushMaterial {
  constructor(name22, scene) {
    super(name22, scene);
    this.radius = 0.157;
    this.bevelFront = 0.065;
    this.bevelFrontStretch = 0.077;
    this.bevelBack = 0.031;
    this.bevelBackStretch = 0;
    this.radiusTopLeft = 1;
    this.radiusTopRight = 1;
    this.radiusBottomLeft = 1;
    this.radiusBottomRight = 1;
    this.bulgeEnabled = false;
    this.bulgeHeight = -0.323;
    this.bulgeRadius = 0.73;
    this.sunIntensity = 2;
    this.sunTheta = 0.937;
    this.sunPhi = 0.555;
    this.indirectDiffuse = 1;
    this.albedo = new Color4(0.0117647, 0.505882, 0.996078, 1);
    this.specular = 0;
    this.shininess = 10;
    this.sharpness = 0;
    this.subsurface = 0.31;
    this.leftGradientColor = new Color4(0.0117647, 0.505882, 0.996078, 1);
    this.rightGradientColor = new Color4(0.0117647, 0.505882, 0.996078, 1);
    this.reflection = 0.749;
    this.frontReflect = 0;
    this.edgeReflect = 0.09;
    this.power = 8.1;
    this.skyColor = new Color4(0.0117647, 0.960784, 0.996078, 1);
    this.horizonColor = new Color4(0.0117647, 0.333333, 0.996078, 1);
    this.groundColor = new Color4(0, 0.254902, 0.996078, 1);
    this.horizonPower = 1;
    this.width = 0.02;
    this.fuzz = 0.5;
    this.minFuzz = 1e-3;
    this.clipFade = 0.01;
    this.hueShift = 0;
    this.saturationShift = 0;
    this.valueShift = 0;
    this.blobPosition = new Vector3(0, 0, 0.1);
    this.blobIntensity = 0.5;
    this.blobNearSize = 0.01;
    this.blobFarSize = 0.03;
    this.blobNearDistance = 0;
    this.blobFarDistance = 0.08;
    this.blobFadeLength = 0.576;
    this.blobPulse = 0;
    this.blobFade = 1;
    this.blobPosition2 = new Vector3(0.2, 0, 0.1);
    this.blobNearSize2 = 0.01;
    this.blobPulse2 = 0;
    this.blobFade2 = 1;
    this.blobTexture = new Texture("", this.getScene());
    this.leftIndexPosition = new Vector3(0, 0, 1);
    this.rightIndexPosition = new Vector3(-1, -1, -1);
    this.leftIndexMiddlePosition = new Vector3(0, 0, 0);
    this.rightIndexMiddlePosition = new Vector3(0, 0, 0);
    this.decalScaleXY = new Vector2(1.5, 1.5);
    this.decalFrontOnly = true;
    this.rimIntensity = 0.287;
    this.rimHueShift = 0;
    this.rimSaturationShift = 0;
    this.rimValueShift = -1;
    this.iridescenceIntensity = 0;
    this.useGlobalLeftIndex = 1;
    this.useGlobalRightIndex = 1;
    this.globalLeftIndexTipProximity = 0;
    this.globalRightIndexTipProximity = 0;
    this.globalLeftIndexTipPosition = new Vector4(0.5, 0, -0.55, 1);
    this.globaRightIndexTipPosition = new Vector4(0, 0, 0, 1);
    this.globalLeftThumbTipPosition = new Vector4(0.5, 0, -0.55, 1);
    this.globalRightThumbTipPosition = new Vector4(0, 0, 0, 1);
    this.globalLeftIndexMiddlePosition = new Vector4(0.5, 0, -0.55, 1);
    this.globalRightIndexMiddlePosition = new Vector4(0, 0, 0, 1);
    this.alphaMode = Constants.ALPHA_DISABLE;
    this.backFaceCulling = false;
    this._blueGradientTexture = new Texture(_MRDLSliderThumbMaterial.BLUE_GRADIENT_TEXTURE_URL, scene, true, false, Texture.NEAREST_SAMPLINGMODE);
    this._decalTexture = new Texture("", this.getScene());
    this._reflectionMapTexture = new Texture("", this.getScene());
    this._indirectEnvTexture = new Texture("", this.getScene());
  }
  needAlphaBlending() {
    return false;
  }
  needAlphaTesting() {
    return false;
  }
  getAlphaTestTexture() {
    return null;
  }
  // Methods
  isReadyForSubMesh(mesh, subMesh) {
    const drawWrapper = subMesh._drawWrapper;
    if (this.isFrozen) {
      if (drawWrapper.effect && drawWrapper._wasPreviouslyReady) {
        return true;
      }
    }
    if (!subMesh.materialDefines) {
      subMesh.materialDefines = new MRDLSliderThumbMaterialDefines();
    }
    const defines = subMesh.materialDefines;
    const scene = this.getScene();
    if (this._isReadyForSubMesh(subMesh)) {
      return true;
    }
    const engine = scene.getEngine();
    PrepareDefinesForAttributes(mesh, defines, false, false);
    if (defines.isDirty) {
      defines.markAsProcessed();
      scene.resetCachedMaterial();
      const fallbacks = new EffectFallbacks();
      if (defines.FOG) {
        fallbacks.addFallback(1, "FOG");
      }
      HandleFallbacksForShadows(defines, fallbacks);
      defines.IMAGEPROCESSINGPOSTPROCESS = scene.imageProcessingConfiguration.applyByPostProcess;
      const attribs = [VertexBuffer.PositionKind];
      if (defines.NORMAL) {
        attribs.push(VertexBuffer.NormalKind);
      }
      if (defines.UV1) {
        attribs.push(VertexBuffer.UVKind);
      }
      if (defines.UV2) {
        attribs.push(VertexBuffer.UV2Kind);
      }
      if (defines.VERTEXCOLOR) {
        attribs.push(VertexBuffer.ColorKind);
      }
      if (defines.TANGENT) {
        attribs.push(VertexBuffer.TangentKind);
      }
      PrepareAttributesForInstances(attribs, defines);
      const shaderName = "mrdlSliderThumb";
      const join = defines.toString();
      const uniforms = [
        "world",
        "viewProjection",
        "cameraPosition",
        "_Radius_",
        "_Bevel_Front_",
        "_Bevel_Front_Stretch_",
        "_Bevel_Back_",
        "_Bevel_Back_Stretch_",
        "_Radius_Top_Left_",
        "_Radius_Top_Right_",
        "_Radius_Bottom_Left_",
        "_Radius_Bottom_Right_",
        "_Bulge_Enabled_",
        "_Bulge_Height_",
        "_Bulge_Radius_",
        "_Sun_Intensity_",
        "_Sun_Theta_",
        "_Sun_Phi_",
        "_Indirect_Diffuse_",
        "_Albedo_",
        "_Specular_",
        "_Shininess_",
        "_Sharpness_",
        "_Subsurface_",
        "_Left_Color_",
        "_Right_Color_",
        "_Reflection_",
        "_Front_Reflect_",
        "_Edge_Reflect_",
        "_Power_",
        "_Sky_Color_",
        "_Horizon_Color_",
        "_Ground_Color_",
        "_Horizon_Power_",
        "_Reflection_Map_",
        "_Indirect_Environment_",
        "_Width_",
        "_Fuzz_",
        "_Min_Fuzz_",
        "_Clip_Fade_",
        "_Hue_Shift_",
        "_Saturation_Shift_",
        "_Value_Shift_",
        "_Blob_Position_",
        "_Blob_Intensity_",
        "_Blob_Near_Size_",
        "_Blob_Far_Size_",
        "_Blob_Near_Distance_",
        "_Blob_Far_Distance_",
        "_Blob_Fade_Length_",
        "_Blob_Pulse_",
        "_Blob_Fade_",
        "_Blob_Texture_",
        "_Blob_Position_2_",
        "_Blob_Near_Size_2_",
        "_Blob_Pulse_2_",
        "_Blob_Fade_2_",
        "_Left_Index_Pos_",
        "_Right_Index_Pos_",
        "_Left_Index_Middle_Pos_",
        "_Right_Index_Middle_Pos_",
        "_Decal_",
        "_Decal_Scale_XY_",
        "_Decal_Front_Only_",
        "_Rim_Intensity_",
        "_Rim_Texture_",
        "_Rim_Hue_Shift_",
        "_Rim_Saturation_Shift_",
        "_Rim_Value_Shift_",
        "_Iridescence_Intensity_",
        "_Iridescence_Texture_",
        "Use_Global_Left_Index",
        "Use_Global_Right_Index",
        "Global_Left_Index_Tip_Position",
        "Global_Right_Index_Tip_Position",
        "Global_Left_Thumb_Tip_Position",
        "Global_Right_Thumb_Tip_Position",
        "Global_Left_Index_Middle_Position;",
        "Global_Right_Index_Middle_Position",
        "Global_Left_Index_Tip_Proximity",
        "Global_Right_Index_Tip_Proximity"
      ];
      const samplers = ["_Rim_Texture_", "_Iridescence_Texture_"];
      const uniformBuffers = [];
      PrepareUniformsAndSamplersList({
        uniformsNames: uniforms,
        uniformBuffersNames: uniformBuffers,
        samplers,
        defines,
        maxSimultaneousLights: 4
      });
      subMesh.setEffect(scene.getEngine().createEffect(shaderName, {
        attributes: attribs,
        uniformsNames: uniforms,
        uniformBuffersNames: uniformBuffers,
        samplers,
        defines: join,
        fallbacks,
        onCompiled: this.onCompiled,
        onError: this.onError,
        indexParameters: { maxSimultaneousLights: 4 }
      }, engine), defines);
    }
    if (!subMesh.effect || !subMesh.effect.isReady()) {
      return false;
    }
    defines._renderId = scene.getRenderId();
    drawWrapper._wasPreviouslyReady = true;
    return true;
  }
  bindForSubMesh(world, mesh, subMesh) {
    const defines = subMesh.materialDefines;
    if (!defines) {
      return;
    }
    const effect = subMesh.effect;
    if (!effect) {
      return;
    }
    this._activeEffect = effect;
    this.bindOnlyWorldMatrix(world);
    this._activeEffect.setMatrix("viewProjection", this.getScene().getTransformMatrix());
    this._activeEffect.setVector3("cameraPosition", this.getScene().activeCamera.position);
    this._activeEffect.setFloat("_Radius_", this.radius);
    this._activeEffect.setFloat("_Bevel_Front_", this.bevelFront);
    this._activeEffect.setFloat("_Bevel_Front_Stretch_", this.bevelFrontStretch);
    this._activeEffect.setFloat("_Bevel_Back_", this.bevelBack);
    this._activeEffect.setFloat("_Bevel_Back_Stretch_", this.bevelBackStretch);
    this._activeEffect.setFloat("_Radius_Top_Left_", this.radiusTopLeft);
    this._activeEffect.setFloat("_Radius_Top_Right_", this.radiusTopRight);
    this._activeEffect.setFloat("_Radius_Bottom_Left_", this.radiusBottomLeft);
    this._activeEffect.setFloat("_Radius_Bottom_Right_", this.radiusBottomRight);
    this._activeEffect.setFloat("_Bulge_Enabled_", this.bulgeEnabled ? 1 : 0);
    this._activeEffect.setFloat("_Bulge_Height_", this.bulgeHeight);
    this._activeEffect.setFloat("_Bulge_Radius_", this.bulgeRadius);
    this._activeEffect.setFloat("_Sun_Intensity_", this.sunIntensity);
    this._activeEffect.setFloat("_Sun_Theta_", this.sunTheta);
    this._activeEffect.setFloat("_Sun_Phi_", this.sunPhi);
    this._activeEffect.setFloat("_Indirect_Diffuse_", this.indirectDiffuse);
    this._activeEffect.setDirectColor4("_Albedo_", this.albedo);
    this._activeEffect.setFloat("_Specular_", this.specular);
    this._activeEffect.setFloat("_Shininess_", this.shininess);
    this._activeEffect.setFloat("_Sharpness_", this.sharpness);
    this._activeEffect.setFloat("_Subsurface_", this.subsurface);
    this._activeEffect.setDirectColor4("_Left_Color_", this.leftGradientColor);
    this._activeEffect.setDirectColor4("_Right_Color_", this.rightGradientColor);
    this._activeEffect.setFloat("_Reflection_", this.reflection);
    this._activeEffect.setFloat("_Front_Reflect_", this.frontReflect);
    this._activeEffect.setFloat("_Edge_Reflect_", this.edgeReflect);
    this._activeEffect.setFloat("_Power_", this.power);
    this._activeEffect.setDirectColor4("_Sky_Color_", this.skyColor);
    this._activeEffect.setDirectColor4("_Horizon_Color_", this.horizonColor);
    this._activeEffect.setDirectColor4("_Ground_Color_", this.groundColor);
    this._activeEffect.setFloat("_Horizon_Power_", this.horizonPower);
    this._activeEffect.setTexture("_Reflection_Map_", this._reflectionMapTexture);
    this._activeEffect.setTexture("_Indirect_Environment_", this._indirectEnvTexture);
    this._activeEffect.setFloat("_Width_", this.width);
    this._activeEffect.setFloat("_Fuzz_", this.fuzz);
    this._activeEffect.setFloat("_Min_Fuzz_", this.minFuzz);
    this._activeEffect.setFloat("_Clip_Fade_", this.clipFade);
    this._activeEffect.setFloat("_Hue_Shift_", this.hueShift);
    this._activeEffect.setFloat("_Saturation_Shift_", this.saturationShift);
    this._activeEffect.setFloat("_Value_Shift_", this.valueShift);
    this._activeEffect.setVector3("_Blob_Position_", this.blobPosition);
    this._activeEffect.setFloat("_Blob_Intensity_", this.blobIntensity);
    this._activeEffect.setFloat("_Blob_Near_Size_", this.blobNearSize);
    this._activeEffect.setFloat("_Blob_Far_Size_", this.blobFarSize);
    this._activeEffect.setFloat("_Blob_Near_Distance_", this.blobNearDistance);
    this._activeEffect.setFloat("_Blob_Far_Distance_", this.blobFarDistance);
    this._activeEffect.setFloat("_Blob_Fade_Length_", this.blobFadeLength);
    this._activeEffect.setFloat("_Blob_Pulse_", this.blobPulse);
    this._activeEffect.setFloat("_Blob_Fade_", this.blobFade);
    this._activeEffect.setTexture("_Blob_Texture_", this.blobTexture);
    this._activeEffect.setVector3("_Blob_Position_2_", this.blobPosition2);
    this._activeEffect.setFloat("_Blob_Near_Size_2_", this.blobNearSize2);
    this._activeEffect.setFloat("_Blob_Pulse_2_", this.blobPulse2);
    this._activeEffect.setFloat("_Blob_Fade_2_", this.blobFade2);
    this._activeEffect.setVector3("_Left_Index_Pos_", this.leftIndexPosition);
    this._activeEffect.setVector3("_Right_Index_Pos_", this.rightIndexPosition);
    this._activeEffect.setVector3("_Left_Index_Middle_Pos_", this.leftIndexMiddlePosition);
    this._activeEffect.setVector3("_Right_Index_Middle_Pos_", this.rightIndexMiddlePosition);
    this._activeEffect.setTexture("_Decal_", this._decalTexture);
    this._activeEffect.setVector2("_Decal_Scale_XY_", this.decalScaleXY);
    this._activeEffect.setFloat("_Decal_Front_Only_", this.decalFrontOnly ? 1 : 0);
    this._activeEffect.setFloat("_Rim_Intensity_", this.rimIntensity);
    this._activeEffect.setTexture("_Rim_Texture_", this._blueGradientTexture);
    this._activeEffect.setFloat("_Rim_Hue_Shift_", this.rimHueShift);
    this._activeEffect.setFloat("_Rim_Saturation_Shift_", this.rimSaturationShift);
    this._activeEffect.setFloat("_Rim_Value_Shift_", this.rimValueShift);
    this._activeEffect.setFloat("_Iridescence_Intensity_", this.iridescenceIntensity);
    this._activeEffect.setTexture("_Iridescence_Texture_", this._blueGradientTexture);
    this._activeEffect.setFloat("Use_Global_Left_Index", this.useGlobalLeftIndex);
    this._activeEffect.setFloat("Use_Global_Right_Index", this.useGlobalRightIndex);
    this._activeEffect.setVector4("Global_Left_Index_Tip_Position", this.globalLeftIndexTipPosition);
    this._activeEffect.setVector4("Global_Right_Index_Tip_Position", this.globaRightIndexTipPosition);
    this._activeEffect.setVector4("Global_Left_Thumb_Tip_Position", this.globalLeftThumbTipPosition);
    this._activeEffect.setVector4("Global_Right_Thumb_Tip_Position", this.globalRightThumbTipPosition);
    this._activeEffect.setVector4("Global_Left_Index_Middle_Position", this.globalLeftIndexMiddlePosition);
    this._activeEffect.setVector4("Global_Right_Index_Middle_Position", this.globalRightIndexMiddlePosition);
    this._activeEffect.setFloat("Global_Left_Index_Tip_Proximity", this.globalLeftIndexTipProximity);
    this._activeEffect.setFloat("Global_Right_Index_Tip_Proximity", this.globalRightIndexTipProximity);
    this._afterBind(mesh, this._activeEffect, subMesh);
  }
  /**
   * Get the list of animatables in the material.
   * @returns the list of animatables object used in the material
   */
  getAnimatables() {
    return [];
  }
  dispose(forceDisposeEffect) {
    super.dispose(forceDisposeEffect);
    this._reflectionMapTexture.dispose();
    this._indirectEnvTexture.dispose();
    this._blueGradientTexture.dispose();
    this._decalTexture.dispose();
  }
  clone(name22) {
    return SerializationHelper.Clone(() => new _MRDLSliderThumbMaterial(name22, this.getScene()), this);
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.customType = "BABYLON.MRDLSliderThumbMaterial";
    return serializationObject;
  }
  getClassName() {
    return "MRDLSliderThumbMaterial";
  }
  // Statics
  static Parse(source, scene, rootUrl) {
    return SerializationHelper.Parse(() => new _MRDLSliderThumbMaterial(source.name, scene), source, scene, rootUrl);
  }
};
MRDLSliderThumbMaterial.BLUE_GRADIENT_TEXTURE_URL = "https://assets.babylonjs.com/meshes/MRTK/MRDL/mrtk-mrdl-blue-gradient.png";
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "radius", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "bevelFront", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "bevelFrontStretch", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "bevelBack", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "bevelBackStretch", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "radiusTopLeft", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "radiusTopRight", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "radiusBottomLeft", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "radiusBottomRight", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "bulgeEnabled", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "bulgeHeight", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "bulgeRadius", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "sunIntensity", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "sunTheta", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "sunPhi", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "indirectDiffuse", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "albedo", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "specular", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "shininess", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "sharpness", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "subsurface", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "leftGradientColor", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "rightGradientColor", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "reflection", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "frontReflect", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "edgeReflect", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "power", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "skyColor", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "horizonColor", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "groundColor", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "horizonPower", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "width", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "fuzz", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "minFuzz", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "clipFade", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "hueShift", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "saturationShift", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "valueShift", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "blobPosition", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "blobIntensity", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "blobNearSize", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "blobFarSize", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "blobNearDistance", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "blobFarDistance", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "blobFadeLength", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "blobPulse", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "blobFade", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "blobPosition2", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "blobNearSize2", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "blobPulse2", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "blobFade2", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "blobTexture", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "leftIndexPosition", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "rightIndexPosition", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "leftIndexMiddlePosition", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "rightIndexMiddlePosition", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "decalScaleXY", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "decalFrontOnly", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "rimIntensity", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "rimHueShift", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "rimSaturationShift", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "rimValueShift", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "iridescenceIntensity", void 0);
RegisterClass("BABYLON.GUI.MRDLSliderThumbMaterial", MRDLSliderThumbMaterial);

// node_modules/@babylonjs/gui/3D/materials/mrdl/shaders/mrdlBackplate.fragment.js
var name14 = "mrdlBackplatePixelShader";
var shader13 = `uniform vec3 cameraPosition;varying vec3 vPosition;varying vec3 vNormal;varying vec2 vUV;varying vec3 vTangent;varying vec3 vBinormal;varying vec4 vExtra1;varying vec4 vExtra2;uniform float _Radius_;uniform float _Line_Width_;uniform bool _Absolute_Sizes_;uniform float _Filter_Width_;uniform vec4 _Base_Color_;uniform vec4 _Line_Color_;uniform float _Radius_Top_Left_;uniform float _Radius_Top_Right_;uniform float _Radius_Bottom_Left_;uniform float _Radius_Bottom_Right_;uniform float _Rate_;uniform vec4 _Highlight_Color_;uniform float _Highlight_Width_;uniform vec4 _Highlight_Transform_;uniform float _Highlight_;uniform float _Iridescence_Intensity_;uniform float _Iridescence_Edge_Intensity_;uniform vec4 _Iridescence_Tint_;uniform sampler2D _Iridescent_Map_;uniform float _Angle_;uniform bool _Reflected_;uniform float _Frequency_;uniform float _Vertical_Offset_;uniform vec4 _Gradient_Color_;uniform vec4 _Top_Left_;uniform vec4 _Top_Right_;uniform vec4 _Bottom_Left_;uniform vec4 _Bottom_Right_;uniform float _Edge_Width_;uniform float _Edge_Power_;uniform float _Line_Gradient_Blend_;uniform float _Fade_Out_;void FastLinearTosRGB_B353(
vec4 Linear,
out vec4 sRGB)
{sRGB.rgb=sqrt(clamp(Linear.rgb,0.0,1.0));sRGB.a=Linear.a;}
void Round_Rect_Fragment_B332(
float Radius,
float Line_Width,
vec4 Line_Color,
float Filter_Width,
vec2 UV,
float Line_Visibility,
vec4 Rect_Parms,
vec4 Fill_Color,
out vec4 Color)
{float d=length(max(abs(UV)-Rect_Parms.xy,0.0));float dx=max(fwidth(d)*Filter_Width,0.00001);float g=min(Rect_Parms.z,Rect_Parms.w);float dgrad=max(fwidth(g)*Filter_Width,0.00001);float Inside_Rect=clamp(g/dgrad,0.0,1.0);float inner=clamp((d+dx*0.5-max(Radius-Line_Width,d-dx*0.5))/dx,0.0,1.0);Color=clamp(mix(Fill_Color,Line_Color,inner),0.0,1.0)*Inside_Rect;}
void Iridescence_B343(
vec3 Position,
vec3 Normal,
vec2 UV,
vec3 Axis,
vec3 Eye,
vec4 Tint,
sampler2D Texture,
bool Reflected,
float Frequency,
float Vertical_Offset,
out vec4 Color)
{vec3 i=normalize(Position-Eye);vec3 r=reflect(i,Normal);float idota=dot(i,Axis);float idotr=dot(i,r);float x=Reflected ? idotr : idota;vec2 xy;xy.x=fract((x*Frequency+1.0)*0.5+UV.y*Vertical_Offset);xy.y=0.5;Color=texture(Texture,xy);Color.rgb*=Tint.rgb;}
void Scale_RGB_B346(
vec4 Color,
float Scalar,
out vec4 Result)
{Result=vec4(Scalar,Scalar,Scalar,1)*Color;}
void Scale_RGB_B344(
float Scalar,
vec4 Color,
out vec4 Result)
{Result=vec4(Scalar,Scalar,Scalar,1)*Color;}
void Line_Fragment_B362(
vec4 Base_Color,
vec4 Highlight_Color,
float Highlight_Width,
vec3 Line_Vertex,
float Highlight,
out vec4 Line_Color)
{float k2=1.0-clamp(abs(Line_Vertex.y/Highlight_Width),0.0,1.0);Line_Color=mix(Base_Color,Highlight_Color,Highlight*k2);}
void Edge_B356(
vec4 RectParms,
float Radius,
float Line_Width,
vec2 UV,
float Edge_Width,
float Edge_Power,
out float Result)
{float d=length(max(abs(UV)-RectParms.xy,0.0));float edge=1.0-clamp((1.0-d/(Radius-Line_Width))/Edge_Width,0.0,1.0);Result=pow(edge,Edge_Power);}
void Gradient_B355(
vec4 Gradient_Color,
vec4 Top_Left,
vec4 Top_Right,
vec4 Bottom_Left,
vec4 Bottom_Right,
vec2 UV,
out vec4 Result)
{vec3 top=Top_Left.rgb+(Top_Right.rgb-Top_Left.rgb)*UV.x;vec3 bottom=Bottom_Left.rgb+(Bottom_Right.rgb-Bottom_Left.rgb)*UV.x;Result.rgb=Gradient_Color.rgb*(bottom+(top-bottom)*UV.y);Result.a=1.0;}
void main()
{float X_Q338;float Y_Q338;float Z_Q338;float W_Q338;X_Q338=vExtra2.x;Y_Q338=vExtra2.y;Z_Q338=vExtra2.z;W_Q338=vExtra2.w;vec4 Color_Q343;
#if IRIDESCENCE_ENABLE
Iridescence_B343(vPosition,vNormal,vUV,vBinormal,cameraPosition,_Iridescence_Tint_,_Iridescent_Map_,_Reflected_,_Frequency_,_Vertical_Offset_,Color_Q343);
#else
Color_Q343=vec4(0,0,0,0);
#endif
vec4 Result_Q344;Scale_RGB_B344(_Iridescence_Intensity_,Color_Q343,Result_Q344);vec4 Line_Color_Q362;Line_Fragment_B362(_Line_Color_,_Highlight_Color_,_Highlight_Width_,vTangent,_Highlight_,Line_Color_Q362);float Result_Q356;
#if EDGE_ONLY
Edge_B356(vExtra1,Z_Q338,W_Q338,vUV,_Edge_Width_,_Edge_Power_,Result_Q356);
#else
Result_Q356=1.0;
#endif
vec2 Vec2_Q339=vec2(X_Q338,Y_Q338);vec4 Result_Q355;Gradient_B355(_Gradient_Color_,_Top_Left_,_Top_Right_,_Bottom_Left_,_Bottom_Right_,Vec2_Q339,Result_Q355);vec4 Linear_Q348;Linear_Q348.rgb=clamp(Result_Q355.rgb*Result_Q355.rgb,0.0,1.0);Linear_Q348.a=Result_Q355.a;vec4 Result_Q346;Scale_RGB_B346(Linear_Q348,Result_Q356,Result_Q346);vec4 Sum_Q345=Result_Q346+Result_Q344;vec4 Color_At_T_Q347=mix(Line_Color_Q362,Result_Q346,_Line_Gradient_Blend_);vec4 Base_And_Iridescent_Q350;Base_And_Iridescent_Q350=_Base_Color_+vec4(Sum_Q345.rgb,0.0);vec4 Sum_Q349=Color_At_T_Q347+_Iridescence_Edge_Intensity_*Color_Q343;vec4 Result_Q351=Sum_Q349; Result_Q351.a=1.0;vec4 Color_Q332;Round_Rect_Fragment_B332(Z_Q338,W_Q338,Result_Q351,_Filter_Width_,vUV,1.0,vExtra1,Base_And_Iridescent_Q350,Color_Q332);vec4 Result_Q354=_Fade_Out_*Color_Q332;vec4 sRGB_Q353;FastLinearTosRGB_B353(Result_Q354,sRGB_Q353);vec4 Out_Color=sRGB_Q353;float Clip_Threshold=0.001;bool To_sRGB=false;gl_FragColor=Out_Color;}`;
ShaderStore.ShadersStore[name14] = shader13;

// node_modules/@babylonjs/gui/3D/materials/mrdl/shaders/mrdlBackplate.vertex.js
var name15 = "mrdlBackplateVertexShader";
var shader14 = `uniform mat4 world;uniform mat4 viewProjection;uniform vec3 cameraPosition;attribute vec3 position;attribute vec3 normal;attribute vec3 tangent;uniform float _Radius_;uniform float _Line_Width_;uniform bool _Absolute_Sizes_;uniform float _Filter_Width_;uniform vec4 _Base_Color_;uniform vec4 _Line_Color_;uniform float _Radius_Top_Left_;uniform float _Radius_Top_Right_;uniform float _Radius_Bottom_Left_;uniform float _Radius_Bottom_Right_;uniform float _Rate_;uniform vec4 _Highlight_Color_;uniform float _Highlight_Width_;uniform vec4 _Highlight_Transform_;uniform float _Highlight_;uniform float _Iridescence_Intensity_;uniform float _Iridescence_Edge_Intensity_;uniform vec4 _Iridescence_Tint_;uniform sampler2D _Iridescent_Map_;uniform float _Angle_;uniform bool _Reflected_;uniform float _Frequency_;uniform float _Vertical_Offset_;uniform vec4 _Gradient_Color_;uniform vec4 _Top_Left_;uniform vec4 _Top_Right_;uniform vec4 _Bottom_Left_;uniform vec4 _Bottom_Right_;uniform float _Edge_Width_;uniform float _Edge_Power_;uniform float _Line_Gradient_Blend_;uniform float _Fade_Out_;varying vec3 vPosition;varying vec3 vNormal;varying vec2 vUV;varying vec3 vTangent;varying vec3 vBinormal;varying vec4 vExtra1;varying vec4 vExtra2;void Object_To_World_Pos_B314(
vec3 Pos_Object,
out vec3 Pos_World)
{Pos_World=(world*vec4(Pos_Object,1.0)).xyz;}
void Round_Rect_Vertex_B357(
vec2 UV,
float Radius,
float Margin,
float Anisotropy,
float Gradient1,
float Gradient2,
vec3 Normal,
vec4 Color_Scale_Translate,
out vec2 Rect_UV,
out vec4 Rect_Parms,
out vec2 Scale_XY,
out vec2 Line_UV,
out vec2 Color_UV_Info)
{Scale_XY=vec2(Anisotropy,1.0);Line_UV=(UV-vec2(0.5,0.5));Rect_UV=Line_UV*Scale_XY;Rect_Parms.xy=Scale_XY*0.5-vec2(Radius,Radius)-vec2(Margin,Margin);Rect_Parms.z=Gradient1; 
Rect_Parms.w=Gradient2;Color_UV_Info=(Line_UV+vec2(0.5,0.5))*Color_Scale_Translate.xy+Color_Scale_Translate.zw;}
void Line_Vertex_B333(
vec2 Scale_XY,
vec2 UV,
float Time,
float Rate,
vec4 Highlight_Transform,
out vec3 Line_Vertex)
{float angle2=(Rate*Time)*2.0*3.1416;float sinAngle2=sin(angle2);float cosAngle2=cos(angle2);vec2 xformUV=UV*Highlight_Transform.xy+Highlight_Transform.zw;Line_Vertex.x=0.0;Line_Vertex.y=cosAngle2*xformUV.x-sinAngle2*xformUV.y;Line_Vertex.z=0.0; }
void PickDir_B334(
float Degrees,
vec3 DirX,
vec3 DirY,
out vec3 Dir)
{float a=Degrees*3.14159/180.0;Dir=cos(a)*DirX+sin(a)*DirY;}
void Move_Verts_B327(
float Anisotropy,
vec3 P,
float Radius,
out vec3 New_P,
out vec2 New_UV,
out float Radial_Gradient,
out vec3 Radial_Dir)
{vec2 UV=P.xy*2.0+0.5;vec2 center=clamp(UV,0.0,1.0);vec2 delta=UV-center;vec2 r2=2.0*vec2(Radius/Anisotropy,Radius);New_UV=center+r2*(UV-2.0*center+0.5);New_P=vec3(New_UV-0.5,P.z);Radial_Gradient=1.0-length(delta)*2.0;Radial_Dir=vec3(delta*r2,0.0);}
void Pick_Radius_B336(
float Radius,
float Radius_Top_Left,
float Radius_Top_Right,
float Radius_Bottom_Left,
float Radius_Bottom_Right,
vec3 Position,
out float Result)
{bool whichY=Position.y>0.0;Result=Position.x<0.0 ? (whichY ? Radius_Top_Left : Radius_Bottom_Left) : (whichY ? Radius_Top_Right : Radius_Bottom_Right);Result*=Radius;}
void Edge_AA_Vertex_B328(
vec3 Position_World,
vec3 Position_Object,
vec3 Normal_Object,
vec3 Eye,
float Radial_Gradient,
vec3 Radial_Dir,
vec3 Tangent,
out float Gradient1,
out float Gradient2)
{vec3 I=(Eye-Position_World);vec3 T=(vec4(Tangent,0.0)).xyz;float g=(dot(T,I)<0.0) ? 0.0 : 1.0;if (Normal_Object.z==0.0) { 
Gradient1=Position_Object.z>0.0 ? g : 1.0;Gradient2=Position_Object.z>0.0 ? 1.0 : g;} else {Gradient1=g+(1.0-g)*(Radial_Gradient);Gradient2=1.0;}}
void Object_To_World_Dir_B330(
vec3 Dir_Object,
out vec3 Binormal_World,
out vec3 Binormal_World_N,
out float Binormal_Length)
{Binormal_World=(world*vec4(Dir_Object,0.0)).xyz;Binormal_Length=length(Binormal_World);Binormal_World_N=Binormal_World/Binormal_Length;}
void RelativeOrAbsoluteDetail_B341(
float Nominal_Radius,
float Nominal_LineWidth,
bool Absolute_Measurements,
float Height,
out float Radius,
out float Line_Width)
{float scale=Absolute_Measurements ? 1.0/Height : 1.0;Radius=Nominal_Radius*scale;Line_Width=Nominal_LineWidth*scale;}
void main()
{vec3 Nrm_World_Q326;Nrm_World_Q326=normalize((world*vec4(normal,0.0)).xyz);vec3 Tangent_World_Q329;vec3 Tangent_World_N_Q329;float Tangent_Length_Q329;Tangent_World_Q329=(world*vec4(vec3(1,0,0),0.0)).xyz;Tangent_Length_Q329=length(Tangent_World_Q329);Tangent_World_N_Q329=Tangent_World_Q329/Tangent_Length_Q329;vec3 Binormal_World_Q330;vec3 Binormal_World_N_Q330;float Binormal_Length_Q330;Object_To_World_Dir_B330(vec3(0,1,0),Binormal_World_Q330,Binormal_World_N_Q330,Binormal_Length_Q330);float Radius_Q341;float Line_Width_Q341;RelativeOrAbsoluteDetail_B341(_Radius_,_Line_Width_,_Absolute_Sizes_,Binormal_Length_Q330,Radius_Q341,Line_Width_Q341);vec3 Dir_Q334;PickDir_B334(_Angle_,Tangent_World_N_Q329,Binormal_World_N_Q330,Dir_Q334);float Result_Q336;Pick_Radius_B336(Radius_Q341,_Radius_Top_Left_,_Radius_Top_Right_,_Radius_Bottom_Left_,_Radius_Bottom_Right_,position,Result_Q336);float Anisotropy_Q331=Tangent_Length_Q329/Binormal_Length_Q330;vec4 Out_Color_Q337=vec4(Result_Q336,Line_Width_Q341,0,1);vec3 New_P_Q327;vec2 New_UV_Q327;float Radial_Gradient_Q327;vec3 Radial_Dir_Q327;Move_Verts_B327(Anisotropy_Q331,position,Result_Q336,New_P_Q327,New_UV_Q327,Radial_Gradient_Q327,Radial_Dir_Q327);vec3 Pos_World_Q314;Object_To_World_Pos_B314(New_P_Q327,Pos_World_Q314);float Gradient1_Q328;float Gradient2_Q328;
#if SMOOTH_EDGES
Edge_AA_Vertex_B328(Pos_World_Q314,position,normal,cameraPosition,Radial_Gradient_Q327,Radial_Dir_Q327,tangent,Gradient1_Q328,Gradient2_Q328);
#else
Gradient1_Q328=1.0;Gradient2_Q328=1.0;
#endif
vec2 Rect_UV_Q357;vec4 Rect_Parms_Q357;vec2 Scale_XY_Q357;vec2 Line_UV_Q357;vec2 Color_UV_Info_Q357;Round_Rect_Vertex_B357(New_UV_Q327,Result_Q336,0.0,Anisotropy_Q331,Gradient1_Q328,Gradient2_Q328,normal,vec4(1,1,0,0),Rect_UV_Q357,Rect_Parms_Q357,Scale_XY_Q357,Line_UV_Q357,Color_UV_Info_Q357);vec3 Line_Vertex_Q333;Line_Vertex_B333(Scale_XY_Q357,Line_UV_Q357,(20.0),_Rate_,_Highlight_Transform_,Line_Vertex_Q333);float X_Q359;float Y_Q359;X_Q359=Color_UV_Info_Q357.x;Y_Q359=Color_UV_Info_Q357.y;vec4 Vec4_Q358=vec4(X_Q359,Y_Q359,Result_Q336,Line_Width_Q341);vec3 Position=Pos_World_Q314;vec3 Normal=Nrm_World_Q326;vec2 UV=Rect_UV_Q357;vec3 Tangent=Line_Vertex_Q333;vec3 Binormal=Dir_Q334;vec4 Color=Out_Color_Q337;vec4 Extra1=Rect_Parms_Q357;vec4 Extra2=Vec4_Q358;vec4 Extra3=vec4(0,0,0,0);gl_Position=viewProjection*vec4(Position,1);vPosition=Position;vNormal=Normal;vUV=UV;vTangent=Tangent;vBinormal=Binormal;vExtra1=Extra1;vExtra2=Extra2;}`;
ShaderStore.ShadersStore[name15] = shader14;

// node_modules/@babylonjs/gui/3D/materials/mrdl/mrdlBackplateMaterial.js
var MRDLBackplateMaterialDefines = class extends MaterialDefines {
  constructor() {
    super();
    this.IRIDESCENCE_ENABLE = true;
    this.SMOOTH_EDGES = true;
    this._needNormals = true;
    this.rebuild();
  }
};
var MRDLBackplateMaterial = class _MRDLBackplateMaterial extends PushMaterial {
  constructor(name22, scene) {
    super(name22, scene);
    this.radius = 0.3;
    this.lineWidth = 3e-3;
    this.absoluteSizes = false;
    this._filterWidth = 1;
    this.baseColor = new Color4(0, 0, 0, 1);
    this.lineColor = new Color4(0.2, 0.262745, 0.4, 1);
    this.radiusTopLeft = 1;
    this.radiusTopRight = 1;
    this.radiusBottomLeft = 1;
    this.radiusBottomRight = 1;
    this._rate = 0;
    this.highlightColor = new Color4(0.239216, 0.435294, 0.827451, 1);
    this.highlightWidth = 0;
    this._highlightTransform = new Vector4(1, 1, 0, 0);
    this._highlight = 1;
    this.iridescenceIntensity = 0.45;
    this.iridescenceEdgeIntensity = 1;
    this.iridescenceTint = new Color4(1, 1, 1, 1);
    this._angle = -45;
    this.fadeOut = 1;
    this._reflected = true;
    this._frequency = 1;
    this._verticalOffset = 0;
    this.gradientColor = new Color4(0.74902, 0.74902, 0.74902, 1);
    this.topLeftGradientColor = new Color4(784314e-8, 0.294118, 0.580392, 1);
    this.topRightGradientColor = new Color4(0.305882, 0, 1, 1);
    this.bottomLeftGradientColor = new Color4(0.133333, 0.258824, 0.992157, 1);
    this.bottomRightGradientColor = new Color4(0.176471, 0.176471, 0.619608, 1);
    this.edgeWidth = 0.5;
    this.edgePower = 1;
    this.edgeLineGradientBlend = 0.5;
    this.alphaMode = Constants.ALPHA_DISABLE;
    this.backFaceCulling = false;
    this._iridescentMapTexture = new Texture(_MRDLBackplateMaterial.IRIDESCENT_MAP_TEXTURE_URL, this.getScene(), true, false, Texture.NEAREST_SAMPLINGMODE);
  }
  needAlphaBlending() {
    return false;
  }
  needAlphaTesting() {
    return false;
  }
  getAlphaTestTexture() {
    return null;
  }
  // Methods
  isReadyForSubMesh(mesh, subMesh) {
    const drawWrapper = subMesh._drawWrapper;
    if (this.isFrozen) {
      if (drawWrapper.effect && drawWrapper._wasPreviouslyReady) {
        return true;
      }
    }
    if (!subMesh.materialDefines) {
      subMesh.materialDefines = new MRDLBackplateMaterialDefines();
    }
    const defines = subMesh.materialDefines;
    const scene = this.getScene();
    if (this._isReadyForSubMesh(subMesh)) {
      return true;
    }
    const engine = scene.getEngine();
    PrepareDefinesForAttributes(mesh, defines, false, false);
    if (defines.isDirty) {
      defines.markAsProcessed();
      scene.resetCachedMaterial();
      const fallbacks = new EffectFallbacks();
      if (defines.FOG) {
        fallbacks.addFallback(1, "FOG");
      }
      HandleFallbacksForShadows(defines, fallbacks);
      defines.IMAGEPROCESSINGPOSTPROCESS = scene.imageProcessingConfiguration.applyByPostProcess;
      const attribs = [VertexBuffer.PositionKind];
      if (defines.NORMAL) {
        attribs.push(VertexBuffer.NormalKind);
      }
      if (defines.UV1) {
        attribs.push(VertexBuffer.UVKind);
      }
      if (defines.UV2) {
        attribs.push(VertexBuffer.UV2Kind);
      }
      if (defines.VERTEXCOLOR) {
        attribs.push(VertexBuffer.ColorKind);
      }
      if (defines.TANGENT) {
        attribs.push(VertexBuffer.TangentKind);
      }
      PrepareAttributesForInstances(attribs, defines);
      const shaderName = "mrdlBackplate";
      const join = defines.toString();
      const uniforms = [
        "world",
        "viewProjection",
        "cameraPosition",
        "_Radius_",
        "_Line_Width_",
        "_Absolute_Sizes_",
        "_Filter_Width_",
        "_Base_Color_",
        "_Line_Color_",
        "_Radius_Top_Left_",
        "_Radius_Top_Right_",
        "_Radius_Bottom_Left_",
        "_Radius_Bottom_Right_",
        "_Rate_",
        "_Highlight_Color_",
        "_Highlight_Width_",
        "_Highlight_Transform_",
        "_Highlight_",
        "_Iridescence_Intensity_",
        "_Iridescence_Edge_Intensity_",
        "_Iridescence_Tint_",
        "_Iridescent_Map_",
        "_Angle_",
        "_Reflected_",
        "_Frequency_",
        "_Vertical_Offset_",
        "_Gradient_Color_",
        "_Top_Left_",
        "_Top_Right_",
        "_Bottom_Left_",
        "_Bottom_Right_",
        "_Edge_Width_",
        "_Edge_Power_",
        "_Line_Gradient_Blend_",
        "_Fade_Out_"
      ];
      const samplers = ["_Iridescent_Map_"];
      const uniformBuffers = [];
      PrepareUniformsAndSamplersList({
        uniformsNames: uniforms,
        uniformBuffersNames: uniformBuffers,
        samplers,
        defines,
        maxSimultaneousLights: 4
      });
      subMesh.setEffect(scene.getEngine().createEffect(shaderName, {
        attributes: attribs,
        uniformsNames: uniforms,
        uniformBuffersNames: uniformBuffers,
        samplers,
        defines: join,
        fallbacks,
        onCompiled: this.onCompiled,
        onError: this.onError,
        indexParameters: { maxSimultaneousLights: 4 }
      }, engine), defines);
    }
    if (!subMesh.effect || !subMesh.effect.isReady()) {
      return false;
    }
    defines._renderId = scene.getRenderId();
    drawWrapper._wasPreviouslyReady = true;
    return true;
  }
  bindForSubMesh(world, mesh, subMesh) {
    const defines = subMesh.materialDefines;
    if (!defines) {
      return;
    }
    const effect = subMesh.effect;
    if (!effect) {
      return;
    }
    this._activeEffect = effect;
    this.bindOnlyWorldMatrix(world);
    this._activeEffect.setMatrix("viewProjection", this.getScene().getTransformMatrix());
    this._activeEffect.setVector3("cameraPosition", this.getScene().activeCamera.position);
    this._activeEffect.setFloat("_Radius_", this.radius);
    this._activeEffect.setFloat("_Line_Width_", this.lineWidth);
    this._activeEffect.setFloat("_Absolute_Sizes_", this.absoluteSizes ? 1 : 0);
    this._activeEffect.setFloat("_Filter_Width_", this._filterWidth);
    this._activeEffect.setDirectColor4("_Base_Color_", this.baseColor);
    this._activeEffect.setDirectColor4("_Line_Color_", this.lineColor);
    this._activeEffect.setFloat("_Radius_Top_Left_", this.radiusTopLeft);
    this._activeEffect.setFloat("_Radius_Top_Right_", this.radiusTopRight);
    this._activeEffect.setFloat("_Radius_Bottom_Left_", this.radiusBottomLeft);
    this._activeEffect.setFloat("_Radius_Bottom_Right_", this.radiusBottomRight);
    this._activeEffect.setFloat("_Rate_", this._rate);
    this._activeEffect.setDirectColor4("_Highlight_Color_", this.highlightColor);
    this._activeEffect.setFloat("_Highlight_Width_", this.highlightWidth);
    this._activeEffect.setVector4("_Highlight_Transform_", this._highlightTransform);
    this._activeEffect.setFloat("_Highlight_", this._highlight);
    this._activeEffect.setFloat("_Iridescence_Intensity_", this.iridescenceIntensity);
    this._activeEffect.setFloat("_Iridescence_Edge_Intensity_", this.iridescenceEdgeIntensity);
    this._activeEffect.setDirectColor4("_Iridescence_Tint_", this.iridescenceTint);
    this._activeEffect.setTexture("_Iridescent_Map_", this._iridescentMapTexture);
    this._activeEffect.setFloat("_Angle_", this._angle);
    this._activeEffect.setFloat("_Reflected_", this._reflected ? 1 : 0);
    this._activeEffect.setFloat("_Frequency_", this._frequency);
    this._activeEffect.setFloat("_Vertical_Offset_", this._verticalOffset);
    this._activeEffect.setDirectColor4("_Gradient_Color_", this.gradientColor);
    this._activeEffect.setDirectColor4("_Top_Left_", this.topLeftGradientColor);
    this._activeEffect.setDirectColor4("_Top_Right_", this.topRightGradientColor);
    this._activeEffect.setDirectColor4("_Bottom_Left_", this.bottomLeftGradientColor);
    this._activeEffect.setDirectColor4("_Bottom_Right_", this.bottomRightGradientColor);
    this._activeEffect.setFloat("_Edge_Width_", this.edgeWidth);
    this._activeEffect.setFloat("_Edge_Power_", this.edgePower);
    this._activeEffect.setFloat("_Line_Gradient_Blend_", this.edgeLineGradientBlend);
    this._activeEffect.setFloat("_Fade_Out_", this.fadeOut);
    this._afterBind(mesh, this._activeEffect, subMesh);
  }
  /**
   * Get the list of animatables in the material.
   * @returns the list of animatables object used in the material
   */
  getAnimatables() {
    return [];
  }
  dispose(forceDisposeEffect) {
    super.dispose(forceDisposeEffect);
  }
  clone(name22) {
    return SerializationHelper.Clone(() => new _MRDLBackplateMaterial(name22, this.getScene()), this);
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.customType = "BABYLON.MRDLBackplateMaterial";
    return serializationObject;
  }
  getClassName() {
    return "MRDLBackplateMaterial";
  }
  // Statics
  static Parse(source, scene, rootUrl) {
    return SerializationHelper.Parse(() => new _MRDLBackplateMaterial(source.name, scene), source, scene, rootUrl);
  }
};
MRDLBackplateMaterial.IRIDESCENT_MAP_TEXTURE_URL = "https://assets.babylonjs.com/meshes/MRTK/MRDL/mrtk-mrdl-backplate-iridescence.png";
__decorate([
  serialize()
], MRDLBackplateMaterial.prototype, "radius", void 0);
__decorate([
  serialize()
], MRDLBackplateMaterial.prototype, "lineWidth", void 0);
__decorate([
  serialize()
], MRDLBackplateMaterial.prototype, "absoluteSizes", void 0);
__decorate([
  serialize()
], MRDLBackplateMaterial.prototype, "baseColor", void 0);
__decorate([
  serialize()
], MRDLBackplateMaterial.prototype, "lineColor", void 0);
__decorate([
  serialize()
], MRDLBackplateMaterial.prototype, "radiusTopLeft", void 0);
__decorate([
  serialize()
], MRDLBackplateMaterial.prototype, "radiusTopRight", void 0);
__decorate([
  serialize()
], MRDLBackplateMaterial.prototype, "radiusBottomLeft", void 0);
__decorate([
  serialize()
], MRDLBackplateMaterial.prototype, "radiusBottomRight", void 0);
__decorate([
  serialize()
], MRDLBackplateMaterial.prototype, "highlightColor", void 0);
__decorate([
  serialize()
], MRDLBackplateMaterial.prototype, "highlightWidth", void 0);
__decorate([
  serialize()
], MRDLBackplateMaterial.prototype, "iridescenceIntensity", void 0);
__decorate([
  serialize()
], MRDLBackplateMaterial.prototype, "iridescenceEdgeIntensity", void 0);
__decorate([
  serialize()
], MRDLBackplateMaterial.prototype, "iridescenceTint", void 0);
__decorate([
  serialize()
], MRDLBackplateMaterial.prototype, "fadeOut", void 0);
__decorate([
  serialize()
], MRDLBackplateMaterial.prototype, "gradientColor", void 0);
__decorate([
  serialize()
], MRDLBackplateMaterial.prototype, "topLeftGradientColor", void 0);
__decorate([
  serialize()
], MRDLBackplateMaterial.prototype, "topRightGradientColor", void 0);
__decorate([
  serialize()
], MRDLBackplateMaterial.prototype, "bottomLeftGradientColor", void 0);
__decorate([
  serialize()
], MRDLBackplateMaterial.prototype, "bottomRightGradientColor", void 0);
__decorate([
  serialize()
], MRDLBackplateMaterial.prototype, "edgeWidth", void 0);
__decorate([
  serialize()
], MRDLBackplateMaterial.prototype, "edgePower", void 0);
__decorate([
  serialize()
], MRDLBackplateMaterial.prototype, "edgeLineGradientBlend", void 0);
RegisterClass("BABYLON.GUI.MRDLBackplateMaterial", MRDLBackplateMaterial);

// node_modules/@babylonjs/gui/3D/controls/slider3D.js
var SLIDER_MIN = 0;
var SLIDER_MAX = 100;
var SLIDER_VAL = 50;
var SLIDER_STEP = 0;
var SLIDER_SCALING = 1;
var SLIDER_MARGIN = 0.2;
var Slider3D = class _Slider3D extends Control3D {
  /**
   * Creates a new slider
   * @param name defines the control name
   * @param sliderBackplateVisible defines if the control has a backplate, default is false
   */
  constructor(name22, sliderBackplateVisible) {
    super(name22);
    this.onValueChangedObservable = new Observable();
    this._sliderBackplateVisible = sliderBackplateVisible || false;
    this._minimum = SLIDER_MIN;
    this._maximum = SLIDER_MAX;
    this._step = SLIDER_STEP;
    this._value = SLIDER_VAL;
  }
  /**
   * Gets the mesh used to render this control
   */
  get mesh() {
    if (this.node) {
      return this._sliderThumb;
    }
    return null;
  }
  /** Gets or sets minimum value */
  get minimum() {
    return this._minimum;
  }
  set minimum(value) {
    if (this._minimum === value) {
      return;
    }
    this._minimum = Math.max(value, SLIDER_MIN);
    this._value = Math.max(Math.min(this._value, this._maximum), this._minimum);
  }
  /** Gets or sets maximum value */
  get maximum() {
    return this._maximum;
  }
  set maximum(value) {
    if (this._maximum === value) {
      return;
    }
    this._maximum = Math.max(value, this._minimum);
    this._value = Math.max(Math.min(this._value, this._maximum), this._minimum);
  }
  /** Gets or sets step value */
  get step() {
    return this._step;
  }
  set step(value) {
    if (this._step === value) {
      return;
    }
    this._step = Math.max(Math.min(value, this._maximum - this._minimum), SLIDER_STEP);
  }
  /** Gets or sets current value */
  get value() {
    return this._value;
  }
  set value(value) {
    if (this._value === value) {
      return;
    }
    this._value = Math.max(Math.min(value, this._maximum), this._minimum);
    if (this._sliderThumb) {
      this._sliderThumb.position.x = this._convertToPosition(this.value);
    }
    this.onValueChangedObservable.notifyObservers(this._value);
  }
  get start() {
    if (!this.node) {
      return -SLIDER_SCALING / 2;
    }
    return this._sliderBar.position.x - this._sliderBar.scaling.x / 2;
  }
  get end() {
    if (!this.node) {
      return SLIDER_SCALING / 2;
    }
    return this._sliderBar.position.x + this._sliderBar.scaling.x / 2;
  }
  /**
   * Gets the slider bar material used by this control
   */
  get sliderBarMaterial() {
    return this._sliderBarMaterial;
  }
  /**
   * Gets the slider thumb material used by this control
   */
  get sliderThumbMaterial() {
    return this._sliderThumbMaterial;
  }
  /**
   * Gets the slider backplate material used by this control
   */
  get sliderBackplateMaterial() {
    return this._sliderBackplateMaterial;
  }
  /**
   * Gets the slider bar mesh used by this control
   */
  get sliderBar() {
    return this._sliderBar;
  }
  /**
   * Gets the slider thumb mesh used by this control
   */
  get sliderThumb() {
    return this._sliderThumb;
  }
  /**
   * Gets the slider backplate mesh used by this control
   */
  get sliderBackplate() {
    return this._sliderBackplate;
  }
  /** Sets a boolean indicating if the control is visible */
  set isVisible(value) {
    var _a;
    if (this._isVisible === value) {
      return;
    }
    this._isVisible = value;
    (_a = this.node) == null ? void 0 : _a.setEnabled(value);
  }
  // Mesh association
  _createNode(scene) {
    const sliderBackplate = CreateBox(`${this.name}_sliderbackplate`, {
      width: 1,
      height: 1,
      depth: 1
    }, scene);
    sliderBackplate.isPickable = false;
    sliderBackplate.visibility = 0;
    sliderBackplate.scaling = new Vector3(1, 0.5, 0.8);
    SceneLoader.ImportMeshAsync(void 0, _Slider3D.MODEL_BASE_URL, _Slider3D.MODEL_FILENAME, scene).then((result) => {
      result.meshes.forEach((m) => {
        m.isPickable = false;
      });
      const sliderBackplateModel = result.meshes[1];
      const sliderBarModel = result.meshes[1].clone(`${this.name}_sliderbar`, sliderBackplate);
      const sliderThumbModel = result.meshes[1].clone(`${this.name}_sliderthumb`, sliderBackplate);
      sliderBackplateModel.visibility = 0;
      if (this._sliderBackplateVisible) {
        sliderBackplateModel.visibility = 1;
        sliderBackplateModel.name = `${this.name}_sliderbackplate`;
        sliderBackplateModel.scaling.x = 1;
        sliderBackplateModel.scaling.z = 0.2;
        sliderBackplateModel.parent = sliderBackplate;
        if (this._sliderBackplateMaterial) {
          sliderBackplateModel.material = this._sliderBackplateMaterial;
        }
        this._sliderBackplate = sliderBackplateModel;
      }
      if (sliderBarModel) {
        sliderBarModel.parent = sliderBackplate;
        sliderBarModel.position.z = -0.1;
        sliderBarModel.scaling = new Vector3(SLIDER_SCALING - SLIDER_MARGIN, 0.04, 0.3);
        if (this._sliderBarMaterial) {
          sliderBarModel.material = this._sliderBarMaterial;
        }
        this._sliderBar = sliderBarModel;
      }
      if (sliderThumbModel) {
        sliderThumbModel.parent = sliderBackplate;
        sliderThumbModel.isPickable = true;
        sliderThumbModel.position.z = -0.115;
        sliderThumbModel.scaling = new Vector3(0.025, 0.3, 0.6);
        sliderThumbModel.position.x = this._convertToPosition(this.value);
        sliderThumbModel.addBehavior(this._createBehavior());
        if (this._sliderThumbMaterial) {
          sliderThumbModel.material = this._sliderThumbMaterial;
        }
        this._sliderThumb = sliderThumbModel;
      }
      this._injectGUI3DReservedDataStore(sliderBackplate).control = this;
      sliderBackplate.getChildMeshes().forEach((mesh) => {
        this._injectGUI3DReservedDataStore(mesh).control = this;
      });
    });
    this._affectMaterial(sliderBackplate);
    return sliderBackplate;
  }
  _affectMaterial(mesh) {
    this._sliderBackplateMaterial = this._sliderBackplateMaterial ?? new MRDLBackplateMaterial(`${this.name}_sliderbackplate_material`, mesh.getScene());
    this._sliderBarMaterial = this._sliderBarMaterial ?? new MRDLSliderBarMaterial(`${this.name}_sliderbar_material`, mesh.getScene());
    this._sliderThumbMaterial = this._sliderThumbMaterial ?? new MRDLSliderThumbMaterial(`${this.name}_sliderthumb_material`, mesh.getScene());
  }
  _createBehavior() {
    const pointerDragBehavior = new PointerDragBehavior({ dragAxis: Vector3.Right() });
    pointerDragBehavior.moveAttached = false;
    pointerDragBehavior.onDragStartObservable.add(() => {
      this._draggedPosition = this._sliderThumb.position.x;
    });
    pointerDragBehavior.onDragObservable.add((event) => {
      this._draggedPosition += event.dragDistance / this.scaling.x;
      this.value = this._convertToValue(this._draggedPosition);
    });
    return pointerDragBehavior;
  }
  _convertToPosition(value) {
    const position = (value - this.minimum) / (this.maximum - this.minimum) * (this.end - this.start) + this.start;
    return Math.min(Math.max(position, this.start), this.end);
  }
  _convertToValue(position) {
    let value = (position - this.start) / (this.end - this.start) * (this.maximum - this.minimum);
    value = this.step ? Math.round(value / this.step) * this.step : value;
    return Math.max(Math.min(this.minimum + value, this._maximum), this._minimum);
  }
  /**
   * Releases all associated resources
   */
  dispose() {
    var _a, _b, _c, _d, _e, _f;
    super.dispose();
    (_a = this._sliderBar) == null ? void 0 : _a.dispose();
    (_b = this._sliderThumb) == null ? void 0 : _b.dispose();
    (_c = this._sliderBarMaterial) == null ? void 0 : _c.dispose();
    (_d = this._sliderThumbMaterial) == null ? void 0 : _d.dispose();
    (_e = this._sliderBackplate) == null ? void 0 : _e.dispose();
    (_f = this._sliderBackplateMaterial) == null ? void 0 : _f.dispose();
  }
};
Slider3D.MODEL_BASE_URL = "https://assets.babylonjs.com/meshes/MRTK/";
Slider3D.MODEL_FILENAME = "mrtk-fluent-backplate.glb";

// node_modules/@babylonjs/gui/3D/controls/spherePanel.js
var SpherePanel = class extends VolumeBasedPanel {
  constructor() {
    super(...arguments);
    this._radius = 5;
  }
  /**
   * Gets or sets the radius of the sphere where to project controls (5 by default)
   */
  get radius() {
    return this._radius;
  }
  set radius(value) {
    if (this._radius === value) {
      return;
    }
    this._radius = value;
    Tools.SetImmediate(() => {
      this._arrangeChildren();
    });
  }
  _mapGridNode(control, nodePosition) {
    const mesh = control.mesh;
    if (!mesh) {
      return;
    }
    const newPos = this._sphericalMapping(nodePosition);
    control.position = newPos;
    switch (this.orientation) {
      case Container3D.FACEORIGIN_ORIENTATION:
        mesh.lookAt(new Vector3(2 * newPos.x, 2 * newPos.y, 2 * newPos.z));
        break;
      case Container3D.FACEORIGINREVERSED_ORIENTATION:
        mesh.lookAt(new Vector3(-newPos.x, -newPos.y, -newPos.z));
        break;
      case Container3D.FACEFORWARD_ORIENTATION:
        break;
      case Container3D.FACEFORWARDREVERSED_ORIENTATION:
        mesh.rotate(
          Axis.Y,
          Math.PI,
          0
          /* Space.LOCAL */
        );
        break;
    }
  }
  _sphericalMapping(source) {
    const newPos = new Vector3(0, 0, this._radius);
    const xAngle = source.y / this._radius;
    const yAngle = -(source.x / this._radius);
    Matrix.RotationYawPitchRollToRef(yAngle, xAngle, 0, TmpVectors.Matrix[0]);
    return Vector3.TransformNormal(newPos, TmpVectors.Matrix[0]);
  }
};

// node_modules/@babylonjs/gui/3D/controls/stackPanel3D.js
var StackPanel3D = class extends Container3D {
  /**
   * Gets or sets a boolean indicating if the stack panel is vertical or horizontal (horizontal by default)
   */
  get isVertical() {
    return this._isVertical;
  }
  set isVertical(value) {
    if (this._isVertical === value) {
      return;
    }
    this._isVertical = value;
    Tools.SetImmediate(() => {
      this._arrangeChildren();
    });
  }
  /**
   * Creates new StackPanel
   * @param isVertical
   */
  constructor(isVertical = false) {
    super();
    this._isVertical = false;
    this.margin = 0.1;
    this._isVertical = isVertical;
  }
  _arrangeChildren() {
    let width = 0;
    let height = 0;
    let controlCount = 0;
    const extendSizes = [];
    const currentInverseWorld = Matrix.Invert(this.node.computeWorldMatrix(true));
    for (const child of this._children) {
      if (!child.mesh) {
        continue;
      }
      controlCount++;
      child.mesh.computeWorldMatrix(true);
      child.mesh.getWorldMatrix().multiplyToRef(currentInverseWorld, TmpVectors.Matrix[0]);
      const boundingBox = child.mesh.getBoundingInfo().boundingBox;
      const extendSize = Vector3.TransformNormal(boundingBox.extendSize, TmpVectors.Matrix[0]);
      extendSizes.push(extendSize);
      if (this._isVertical) {
        height += extendSize.y;
      } else {
        width += extendSize.x;
      }
    }
    if (this._isVertical) {
      height += (controlCount - 1) * this.margin / 2;
    } else {
      width += (controlCount - 1) * this.margin / 2;
    }
    let offset;
    if (this._isVertical) {
      offset = -height;
    } else {
      offset = -width;
    }
    let index = 0;
    for (const child of this._children) {
      if (!child.mesh) {
        continue;
      }
      controlCount--;
      const extendSize = extendSizes[index++];
      if (this._isVertical) {
        child.position.y = offset + extendSize.y;
        child.position.x = 0;
        offset += extendSize.y * 2;
      } else {
        child.position.x = offset + extendSize.x;
        child.position.y = 0;
        offset += extendSize.x * 2;
      }
      offset += controlCount > 0 ? this.margin : 0;
    }
  }
};

// node_modules/@babylonjs/gui/3D/controls/touchMeshButton3D.js
var TouchMeshButton3D = class extends TouchButton3D {
  /**
   * Creates a new 3D button based on a mesh
   * @param mesh mesh to become a 3D button. By default this is also the mesh for near interaction collision checking
   * @param name defines the control name
   */
  constructor(mesh, name22) {
    super(name22, mesh);
    this._currentMesh = mesh;
    this.pointerEnterAnimation = () => {
      if (!this.mesh) {
        return;
      }
      this.mesh.scaling.scaleInPlace(1.1);
    };
    this.pointerOutAnimation = () => {
      if (!this.mesh) {
        return;
      }
      this.mesh.scaling.scaleInPlace(1 / 1.1);
    };
    this.pointerDownAnimation = () => {
      if (!this.mesh) {
        return;
      }
      this.mesh.scaling.scaleInPlace(0.95);
    };
    this.pointerUpAnimation = () => {
      if (!this.mesh) {
        return;
      }
      this.mesh.scaling.scaleInPlace(1 / 0.95);
    };
  }
  _getTypeName() {
    return "TouchMeshButton3D";
  }
  // Mesh association
  _createNode() {
    this._currentMesh.getChildMeshes().forEach((mesh) => {
      this._injectGUI3DReservedDataStore(mesh).control = this;
    });
    return this._currentMesh;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _affectMaterial(mesh) {
  }
};

// node_modules/@babylonjs/gui/3D/materials/mrdl/shaders/mrdlBackglow.fragment.js
var name16 = "mrdlBackglowPixelShader";
var shader15 = `uniform vec3 cameraPosition;varying vec3 vNormal;varying vec2 vUV;uniform float _Bevel_Radius_;uniform float _Line_Width_;uniform bool _Absolute_Sizes_;uniform float _Tuning_Motion_;uniform float _Motion_;uniform float _Max_Intensity_;uniform float _Intensity_Fade_In_Exponent_;uniform float _Outer_Fuzz_Start_;uniform float _Outer_Fuzz_End_;uniform vec4 _Color_;uniform vec4 _Inner_Color_;uniform float _Blend_Exponent_;uniform float _Falloff_;uniform float _Bias_;float BiasFunc(float b,float v) {return pow(v,log(clamp(b,0.001,0.999))/log(0.5));}
void Fuzzy_Round_Rect_B33(
float Size_X,
float Size_Y,
float Radius_X,
float Radius_Y,
float Line_Width,
vec2 UV,
float Outer_Fuzz,
float Max_Outer_Fuzz,
out float Rect_Distance,
out float Inner_Distance)
{vec2 halfSize=vec2(Size_X,Size_Y)*0.5;vec2 r=max(min(vec2(Radius_X,Radius_Y),halfSize),vec2(0.001,0.001));float radius=min(r.x,r.y)-Max_Outer_Fuzz;vec2 v=abs(UV);vec2 nearestp=min(v,halfSize-r);float d=distance(nearestp,v);Inner_Distance=clamp(1.0-(radius-d)/Line_Width,0.0,1.0);Rect_Distance=clamp(1.0-(d-radius)/Outer_Fuzz,0.0,1.0)*Inner_Distance;}
void main()
{float X_Q42;float Y_Q42;X_Q42=vNormal.x;Y_Q42=vNormal.y;float MaxAB_Q24=max(_Tuning_Motion_,_Motion_);float Sqrt_F_Q27=sqrt(MaxAB_Q24);float Power_Q43=pow(MaxAB_Q24,_Intensity_Fade_In_Exponent_);float Value_At_T_Q26=mix(_Outer_Fuzz_Start_,_Outer_Fuzz_End_,Sqrt_F_Q27);float Product_Q23=_Max_Intensity_*Power_Q43;float Rect_Distance_Q33;float Inner_Distance_Q33;Fuzzy_Round_Rect_B33(X_Q42,Y_Q42,_Bevel_Radius_,_Bevel_Radius_,_Line_Width_,vUV,Value_At_T_Q26,_Outer_Fuzz_Start_,Rect_Distance_Q33,Inner_Distance_Q33);float Power_Q44=pow(Inner_Distance_Q33,_Blend_Exponent_);float Result_Q45=pow(BiasFunc(_Bias_,Rect_Distance_Q33),_Falloff_);vec4 Color_At_T_Q25=mix(_Inner_Color_,_Color_,Power_Q44);float Product_Q22=Result_Q45*Product_Q23;vec4 Result_Q28=Product_Q22*Color_At_T_Q25;vec4 Out_Color=Result_Q28;float Clip_Threshold=0.0;gl_FragColor=Out_Color;}`;
ShaderStore.ShadersStore[name16] = shader15;

// node_modules/@babylonjs/gui/3D/materials/mrdl/shaders/mrdlBackglow.vertex.js
var name17 = "mrdlBackglowVertexShader";
var shader16 = `uniform mat4 world;uniform mat4 viewProjection;uniform vec3 cameraPosition;attribute vec3 position;attribute vec3 normal;attribute vec2 uv;attribute vec3 tangent;uniform float _Bevel_Radius_;uniform float _Line_Width_;uniform bool _Absolute_Sizes_;uniform float _Tuning_Motion_;uniform float _Motion_;uniform float _Max_Intensity_;uniform float _Intensity_Fade_In_Exponent_;uniform float _Outer_Fuzz_Start_;uniform float _Outer_Fuzz_End_;uniform vec4 _Color_;uniform vec4 _Inner_Color_;uniform float _Blend_Exponent_;uniform float _Falloff_;uniform float _Bias_;varying vec3 vNormal;varying vec2 vUV;void main()
{vec3 Dir_World_Q41=(world*vec4(tangent,0.0)).xyz;vec3 Dir_World_Q40=(world*vec4((cross(normal,tangent)),0.0)).xyz;float MaxAB_Q24=max(_Tuning_Motion_,_Motion_);float Length_Q16=length(Dir_World_Q41);float Length_Q17=length(Dir_World_Q40);bool Greater_Than_Q37=MaxAB_Q24>0.0;vec3 Sizes_Q35;vec2 XY_Q35;Sizes_Q35=(_Absolute_Sizes_ ? vec3(Length_Q16,Length_Q17,0) : vec3(Length_Q16/Length_Q17,1,0));XY_Q35=(uv-vec2(0.5,0.5))*Sizes_Q35.xy;vec3 Result_Q38=Greater_Than_Q37 ? position : vec3(0,0,0);vec3 Pos_World_Q39=(world*vec4(Result_Q38,1.0)).xyz;vec3 Position=Pos_World_Q39;vec3 Normal=Sizes_Q35;vec2 UV=XY_Q35;vec3 Tangent=vec3(0,0,0);vec3 Binormal=vec3(0,0,0);vec4 Color=vec4(1,1,1,1);gl_Position=viewProjection*vec4(Position,1);vNormal=Normal;vUV=UV;}`;
ShaderStore.ShadersStore[name17] = shader16;

// node_modules/@babylonjs/gui/3D/materials/mrdl/mrdlBackglowMaterial.js
var MRDLBackglowMaterialDefines = class extends MaterialDefines {
  constructor() {
    super();
    this._needNormals = true;
    this._needUVs = true;
    this.rebuild();
  }
};
var MRDLBackglowMaterial = class _MRDLBackglowMaterial extends PushMaterial {
  constructor(name22, scene) {
    super(name22, scene);
    this.bevelRadius = 0.16;
    this.lineWidth = 0.16;
    this.absoluteSizes = false;
    this.tuningMotion = 0;
    this.motion = 1;
    this.maxIntensity = 0.7;
    this.intensityFadeInExponent = 2;
    this.outerFuzzStart = 0.04;
    this.outerFuzzEnd = 0.04;
    this.color = new Color4(0.682353, 0.698039, 1, 1);
    this.innerColor = new Color4(0.356863, 0.392157, 0.796078, 1);
    this.blendExponent = 1.5;
    this.falloff = 2;
    this.bias = 0.5;
    this.alphaMode = Constants.ALPHA_ADD;
    this.disableDepthWrite = true;
    this.backFaceCulling = false;
  }
  needAlphaBlending() {
    return true;
  }
  needAlphaTesting() {
    return false;
  }
  getAlphaTestTexture() {
    return null;
  }
  // Methods
  isReadyForSubMesh(mesh, subMesh) {
    const drawWrapper = subMesh._drawWrapper;
    if (this.isFrozen) {
      if (drawWrapper.effect && drawWrapper._wasPreviouslyReady) {
        return true;
      }
    }
    if (!subMesh.materialDefines) {
      subMesh.materialDefines = new MRDLBackglowMaterialDefines();
    }
    const defines = subMesh.materialDefines;
    const scene = this.getScene();
    if (this._isReadyForSubMesh(subMesh)) {
      return true;
    }
    const engine = scene.getEngine();
    PrepareDefinesForAttributes(mesh, defines, false, false);
    if (defines.isDirty) {
      defines.markAsProcessed();
      scene.resetCachedMaterial();
      const fallbacks = new EffectFallbacks();
      if (defines.FOG) {
        fallbacks.addFallback(1, "FOG");
      }
      HandleFallbacksForShadows(defines, fallbacks);
      defines.IMAGEPROCESSINGPOSTPROCESS = scene.imageProcessingConfiguration.applyByPostProcess;
      const attribs = [VertexBuffer.PositionKind];
      if (defines.NORMAL) {
        attribs.push(VertexBuffer.NormalKind);
      }
      if (defines.UV1) {
        attribs.push(VertexBuffer.UVKind);
      }
      if (defines.UV2) {
        attribs.push(VertexBuffer.UV2Kind);
      }
      if (defines.VERTEXCOLOR) {
        attribs.push(VertexBuffer.ColorKind);
      }
      if (defines.TANGENT) {
        attribs.push(VertexBuffer.TangentKind);
      }
      PrepareAttributesForInstances(attribs, defines);
      const shaderName = "mrdlBackglow";
      const join = defines.toString();
      const uniforms = [
        "world",
        "worldView",
        "worldViewProjection",
        "view",
        "projection",
        "viewProjection",
        "cameraPosition",
        "_Bevel_Radius_",
        "_Line_Width_",
        "_Absolute_Sizes_",
        "_Tuning_Motion_",
        "_Motion_",
        "_Max_Intensity_",
        "_Intensity_Fade_In_Exponent_",
        "_Outer_Fuzz_Start_",
        "_Outer_Fuzz_End_",
        "_Color_",
        "_Inner_Color_",
        "_Blend_Exponent_",
        "_Falloff_",
        "_Bias_"
      ];
      const samplers = [];
      const uniformBuffers = [];
      PrepareUniformsAndSamplersList({
        uniformsNames: uniforms,
        uniformBuffersNames: uniformBuffers,
        samplers,
        defines,
        maxSimultaneousLights: 4
      });
      subMesh.setEffect(scene.getEngine().createEffect(shaderName, {
        attributes: attribs,
        uniformsNames: uniforms,
        uniformBuffersNames: uniformBuffers,
        samplers,
        defines: join,
        fallbacks,
        onCompiled: this.onCompiled,
        onError: this.onError,
        indexParameters: { maxSimultaneousLights: 4 }
      }, engine), defines);
    }
    if (!subMesh.effect || !subMesh.effect.isReady()) {
      return false;
    }
    defines._renderId = scene.getRenderId();
    drawWrapper._wasPreviouslyReady = true;
    return true;
  }
  bindForSubMesh(world, mesh, subMesh) {
    const scene = this.getScene();
    const defines = subMesh.materialDefines;
    if (!defines) {
      return;
    }
    const effect = subMesh.effect;
    if (!effect) {
      return;
    }
    this._activeEffect = effect;
    this.bindOnlyWorldMatrix(world);
    this._activeEffect.setMatrix("viewProjection", scene.getTransformMatrix());
    this._activeEffect.setVector3("cameraPosition", scene.activeCamera.position);
    this._activeEffect.setFloat("_Bevel_Radius_", this.bevelRadius);
    this._activeEffect.setFloat("_Line_Width_", this.lineWidth);
    this._activeEffect.setFloat("_Absolute_Sizes_", this.absoluteSizes ? 1 : 0);
    this._activeEffect.setFloat("_Tuning_Motion_", this.tuningMotion);
    this._activeEffect.setFloat("_Motion_", this.motion);
    this._activeEffect.setFloat("_Max_Intensity_", this.maxIntensity);
    this._activeEffect.setFloat("_Intensity_Fade_In_Exponent_", this.intensityFadeInExponent);
    this._activeEffect.setFloat("_Outer_Fuzz_Start_", this.outerFuzzStart);
    this._activeEffect.setFloat("_Outer_Fuzz_End_", this.outerFuzzEnd);
    this._activeEffect.setDirectColor4("_Color_", this.color);
    this._activeEffect.setDirectColor4("_Inner_Color_", this.innerColor);
    this._activeEffect.setFloat("_Blend_Exponent_", this.blendExponent);
    this._activeEffect.setFloat("_Falloff_", this.falloff);
    this._activeEffect.setFloat("_Bias_", this.bias);
    this._afterBind(mesh, this._activeEffect, subMesh);
  }
  /**
   * Get the list of animatables in the material.
   * @returns the list of animatables object used in the material
   */
  getAnimatables() {
    return [];
  }
  dispose(forceDisposeEffect) {
    super.dispose(forceDisposeEffect);
  }
  clone(name22) {
    return SerializationHelper.Clone(() => new _MRDLBackglowMaterial(name22, this.getScene()), this);
  }
  serialize() {
    const serializationObject = SerializationHelper.Serialize(this);
    serializationObject.customType = "BABYLON.MRDLBackglowMaterial";
    return serializationObject;
  }
  getClassName() {
    return "MRDLBackglowMaterial";
  }
  // Statics
  static Parse(source, scene, rootUrl) {
    return SerializationHelper.Parse(() => new _MRDLBackglowMaterial(source.name, scene), source, scene, rootUrl);
  }
};
__decorate([
  serialize()
], MRDLBackglowMaterial.prototype, "bevelRadius", void 0);
__decorate([
  serialize()
], MRDLBackglowMaterial.prototype, "lineWidth", void 0);
__decorate([
  serialize()
], MRDLBackglowMaterial.prototype, "absoluteSizes", void 0);
__decorate([
  serialize()
], MRDLBackglowMaterial.prototype, "tuningMotion", void 0);
__decorate([
  serialize()
], MRDLBackglowMaterial.prototype, "motion", void 0);
__decorate([
  serialize()
], MRDLBackglowMaterial.prototype, "maxIntensity", void 0);
__decorate([
  serialize()
], MRDLBackglowMaterial.prototype, "intensityFadeInExponent", void 0);
__decorate([
  serialize()
], MRDLBackglowMaterial.prototype, "outerFuzzStart", void 0);
__decorate([
  serialize()
], MRDLBackglowMaterial.prototype, "outerFuzzEnd", void 0);
__decorate([
  serialize()
], MRDLBackglowMaterial.prototype, "color", void 0);
__decorate([
  serialize()
], MRDLBackglowMaterial.prototype, "innerColor", void 0);
__decorate([
  serialize()
], MRDLBackglowMaterial.prototype, "blendExponent", void 0);
__decorate([
  serialize()
], MRDLBackglowMaterial.prototype, "falloff", void 0);
__decorate([
  serialize()
], MRDLBackglowMaterial.prototype, "bias", void 0);
RegisterClass("BABYLON.GUI.MRDLBackglowMaterial", MRDLBackglowMaterial);

// node_modules/@babylonjs/gui/3D/materials/mrdl/shaders/mrdlFrontplate.fragment.js
var name18 = "mrdlFrontplatePixelShader";
var shader17 = `uniform vec3 cameraPosition;varying vec3 vNormal;varying vec2 vUV;varying vec3 vTangent;varying vec4 vExtra1;varying vec4 vExtra2;varying vec4 vExtra3;uniform float _Radius_;uniform float _Line_Width_;uniform bool _Relative_To_Height_;uniform float _Filter_Width_;uniform vec4 _Edge_Color_;uniform float _Fade_Out_;uniform bool _Smooth_Edges_;uniform bool _Blob_Enable_;uniform vec3 _Blob_Position_;uniform float _Blob_Intensity_;uniform float _Blob_Near_Size_;uniform float _Blob_Far_Size_;uniform float _Blob_Near_Distance_;uniform float _Blob_Far_Distance_;uniform float _Blob_Fade_Length_;uniform float _Blob_Inner_Fade_;uniform float _Blob_Pulse_;uniform float _Blob_Fade_;uniform float _Blob_Pulse_Max_Size_;uniform bool _Blob_Enable_2_;uniform vec3 _Blob_Position_2_;uniform float _Blob_Near_Size_2_;uniform float _Blob_Inner_Fade_2_;uniform float _Blob_Pulse_2_;uniform float _Blob_Fade_2_;uniform float _Gaze_Intensity_;uniform float _Gaze_Focus_;uniform sampler2D _Blob_Texture_;uniform float _Selection_Fuzz_;uniform float _Selected_;uniform float _Selection_Fade_;uniform float _Selection_Fade_Size_;uniform float _Selected_Distance_;uniform float _Selected_Fade_Length_;uniform float _Proximity_Max_Intensity_;uniform float _Proximity_Far_Distance_;uniform float _Proximity_Near_Radius_;uniform float _Proximity_Anisotropy_;uniform bool _Use_Global_Left_Index_;uniform bool _Use_Global_Right_Index_;uniform vec4 Global_Left_Index_Tip_Position;uniform vec4 Global_Right_Index_Tip_Position;void Scale_Color_B54(
vec4 Color,
float Scalar,
out vec4 Result)
{Result=Scalar*Color;}
void Scale_RGB_B50(
vec4 Color,
float Scalar,
out vec4 Result)
{Result=vec4(Scalar,Scalar,Scalar,1)*Color;}
void Proximity_Fragment_B51(
float Proximity_Max_Intensity,
float Proximity_Near_Radius,
vec4 Deltas,
float Show_Selection,
float Distance_Fade1,
float Distance_Fade2,
float Strength,
out float Proximity)
{float proximity1=(1.0-clamp(length(Deltas.xy)/Proximity_Near_Radius,0.0,1.0))*Distance_Fade1;float proximity2=(1.0-clamp(length(Deltas.zw)/Proximity_Near_Radius,0.0,1.0))*Distance_Fade2;Proximity=Strength*(Proximity_Max_Intensity*max(proximity1,proximity2) *(1.0-Show_Selection)+Show_Selection);}
void Blob_Fragment_B56(
vec2 UV,
vec3 Blob_Info,
sampler2D Blob_Texture,
out vec4 Blob_Color)
{float k=dot(UV,UV);Blob_Color=Blob_Info.y*texture(Blob_Texture,vec2(vec2(sqrt(k),Blob_Info.x).x,1.0-vec2(sqrt(k),Blob_Info.x).y))*(1.0-clamp(k,0.0,1.0));}
void Round_Rect_Fragment_B61(
float Radius,
vec4 Line_Color,
float Filter_Width,
float Line_Visibility,
vec4 Fill_Color,
bool Smooth_Edges,
vec4 Rect_Parms,
out float Inside_Rect)
{float d=length(max(abs(Rect_Parms.zw)-Rect_Parms.xy,0.0));float dx=max(fwidth(d)*Filter_Width,0.00001);Inside_Rect=Smooth_Edges ? clamp((Radius-d)/dx,0.0,1.0) : 1.0-step(Radius,d);}
void main()
{float Is_Quad_Q53;Is_Quad_Q53=vNormal.z;vec4 Blob_Color_Q56;Blob_Fragment_B56(vUV,vTangent,_Blob_Texture_,Blob_Color_Q56);float X_Q52;float Y_Q52;float Z_Q52;float W_Q52;X_Q52=vExtra3.x;Y_Q52=vExtra3.y;Z_Q52=vExtra3.z;W_Q52=vExtra3.w;float Proximity_Q51;Proximity_Fragment_B51(_Proximity_Max_Intensity_,_Proximity_Near_Radius_,vExtra2,X_Q52,Y_Q52,Z_Q52,1.0,Proximity_Q51);float Inside_Rect_Q61;Round_Rect_Fragment_B61(W_Q52,vec4(1,1,1,1),_Filter_Width_,1.0,vec4(0,0,0,0),_Smooth_Edges_,vExtra1,Inside_Rect_Q61);vec4 Result_Q50;Scale_RGB_B50(_Edge_Color_,Proximity_Q51,Result_Q50);vec4 Result_Q47=Inside_Rect_Q61*Blob_Color_Q56;vec4 Color_At_T_Q48=mix(Result_Q50,Result_Q47,Is_Quad_Q53);vec4 Result_Q54;Scale_Color_B54(Color_At_T_Q48,_Fade_Out_,Result_Q54);vec4 Out_Color=Result_Q54;float Clip_Threshold=0.001;bool To_sRGB=false;gl_FragColor=Out_Color;}`;
ShaderStore.ShadersStore[name18] = shader17;

// node_modules/@babylonjs/gui/3D/materials/mrdl/shaders/mrdlFrontplate.vertex.js
var name19 = "mrdlFrontplateVertexShader";
var shader18 = `uniform mat4 world;uniform mat4 viewProjection;uniform vec3 cameraPosition;attribute vec3 position;attribute vec3 normal;attribute vec2 uv;attribute vec3 tangent;attribute vec4 color;uniform float _Radius_;uniform float _Line_Width_;uniform bool _Relative_To_Height_;uniform float _Filter_Width_;uniform vec4 _Edge_Color_;uniform float _Fade_Out_;uniform bool _Smooth_Edges_;uniform bool _Blob_Enable_;uniform vec3 _Blob_Position_;uniform float _Blob_Intensity_;uniform float _Blob_Near_Size_;uniform float _Blob_Far_Size_;uniform float _Blob_Near_Distance_;uniform float _Blob_Far_Distance_;uniform float _Blob_Fade_Length_;uniform float _Blob_Inner_Fade_;uniform float _Blob_Pulse_;uniform float _Blob_Fade_;uniform float _Blob_Pulse_Max_Size_;uniform bool _Blob_Enable_2_;uniform vec3 _Blob_Position_2_;uniform float _Blob_Near_Size_2_;uniform float _Blob_Inner_Fade_2_;uniform float _Blob_Pulse_2_;uniform float _Blob_Fade_2_;uniform float _Gaze_Intensity_;uniform float _Gaze_Focus_;uniform sampler2D _Blob_Texture_;uniform float _Selection_Fuzz_;uniform float _Selected_;uniform float _Selection_Fade_;uniform float _Selection_Fade_Size_;uniform float _Selected_Distance_;uniform float _Selected_Fade_Length_;uniform float _Proximity_Max_Intensity_;uniform float _Proximity_Far_Distance_;uniform float _Proximity_Near_Radius_;uniform float _Proximity_Anisotropy_;uniform bool _Use_Global_Left_Index_;uniform bool _Use_Global_Right_Index_;uniform vec4 Global_Left_Index_Tip_Position;uniform vec4 Global_Right_Index_Tip_Position;varying vec3 vNormal;varying vec2 vUV;varying vec3 vTangent;varying vec4 vExtra1;varying vec4 vExtra2;varying vec4 vExtra3;void Blob_Vertex_B40(
vec3 Position,
vec3 Normal,
vec3 Tangent,
vec3 Bitangent,
vec3 Blob_Position,
float Intensity,
float Blob_Near_Size,
float Blob_Far_Size,
float Blob_Near_Distance,
float Blob_Far_Distance,
vec4 Vx_Color,
vec2 UV,
vec3 Face_Center,
vec2 Face_Size,
vec2 In_UV,
float Blob_Fade_Length,
float Selection_Fade,
float Selection_Fade_Size,
float Inner_Fade,
float Blob_Pulse,
float Blob_Fade,
float Blob_Enabled,
float DistanceOffset,
out vec3 Out_Position,
out vec2 Out_UV,
out vec3 Blob_Info,
out vec2 Blob_Relative_UV)
{float blobSize,fadeIn;vec3 Hit_Position;Blob_Info=vec3(0.0,0.0,0.0);float Hit_Distance=dot(Blob_Position-Face_Center,Normal)+DistanceOffset*Blob_Far_Distance;Hit_Position=Blob_Position-Hit_Distance*Normal;float absD=abs(Hit_Distance);float lerpVal=clamp((absD-Blob_Near_Distance)/(Blob_Far_Distance-Blob_Near_Distance),0.0,1.0);fadeIn=1.0-clamp((absD-Blob_Far_Distance)/Blob_Fade_Length,0.0,1.0);float innerFade=1.0-clamp(-Hit_Distance/Inner_Fade,0.0,1.0);float farClip=clamp(1.0-step(Blob_Far_Distance+Blob_Fade_Length,absD),0.0,1.0);float size=mix(Blob_Near_Size,Blob_Far_Size,lerpVal)*farClip;blobSize=mix(size,Selection_Fade_Size,Selection_Fade)*innerFade*Blob_Enabled;Blob_Info.x=lerpVal*0.5+0.5;Blob_Info.y=fadeIn*Intensity*(1.0-Selection_Fade)*Blob_Fade;Blob_Info.x*=(1.0-Blob_Pulse);vec3 delta=Hit_Position-Face_Center;vec2 blobCenterXY=vec2(dot(delta,Tangent),dot(delta,Bitangent));vec2 quadUVin=2.0*UV-1.0; 
vec2 blobXY=blobCenterXY+quadUVin*blobSize;vec2 blobClipped=clamp(blobXY,-Face_Size*0.5,Face_Size*0.5);vec2 blobUV=(blobClipped-blobCenterXY)/max(blobSize,0.0001)*2.0;vec3 blobCorner=Face_Center+blobClipped.x*Tangent+blobClipped.y*Bitangent;Out_Position=mix(Position,blobCorner,Vx_Color.rrr);Out_UV=mix(In_UV,blobUV,Vx_Color.rr);Blob_Relative_UV=blobClipped/Face_Size.y;}
void Round_Rect_Vertex_B36(
vec2 UV,
vec3 Tangent,
vec3 Binormal,
float Radius,
float Anisotropy,
vec2 Blob_Center_UV,
out vec2 Rect_UV,
out vec2 Scale_XY,
out vec4 Rect_Parms)
{Scale_XY=vec2(Anisotropy,1.0);Rect_UV=(UV-vec2(0.5,0.5))*Scale_XY;Rect_Parms.xy=Scale_XY*0.5-vec2(Radius,Radius);Rect_Parms.zw=Blob_Center_UV;}
vec2 ProjectProximity(
vec3 blobPosition,
vec3 position,
vec3 center,
vec3 dir,
vec3 xdir,
vec3 ydir,
out float vdistance
)
{vec3 delta=blobPosition-position;vec2 xy=vec2(dot(delta,xdir),dot(delta,ydir));vdistance=abs(dot(delta,dir));return xy;}
void Proximity_Vertex_B33(
vec3 Blob_Position,
vec3 Blob_Position_2,
vec3 Face_Center,
vec3 Position,
float Proximity_Far_Distance,
float Relative_Scale,
float Proximity_Anisotropy,
vec3 Normal,
vec3 Tangent,
vec3 Binormal,
out vec4 Extra,
out float Distance_To_Face,
out float Distance_Fade1,
out float Distance_Fade2)
{float distz1,distz2;Extra.xy=ProjectProximity(Blob_Position,Position,Face_Center,Normal,Tangent*Proximity_Anisotropy,Binormal,distz1)/Relative_Scale;Extra.zw=ProjectProximity(Blob_Position_2,Position,Face_Center,Normal,Tangent*Proximity_Anisotropy,Binormal,distz2)/Relative_Scale;Distance_To_Face=dot(Normal,Position-Face_Center);Distance_Fade1=1.0-clamp(distz1/Proximity_Far_Distance,0.0,1.0);Distance_Fade2=1.0-clamp(distz2/Proximity_Far_Distance,0.0,1.0);}
void Object_To_World_Pos_B12(
vec3 Pos_Object,
out vec3 Pos_World)
{Pos_World=(world*vec4(Pos_Object,1.0)).xyz;}
void Choose_Blob_B27(
vec4 Vx_Color,
vec3 Position1,
vec3 Position2,
bool Blob_Enable_1,
bool Blob_Enable_2,
float Near_Size_1,
float Near_Size_2,
float Blob_Inner_Fade_1,
float Blob_Inner_Fade_2,
float Blob_Pulse_1,
float Blob_Pulse_2,
float Blob_Fade_1,
float Blob_Fade_2,
out vec3 Position,
out float Near_Size,
out float Inner_Fade,
out float Blob_Enable,
out float Fade,
out float Pulse)
{Position=Position1*(1.0-Vx_Color.g)+Vx_Color.g*Position2;float b1=Blob_Enable_1 ? 1.0 : 0.0;float b2=Blob_Enable_2 ? 1.0 : 0.0;Blob_Enable=b1+(b2-b1)*Vx_Color.g;Pulse=Blob_Pulse_1*(1.0-Vx_Color.g)+Vx_Color.g*Blob_Pulse_2;Fade=Blob_Fade_1*(1.0-Vx_Color.g)+Vx_Color.g*Blob_Fade_2;Near_Size=Near_Size_1*(1.0-Vx_Color.g)+Vx_Color.g*Near_Size_2;Inner_Fade=Blob_Inner_Fade_1*(1.0-Vx_Color.g)+Vx_Color.g*Blob_Inner_Fade_2;}
void Move_Verts_B32(
vec2 UV,
float Radius,
float Anisotropy,
float Line_Width,
float Visible,
out vec3 New_P,
out vec2 New_UV)
{vec2 xy=2.0*UV-vec2(0.5,0.5);vec2 center=clamp(xy,0.0,1.0);vec2 delta=2.0*(xy-center);float deltaLength=length(delta);vec2 aniso=vec2(1.0/Anisotropy,1.0);center=(center-vec2(0.5,0.5))*(1.0-2.0*Radius*aniso);New_UV=vec2((2.0-2.0*deltaLength)*Visible,0.0);float deltaRadius= (Radius-Line_Width*New_UV.x);New_P.xy=(center+deltaRadius/deltaLength *aniso*delta);New_P.z=0.0;}
void Object_To_World_Dir_B14(
vec3 Dir_Object,
out vec3 Binormal_World)
{Binormal_World=(world*vec4(Dir_Object,0.0)).xyz;}
void Proximity_Visibility_B55(
float Selection,
vec3 Proximity_Center,
vec3 Proximity_Center_2,
float Proximity_Far_Distance,
float Proximity_Radius,
vec3 Face_Center,
vec3 Normal,
vec2 Face_Size,
float Gaze,
out float Width)
{float boxMaxSize=length(Face_Size)*0.5;float d1=dot(Proximity_Center-Face_Center,Normal);vec3 blob1=Proximity_Center-d1*Normal;float d2=dot(Proximity_Center_2-Face_Center,Normal);vec3 blob2=Proximity_Center_2-d2*Normal;vec3 delta1=blob1-Face_Center;vec3 delta2=blob2-Face_Center;float dist1=dot(delta1,delta1);float dist2=dot(delta2,delta2);float nearestProxDist=sqrt(min(dist1,dist2));Width=(1.0-step(boxMaxSize+Proximity_Radius,nearestProxDist))*(1.0-step(Proximity_Far_Distance,min(d1,d2))*(1.0-step(0.0001,Selection)));Width=max(Gaze,Width);}
vec2 ramp2(vec2 start,vec2 end,vec2 x)
{return clamp((x-start)/(end-start),vec2(0.0,0.0),vec2(1.0,1.0));}
float computeSelection(
vec3 blobPosition,
vec3 normal,
vec3 tangent,
vec3 bitangent,
vec3 faceCenter,
vec2 faceSize,
float selectionFuzz,
float farDistance,
float fadeLength
)
{vec3 delta=blobPosition-faceCenter;float absD=abs(dot(delta,normal));float fadeIn=1.0-clamp((absD-farDistance)/fadeLength,0.0,1.0);vec2 blobCenterXY=vec2(dot(delta,tangent),dot(delta,bitangent));vec2 innerFace=faceSize*(1.0-selectionFuzz)*0.5;vec2 selectPulse=ramp2(-faceSize*0.5,-innerFace,blobCenterXY)-ramp2(innerFace,faceSize*0.5,blobCenterXY);return selectPulse.x*selectPulse.y*fadeIn;}
void Selection_Vertex_B31(
vec3 Blob_Position,
vec3 Blob_Position_2,
vec3 Face_Center,
vec2 Face_Size,
vec3 Normal,
vec3 Tangent,
vec3 Bitangent,
float Selection_Fuzz,
float Selected,
float Far_Distance,
float Fade_Length,
vec3 Active_Face_Dir,
out float Show_Selection)
{float select1=computeSelection(Blob_Position,Normal,Tangent,Bitangent,Face_Center,Face_Size,Selection_Fuzz,Far_Distance,Fade_Length);float select2=computeSelection(Blob_Position_2,Normal,Tangent,Bitangent,Face_Center,Face_Size,Selection_Fuzz,Far_Distance,Fade_Length);Show_Selection=mix(max(select1,select2),1.0,Selected);}
void main()
{vec3 Vec3_Q29=vec3(vec2(0,0).x,vec2(0,0).y,color.r);vec3 Nrm_World_Q24;Nrm_World_Q24=normalize((world*vec4(normal,0.0)).xyz);vec3 Face_Center_Q30;Face_Center_Q30=(world*vec4(vec3(0,0,0),1.0)).xyz;vec3 Tangent_World_Q13;Tangent_World_Q13=(world*vec4(tangent,0.0)).xyz;vec3 Result_Q42;Result_Q42=_Use_Global_Left_Index_ ? Global_Left_Index_Tip_Position.xyz : _Blob_Position_;vec3 Result_Q43;Result_Q43=_Use_Global_Right_Index_ ? Global_Right_Index_Tip_Position.xyz : _Blob_Position_2_;float Value_At_T_Q58=mix(_Blob_Near_Size_,_Blob_Pulse_Max_Size_,_Blob_Pulse_);float Value_At_T_Q59=mix(_Blob_Near_Size_2_,_Blob_Pulse_Max_Size_,_Blob_Pulse_2_);vec3 Cross_Q70=cross(normal,tangent);float Product_Q45=_Gaze_Intensity_*_Gaze_Focus_;float Step_Q46=step(0.0001,Product_Q45);vec3 Tangent_World_N_Q15=normalize(Tangent_World_Q13);vec3 Position_Q27;float Near_Size_Q27;float Inner_Fade_Q27;float Blob_Enable_Q27;float Fade_Q27;float Pulse_Q27;Choose_Blob_B27(color,Result_Q42,Result_Q43,_Blob_Enable_,_Blob_Enable_2_,Value_At_T_Q58,Value_At_T_Q59,_Blob_Inner_Fade_,_Blob_Inner_Fade_2_,_Blob_Pulse_,_Blob_Pulse_2_,_Blob_Fade_,_Blob_Fade_2_,Position_Q27,Near_Size_Q27,Inner_Fade_Q27,Blob_Enable_Q27,Fade_Q27,Pulse_Q27);vec3 Binormal_World_Q14;Object_To_World_Dir_B14(Cross_Q70,Binormal_World_Q14);float Anisotropy_Q21=length(Tangent_World_Q13)/length(Binormal_World_Q14);vec3 Binormal_World_N_Q16=normalize(Binormal_World_Q14);vec2 Face_Size_Q35;float ScaleY_Q35;Face_Size_Q35=vec2(length(Tangent_World_Q13),length(Binormal_World_Q14));ScaleY_Q35=Face_Size_Q35.y;float Out_Radius_Q38;float Out_Line_Width_Q38;Out_Radius_Q38=_Relative_To_Height_ ? _Radius_ : _Radius_/ScaleY_Q35;Out_Line_Width_Q38=_Relative_To_Height_ ? _Line_Width_ : _Line_Width_/ScaleY_Q35;float Show_Selection_Q31;Selection_Vertex_B31(Result_Q42,Result_Q43,Face_Center_Q30,Face_Size_Q35,Nrm_World_Q24,Tangent_World_N_Q15,Binormal_World_N_Q16,_Selection_Fuzz_,_Selected_,_Selected_Distance_,_Selected_Fade_Length_,vec3(0,0,-1),Show_Selection_Q31);float MaxAB_Q41=max(Show_Selection_Q31,Product_Q45);float Width_Q55;Proximity_Visibility_B55(Show_Selection_Q31,Result_Q42,Result_Q43,_Proximity_Far_Distance_,_Proximity_Near_Radius_,Face_Center_Q30,Nrm_World_Q24,Face_Size_Q35,Step_Q46,Width_Q55);vec3 New_P_Q32;vec2 New_UV_Q32;Move_Verts_B32(uv,Out_Radius_Q38,Anisotropy_Q21,Out_Line_Width_Q38,Width_Q55,New_P_Q32,New_UV_Q32);vec3 Pos_World_Q12;Object_To_World_Pos_B12(New_P_Q32,Pos_World_Q12);vec3 Out_Position_Q40;vec2 Out_UV_Q40;vec3 Blob_Info_Q40;vec2 Blob_Relative_UV_Q40;Blob_Vertex_B40(Pos_World_Q12,Nrm_World_Q24,Tangent_World_N_Q15,Binormal_World_N_Q16,Position_Q27,_Blob_Intensity_,Near_Size_Q27,_Blob_Far_Size_,_Blob_Near_Distance_,_Blob_Far_Distance_,color,uv,Face_Center_Q30,Face_Size_Q35,New_UV_Q32,_Blob_Fade_Length_,_Selection_Fade_,_Selection_Fade_Size_,Inner_Fade_Q27,Pulse_Q27,Fade_Q27,Blob_Enable_Q27,0.0,Out_Position_Q40,Out_UV_Q40,Blob_Info_Q40,Blob_Relative_UV_Q40);vec2 Rect_UV_Q36;vec2 Scale_XY_Q36;vec4 Rect_Parms_Q36;Round_Rect_Vertex_B36(New_UV_Q32,Tangent_World_Q13,Binormal_World_Q14,Out_Radius_Q38,Anisotropy_Q21,Blob_Relative_UV_Q40,Rect_UV_Q36,Scale_XY_Q36,Rect_Parms_Q36);vec4 Extra_Q33;float Distance_To_Face_Q33;float Distance_Fade1_Q33;float Distance_Fade2_Q33;Proximity_Vertex_B33(Result_Q42,Result_Q43,Face_Center_Q30,Pos_World_Q12,_Proximity_Far_Distance_,1.0,_Proximity_Anisotropy_,Nrm_World_Q24,Tangent_World_N_Q15,Binormal_World_N_Q16,Extra_Q33,Distance_To_Face_Q33,Distance_Fade1_Q33,Distance_Fade2_Q33);vec4 Vec4_Q37=vec4(MaxAB_Q41,Distance_Fade1_Q33,Distance_Fade2_Q33,Out_Radius_Q38);vec3 Position=Out_Position_Q40;vec3 Normal=Vec3_Q29;vec2 UV=Out_UV_Q40;vec3 Tangent=Blob_Info_Q40;vec3 Binormal=vec3(0,0,0);vec4 Color=vec4(1,1,1,1);vec4 Extra1=Rect_Parms_Q36;vec4 Extra2=Extra_Q33;vec4 Extra3=Vec4_Q37;gl_Position=viewProjection*vec4(Position,1);vNormal=Normal;vUV=UV;vTangent=Tangent;vExtra1=Extra1;vExtra2=Extra2;vExtra3=Extra3;}`;
ShaderStore.ShadersStore[name19] = shader18;

// node_modules/@babylonjs/gui/3D/materials/mrdl/mrdlFrontplateMaterial.js
var MRDLFrontplateMaterialDefines = class extends MaterialDefines {
  constructor() {
    super();
    this.SMOOTH_EDGES = true;
    this._needNormals = true;
    this._needUVs = true;
    this.rebuild();
  }
};
var MRDLFrontplateMaterial = class _MRDLFrontplateMaterial extends PushMaterial {
  constructor(name22, scene) {
    super(name22, scene);
    this.radius = 0.12;
    this.lineWidth = 0.01;
    this.relativeToHeight = false;
    this._filterWidth = 1;
    this.edgeColor = new Color4(0.53, 0.53, 0.53, 1);
    this.blobEnable = true;
    this.blobPosition = new Vector3(100, 100, 100);
    this.blobIntensity = 0.5;
    this.blobNearSize = 0.032;
    this.blobFarSize = 0.048;
    this.blobNearDistance = 8e-3;
    this.blobFarDistance = 0.064;
    this.blobFadeLength = 0.04;
    this.blobInnerFade = 0.01;
    this.blobPulse = 0;
    this.blobFade = 1;
    this.blobPulseMaxSize = 0.05;
    this.blobEnable2 = true;
    this.blobPosition2 = new Vector3(10, 10.1, -0.6);
    this.blobNearSize2 = 8e-3;
    this.blobInnerFade2 = 0.1;
    this.blobPulse2 = 0;
    this.blobFade2 = 1;
    this.gazeIntensity = 0.8;
    this.gazeFocus = 0;
    this.selectionFuzz = 0.5;
    this.selected = 1;
    this.selectionFade = 0.2;
    this.selectionFadeSize = 0;
    this.selectedDistance = 0.08;
    this.selectedFadeLength = 0.08;
    this.proximityMaxIntensity = 0.45;
    this.proximityFarDistance = 0.16;
    this.proximityNearRadius = 0.016;
    this.proximityAnisotropy = 1;
    this.useGlobalLeftIndex = true;
    this.useGlobalRightIndex = true;
    this.fadeOut = 1;
    this.alphaMode = Constants.ALPHA_ADD;
    this.disableDepthWrite = true;
    this.backFaceCulling = false;
    this._blobTexture = new Texture(_MRDLFrontplateMaterial.BLOB_TEXTURE_URL, scene, true, false, Texture.NEAREST_SAMPLINGMODE);
  }
  needAlphaBlending() {
    return true;
  }
  needAlphaTesting() {
    return false;
  }
  getAlphaTestTexture() {
    return null;
  }
  // Methods
  isReadyForSubMesh(mesh, subMesh) {
    const drawWrapper = subMesh._drawWrapper;
    if (this.isFrozen) {
      if (drawWrapper.effect && drawWrapper._wasPreviouslyReady) {
        return true;
      }
    }
    if (!subMesh.materialDefines) {
      subMesh.materialDefines = new MRDLFrontplateMaterialDefines();
    }
    const defines = subMesh.materialDefines;
    const scene = this.getScene();
    if (this._isReadyForSubMesh(subMesh)) {
      return true;
    }
    const engine = scene.getEngine();
    PrepareDefinesForAttributes(mesh, defines, false, false);
    if (defines.isDirty) {
      defines.markAsProcessed();
      scene.resetCachedMaterial();
      const fallbacks = new EffectFallbacks();
      if (defines.FOG) {
        fallbacks.addFallback(1, "FOG");
      }
      HandleFallbacksForShadows(defines, fallbacks);
      defines.IMAGEPROCESSINGPOSTPROCESS = scene.imageProcessingConfiguration.applyByPostProcess;
      const attribs = [VertexBuffer.PositionKind];
      if (defines.NORMAL) {
        attribs.push(VertexBuffer.NormalKind);
      }
      if (defines.UV1) {
        attribs.push(VertexBuffer.UVKind);
      }
      if (defines.UV2) {
        attribs.push(VertexBuffer.UV2Kind);
      }
      if (defines.VERTEXCOLOR) {
        attribs.push(VertexBuffer.ColorKind);
      }
      if (defines.TANGENT) {
        attribs.push(VertexBuffer.TangentKind);
      }
      PrepareAttributesForInstances(attribs, defines);
      const shaderName = "mrdlFrontplate";
      const join = defines.toString();
      const uniforms = [
        "world",
        "worldView",
        "worldViewProjection",
        "view",
        "projection",
        "viewProjection",
        "cameraPosition",
        "_Radius_",
        "_Line_Width_",
        "_Relative_To_Height_",
        "_Filter_Width_",
        "_Edge_Color_",
        "_Fade_Out_",
        "_Smooth_Edges_",
        "_Blob_Enable_",
        "_Blob_Position_",
        "_Blob_Intensity_",
        "_Blob_Near_Size_",
        "_Blob_Far_Size_",
        "_Blob_Near_Distance_",
        "_Blob_Far_Distance_",
        "_Blob_Fade_Length_",
        "_Blob_Inner_Fade_",
        "_Blob_Pulse_",
        "_Blob_Fade_",
        "_Blob_Pulse_Max_Size_",
        "_Blob_Enable_2_",
        "_Blob_Position_2_",
        "_Blob_Near_Size_2_",
        "_Blob_Inner_Fade_2_",
        "_Blob_Pulse_2_",
        "_Blob_Fade_2_",
        "_Gaze_Intensity_",
        "_Gaze_Focus_",
        "_Blob_Texture_",
        "_Selection_Fuzz_",
        "_Selected_",
        "_Selection_Fade_",
        "_Selection_Fade_Size_",
        "_Selected_Distance_",
        "_Selected_Fade_Length_",
        "_Proximity_Max_Intensity_",
        "_Proximity_Far_Distance_",
        "_Proximity_Near_Radius_",
        "_Proximity_Anisotropy_",
        "Global_Left_Index_Tip_Position",
        "Global_Right_Index_Tip_Position",
        "_Use_Global_Left_Index_",
        "_Use_Global_Right_Index_"
      ];
      const samplers = [];
      const uniformBuffers = [];
      PrepareUniformsAndSamplersList({
        uniformsNames: uniforms,
        uniformBuffersNames: uniformBuffers,
        samplers,
        defines,
        maxSimultaneousLights: 4
      });
      subMesh.setEffect(scene.getEngine().createEffect(shaderName, {
        attributes: attribs,
        uniformsNames: uniforms,
        uniformBuffersNames: uniformBuffers,
        samplers,
        defines: join,
        fallbacks,
        onCompiled: this.onCompiled,
        onError: this.onError,
        indexParameters: { maxSimultaneousLights: 4 }
      }, engine), defines);
    }
    if (!subMesh.effect || !subMesh.effect.isReady()) {
      return false;
    }
    defines._renderId = scene.getRenderId();
    drawWrapper._wasPreviouslyReady = true;
    return true;
  }
  bindForSubMesh(world, mesh, subMesh) {
    const scene = this.getScene();
    const defines = subMesh.materialDefines;
    if (!defines) {
      return;
    }
    const effect = subMesh.effect;
    if (!effect) {
      return;
    }
    this._activeEffect = effect;
    this.bindOnlyWorldMatrix(world);
    this._activeEffect.setMatrix("viewProjection", scene.getTransformMatrix());
    this._activeEffect.setVector3("cameraPosition", scene.activeCamera.position);
    this._activeEffect.setFloat("_Radius_", this.radius);
    this._activeEffect.setFloat("_Line_Width_", this.lineWidth);
    this._activeEffect.setFloat("_Relative_To_Height_", this.relativeToHeight ? 1 : 0);
    this._activeEffect.setFloat("_Filter_Width_", this._filterWidth);
    this._activeEffect.setDirectColor4("_Edge_Color_", this.edgeColor);
    this._activeEffect.setFloat("_Fade_Out_", this.fadeOut);
    this._activeEffect.setFloat("_Blob_Enable_", this.blobEnable ? 1 : 0);
    this._activeEffect.setVector3("_Blob_Position_", this.blobPosition);
    this._activeEffect.setFloat("_Blob_Intensity_", this.blobIntensity);
    this._activeEffect.setFloat("_Blob_Near_Size_", this.blobNearSize);
    this._activeEffect.setFloat("_Blob_Far_Size_", this.blobFarSize);
    this._activeEffect.setFloat("_Blob_Near_Distance_", this.blobNearDistance);
    this._activeEffect.setFloat("_Blob_Far_Distance_", this.blobFarDistance);
    this._activeEffect.setFloat("_Blob_Fade_Length_", this.blobFadeLength);
    this._activeEffect.setFloat("_Blob_Inner_Fade_", this.blobInnerFade);
    this._activeEffect.setFloat("_Blob_Pulse_", this.blobPulse);
    this._activeEffect.setFloat("_Blob_Fade_", this.blobFade);
    this._activeEffect.setFloat("_Blob_Pulse_Max_Size_", this.blobPulseMaxSize);
    this._activeEffect.setFloat("_Blob_Enable_2_", this.blobEnable2 ? 1 : 0);
    this._activeEffect.setVector3("_Blob_Position_2_", this.blobPosition2);
    this._activeEffect.setFloat("_Blob_Near_Size_2_", this.blobNearSize2);
    this._activeEffect.setFloat("_Blob_Inner_Fade_2_", this.blobInnerFade2);
    this._activeEffect.setFloat("_Blob_Pulse_2_", this.blobPulse2);
    this._activeEffect.setFloat("_Blob_Fade_2_", this.blobFade2);
    this._activeEffect.setFloat("_Gaze_Intensity_", this.gazeIntensity);
    this._activeEffect.setFloat("_Gaze_Focus_", this.gazeFocus);
    this._activeEffect.setTexture("_Blob_Texture_", this._blobTexture);
    this._activeEffect.setFloat("_Selection_Fuzz_", this.selectionFuzz);
    this._activeEffect.setFloat("_Selected_", this.selected);
    this._activeEffect.setFloat("_Selection_Fade_", this.selectionFade);
    this._activeEffect.setFloat("_Selection_Fade_Size_", this.selectionFadeSize);
    this._activeEffect.setFloat("_Selected_Distance_", this.selectedDistance);
    this._activeEffect.setFloat("_Selected_Fade_Length_", this.selectedFadeLength);
    this._activeEffect.setFloat("_Proximity_Max_Intensity_", this.proximityMaxIntensity);
    this._activeEffect.setFloat("_Proximity_Far_Distance_", this.proximityFarDistance);
    this._activeEffect.setFloat("_Proximity_Near_Radius_", this.proximityNearRadius);
    this._activeEffect.setFloat("_Proximity_Anisotropy_", this.proximityAnisotropy);
    this._activeEffect.setFloat("_Use_Global_Left_Index_", this.useGlobalLeftIndex ? 1 : 0);
    this._activeEffect.setFloat("_Use_Global_Right_Index_", this.useGlobalRightIndex ? 1 : 0);
    this._afterBind(mesh, this._activeEffect, subMesh);
  }
  /**
   * Get the list of animatables in the material.
   * @returns the list of animatables object used in the material
   */
  getAnimatables() {
    return [];
  }
  dispose(forceDisposeEffect) {
    super.dispose(forceDisposeEffect);
  }
  clone(name22) {
    return SerializationHelper.Clone(() => new _MRDLFrontplateMaterial(name22, this.getScene()), this);
  }
  serialize() {
    const serializationObject = SerializationHelper.Serialize(this);
    serializationObject.customType = "BABYLON.MRDLFrontplateMaterial";
    return serializationObject;
  }
  getClassName() {
    return "MRDLFrontplateMaterial";
  }
  // Statics
  static Parse(source, scene, rootUrl) {
    return SerializationHelper.Parse(() => new _MRDLFrontplateMaterial(source.name, scene), source, scene, rootUrl);
  }
};
MRDLFrontplateMaterial.BLOB_TEXTURE_URL = "";
__decorate([
  serialize()
], MRDLFrontplateMaterial.prototype, "radius", void 0);
__decorate([
  serialize()
], MRDLFrontplateMaterial.prototype, "lineWidth", void 0);
__decorate([
  serialize()
], MRDLFrontplateMaterial.prototype, "relativeToHeight", void 0);
__decorate([
  serialize()
], MRDLFrontplateMaterial.prototype, "edgeColor", void 0);
__decorate([
  serialize()
], MRDLFrontplateMaterial.prototype, "blobEnable", void 0);
__decorate([
  serialize()
], MRDLFrontplateMaterial.prototype, "blobPosition", void 0);
__decorate([
  serialize()
], MRDLFrontplateMaterial.prototype, "blobIntensity", void 0);
__decorate([
  serialize()
], MRDLFrontplateMaterial.prototype, "blobNearSize", void 0);
__decorate([
  serialize()
], MRDLFrontplateMaterial.prototype, "blobFarSize", void 0);
__decorate([
  serialize()
], MRDLFrontplateMaterial.prototype, "blobNearDistance", void 0);
__decorate([
  serialize()
], MRDLFrontplateMaterial.prototype, "blobFarDistance", void 0);
__decorate([
  serialize()
], MRDLFrontplateMaterial.prototype, "blobFadeLength", void 0);
__decorate([
  serialize()
], MRDLFrontplateMaterial.prototype, "blobInnerFade", void 0);
__decorate([
  serialize()
], MRDLFrontplateMaterial.prototype, "blobPulse", void 0);
__decorate([
  serialize()
], MRDLFrontplateMaterial.prototype, "blobFade", void 0);
__decorate([
  serialize()
], MRDLFrontplateMaterial.prototype, "blobPulseMaxSize", void 0);
__decorate([
  serialize()
], MRDLFrontplateMaterial.prototype, "blobEnable2", void 0);
__decorate([
  serialize()
], MRDLFrontplateMaterial.prototype, "blobPosition2", void 0);
__decorate([
  serialize()
], MRDLFrontplateMaterial.prototype, "blobNearSize2", void 0);
__decorate([
  serialize()
], MRDLFrontplateMaterial.prototype, "blobInnerFade2", void 0);
__decorate([
  serialize()
], MRDLFrontplateMaterial.prototype, "blobPulse2", void 0);
__decorate([
  serialize()
], MRDLFrontplateMaterial.prototype, "blobFade2", void 0);
__decorate([
  serialize()
], MRDLFrontplateMaterial.prototype, "gazeIntensity", void 0);
__decorate([
  serialize()
], MRDLFrontplateMaterial.prototype, "gazeFocus", void 0);
__decorate([
  serialize()
], MRDLFrontplateMaterial.prototype, "selectionFuzz", void 0);
__decorate([
  serialize()
], MRDLFrontplateMaterial.prototype, "selected", void 0);
__decorate([
  serialize()
], MRDLFrontplateMaterial.prototype, "selectionFade", void 0);
__decorate([
  serialize()
], MRDLFrontplateMaterial.prototype, "selectionFadeSize", void 0);
__decorate([
  serialize()
], MRDLFrontplateMaterial.prototype, "selectedDistance", void 0);
__decorate([
  serialize()
], MRDLFrontplateMaterial.prototype, "selectedFadeLength", void 0);
__decorate([
  serialize()
], MRDLFrontplateMaterial.prototype, "proximityMaxIntensity", void 0);
__decorate([
  serialize()
], MRDLFrontplateMaterial.prototype, "proximityFarDistance", void 0);
__decorate([
  serialize()
], MRDLFrontplateMaterial.prototype, "proximityNearRadius", void 0);
__decorate([
  serialize()
], MRDLFrontplateMaterial.prototype, "proximityAnisotropy", void 0);
__decorate([
  serialize()
], MRDLFrontplateMaterial.prototype, "useGlobalLeftIndex", void 0);
__decorate([
  serialize()
], MRDLFrontplateMaterial.prototype, "useGlobalRightIndex", void 0);
RegisterClass("BABYLON.GUI.MRDLFrontplateMaterial", MRDLFrontplateMaterial);

// node_modules/@babylonjs/gui/3D/materials/mrdl/shaders/mrdlInnerquad.fragment.js
var name20 = "mrdlInnerquadPixelShader";
var shader19 = `uniform vec3 cameraPosition;varying vec2 vUV;varying vec3 vTangent;uniform vec4 _Color_;uniform float _Radius_;uniform bool _Fixed_Radius_;uniform float _Filter_Width_;uniform float _Glow_Fraction_;uniform float _Glow_Max_;uniform float _Glow_Falloff_;float FilterStep_Bid194(float edge,float x,float filterWidth)
{float dx=max(1.0E-5,fwidth(x)*filterWidth);return max((x+dx*0.5-max(edge,x-dx*0.5))/dx,0.0);}
void Round_Rect_B194(
float Size_X,
float Size_Y,
float Radius,
vec4 Rect_Color,
float Filter_Width,
vec2 UV,
float Glow_Fraction,
float Glow_Max,
float Glow_Falloff,
out vec4 Color)
{vec2 halfSize=vec2(Size_X,Size_Y)*0.5;vec2 r=max(min(vec2(Radius,Radius),halfSize),vec2(0.01,0.01));vec2 v=abs(UV);vec2 nearestp=min(v,halfSize-r);vec2 delta=(v-nearestp)/max(vec2(0.01,0.01),r);float Distance=length(delta);float insideRect=1.0-FilterStep_Bid194(1.0-Glow_Fraction,Distance,Filter_Width);float glow=clamp((1.0-Distance)/Glow_Fraction,0.0,1.0);glow=pow(glow,Glow_Falloff);Color=Rect_Color*max(insideRect,glow*Glow_Max);}
void main()
{float X_Q192;float Y_Q192;float Z_Q192;X_Q192=vTangent.x;Y_Q192=vTangent.y;Z_Q192=vTangent.z;vec4 Color_Q194;Round_Rect_B194(X_Q192,1.0,Y_Q192,_Color_,_Filter_Width_,vUV,_Glow_Fraction_,_Glow_Max_,_Glow_Falloff_,Color_Q194);vec4 Out_Color=Color_Q194;float Clip_Threshold=0.0;gl_FragColor=Out_Color;}
`;
ShaderStore.ShadersStore[name20] = shader19;

// node_modules/@babylonjs/gui/3D/materials/mrdl/shaders/mrdlInnerquad.vertex.js
var name21 = "mrdlInnerquadVertexShader";
var shader20 = `uniform mat4 world;uniform mat4 viewProjection;uniform vec3 cameraPosition;attribute vec3 position;attribute vec3 normal;attribute vec2 uv;attribute vec3 tangent;attribute vec4 color;uniform vec4 _Color_;uniform float _Radius_;uniform bool _Fixed_Radius_;uniform float _Filter_Width_;uniform float _Glow_Fraction_;uniform float _Glow_Max_;uniform float _Glow_Falloff_;varying vec2 vUV;varying vec3 vTangent;void main()
{vec3 Pos_World_Q189;Pos_World_Q189=(world*vec4(position,1.0)).xyz;vec3 Dir_World_Q190;Dir_World_Q190=(world*vec4(tangent,0.0)).xyz;vec3 Dir_World_Q191;Dir_World_Q191=(world*vec4((cross(normal,tangent)),0.0)).xyz;float Length_Q180=length(Dir_World_Q190);float Length_Q181=length(Dir_World_Q191);float Quotient_Q184=Length_Q180/Length_Q181;float Quotient_Q195=_Radius_/Length_Q181;vec2 Result_Q193;Result_Q193=vec2((uv.x-0.5)*Length_Q180/Length_Q181,(uv.y-0.5));float Result_Q198=_Fixed_Radius_ ? Quotient_Q195 : _Radius_;vec3 Vec3_Q183=vec3(Quotient_Q184,Result_Q198,0);vec3 Position=Pos_World_Q189;vec3 Normal=vec3(0,0,0);vec2 UV=Result_Q193;vec3 Tangent=Vec3_Q183;vec3 Binormal=vec3(0,0,0);vec4 Color=color;gl_Position=viewProjection*vec4(Position,1);vUV=UV;vTangent=Tangent;}
`;
ShaderStore.ShadersStore[name21] = shader20;

// node_modules/@babylonjs/gui/3D/materials/mrdl/mrdlInnerquadMaterial.js
var MRDLInnerquadMaterialDefines = class extends MaterialDefines {
  constructor() {
    super();
    this._needNormals = true;
    this._needUVs = true;
    this.rebuild();
  }
};
var MRDLInnerquadMaterial = class _MRDLInnerquadMaterial extends PushMaterial {
  constructor(name22, scene) {
    super(name22, scene);
    this.color = new Color4(1, 1, 1, 0.05);
    this.radius = 0.12;
    this.fixedRadius = true;
    this._filterWidth = 1;
    this.glowFraction = 0;
    this.glowMax = 0.5;
    this.glowFalloff = 2;
    this.alphaMode = Constants.ALPHA_COMBINE;
    this.backFaceCulling = false;
  }
  needAlphaBlending() {
    return true;
  }
  needAlphaTesting() {
    return false;
  }
  getAlphaTestTexture() {
    return null;
  }
  // Methods
  isReadyForSubMesh(mesh, subMesh) {
    const drawWrapper = subMesh._drawWrapper;
    if (this.isFrozen) {
      if (drawWrapper.effect && drawWrapper._wasPreviouslyReady) {
        return true;
      }
    }
    if (!subMesh.materialDefines) {
      subMesh.materialDefines = new MRDLInnerquadMaterialDefines();
    }
    const defines = subMesh.materialDefines;
    const scene = this.getScene();
    if (this._isReadyForSubMesh(subMesh)) {
      return true;
    }
    const engine = scene.getEngine();
    PrepareDefinesForAttributes(mesh, defines, true, false);
    if (defines.isDirty) {
      defines.markAsProcessed();
      scene.resetCachedMaterial();
      const fallbacks = new EffectFallbacks();
      if (defines.FOG) {
        fallbacks.addFallback(1, "FOG");
      }
      HandleFallbacksForShadows(defines, fallbacks);
      defines.IMAGEPROCESSINGPOSTPROCESS = scene.imageProcessingConfiguration.applyByPostProcess;
      const attribs = [VertexBuffer.PositionKind];
      if (defines.NORMAL) {
        attribs.push(VertexBuffer.NormalKind);
      }
      if (defines.UV1) {
        attribs.push(VertexBuffer.UVKind);
      }
      if (defines.UV2) {
        attribs.push(VertexBuffer.UV2Kind);
      }
      if (defines.VERTEXCOLOR) {
        attribs.push(VertexBuffer.ColorKind);
      }
      if (defines.TANGENT) {
        attribs.push(VertexBuffer.TangentKind);
      }
      PrepareAttributesForInstances(attribs, defines);
      const shaderName = "mrdlInnerquad";
      const join = defines.toString();
      const uniforms = [
        "world",
        "worldView",
        "worldViewProjection",
        "view",
        "projection",
        "viewProjection",
        "cameraPosition",
        "_Color_",
        "_Radius_",
        "_Fixed_Radius_",
        "_Filter_Width_",
        "_Glow_Fraction_",
        "_Glow_Max_",
        "_Glow_Falloff_"
      ];
      const samplers = [];
      const uniformBuffers = [];
      PrepareUniformsAndSamplersList({
        uniformsNames: uniforms,
        uniformBuffersNames: uniformBuffers,
        samplers,
        defines,
        maxSimultaneousLights: 4
      });
      subMesh.setEffect(scene.getEngine().createEffect(shaderName, {
        attributes: attribs,
        uniformsNames: uniforms,
        uniformBuffersNames: uniformBuffers,
        samplers,
        defines: join,
        fallbacks,
        onCompiled: this.onCompiled,
        onError: this.onError,
        indexParameters: { maxSimultaneousLights: 4 }
      }, engine), defines);
    }
    if (!subMesh.effect || !subMesh.effect.isReady()) {
      return false;
    }
    defines._renderId = scene.getRenderId();
    drawWrapper._wasPreviouslyReady = true;
    return true;
  }
  bindForSubMesh(world, mesh, subMesh) {
    const scene = this.getScene();
    const defines = subMesh.materialDefines;
    if (!defines) {
      return;
    }
    const effect = subMesh.effect;
    if (!effect) {
      return;
    }
    this._activeEffect = effect;
    this.bindOnlyWorldMatrix(world);
    this._activeEffect.setMatrix("viewProjection", scene.getTransformMatrix());
    this._activeEffect.setVector3("cameraPosition", scene.activeCamera.position);
    this._activeEffect.setDirectColor4("_Color_", this.color);
    this._activeEffect.setFloat("_Radius_", this.radius);
    this._activeEffect.setFloat("_Fixed_Radius_", this.fixedRadius ? 1 : 0);
    this._activeEffect.setFloat("_Filter_Width_", this._filterWidth);
    this._activeEffect.setFloat("_Glow_Fraction_", this.glowFraction);
    this._activeEffect.setFloat("_Glow_Max_", this.glowMax);
    this._activeEffect.setFloat("_Glow_Falloff_", this.glowFalloff);
    this._afterBind(mesh, this._activeEffect, subMesh);
  }
  /**
   * Get the list of animatables in the material.
   * @returns the list of animatables object used in the material
   */
  getAnimatables() {
    return [];
  }
  dispose(forceDisposeEffect) {
    super.dispose(forceDisposeEffect);
  }
  clone(name22) {
    return SerializationHelper.Clone(() => new _MRDLInnerquadMaterial(name22, this.getScene()), this);
  }
  serialize() {
    const serializationObject = SerializationHelper.Serialize(this);
    serializationObject.customType = "BABYLON.MRDLInnerquadMaterial";
    return serializationObject;
  }
  getClassName() {
    return "MRDLInnerquadMaterial";
  }
  // Statics
  static Parse(source, scene, rootUrl) {
    return SerializationHelper.Parse(() => new _MRDLInnerquadMaterial(source.name, scene), source, scene, rootUrl);
  }
};
__decorate([
  serialize()
], MRDLInnerquadMaterial.prototype, "color", void 0);
__decorate([
  serialize()
], MRDLInnerquadMaterial.prototype, "radius", void 0);
__decorate([
  serialize()
], MRDLInnerquadMaterial.prototype, "fixedRadius", void 0);
__decorate([
  serialize()
], MRDLInnerquadMaterial.prototype, "glowFraction", void 0);
__decorate([
  serialize()
], MRDLInnerquadMaterial.prototype, "glowMax", void 0);
__decorate([
  serialize()
], MRDLInnerquadMaterial.prototype, "glowFalloff", void 0);
RegisterClass("BABYLON.GUI.MRDLInnerquadMaterial", MRDLInnerquadMaterial);

// node_modules/@babylonjs/gui/3D/controls/MRTK3/touchHolographicButton.js
var TouchHolographicButton2 = class _TouchHolographicButton extends TouchButton3D {
  _disposeTooltip() {
    this._tooltipFade = null;
    if (this._tooltipTextBlock) {
      this._tooltipTextBlock.dispose();
    }
    if (this._tooltipTexture) {
      this._tooltipTexture.dispose();
    }
    if (this._tooltipMesh) {
      this._tooltipMesh.dispose();
    }
    this.onPointerEnterObservable.remove(this._tooltipHoverObserver);
    this.onPointerOutObservable.remove(this._tooltipOutObserver);
  }
  /**
   * Rendering ground id of all the mesh in the button
   */
  set renderingGroupId(id) {
    this._backPlate.renderingGroupId = id;
    this._textPlate.renderingGroupId = id;
    this._frontPlate.renderingGroupId = id;
    this._backGlow.renderingGroupId = id;
    this._innerQuad.renderingGroupId = id;
    if (this._tooltipMesh) {
      this._tooltipMesh.renderingGroupId = id;
    }
  }
  get renderingGroupId() {
    return this._backPlate.renderingGroupId;
  }
  /**
   * Gets the mesh used to render this control
   */
  get mesh() {
    return this._backPlate;
  }
  /**
   * Text to be displayed on the tooltip shown when hovering on the button. When set to null tooltip is disabled. (Default: null)
   * Set this property after adding the button to the GUI3DManager
   */
  set tooltipText(text) {
    if (!text) {
      this._disposeTooltip();
      return;
    }
    if (!this._tooltipFade) {
      const rightHandedScene = this._backPlate._scene.useRightHandedSystem;
      this._tooltipMesh = CreatePlane("", { size: 1 }, this._backPlate._scene);
      this._tooltipMesh.position = Vector3.Down().scale(0.7).add(Vector3.Forward(rightHandedScene).scale(-0.15));
      this._tooltipMesh.isPickable = false;
      this._tooltipMesh.parent = this._frontPlateCollisionMesh;
      this._tooltipTexture = AdvancedDynamicTexture.CreateForMesh(this._tooltipMesh);
      const tooltipBackground = new Rectangle();
      tooltipBackground.height = 0.25;
      tooltipBackground.width = 0.8;
      tooltipBackground.cornerRadius = 25;
      tooltipBackground.color = "#ffffff";
      tooltipBackground.thickness = 20;
      tooltipBackground.background = "#060668";
      this._tooltipTexture.addControl(tooltipBackground);
      this._tooltipTextBlock = new TextBlock();
      this._tooltipTextBlock.color = "white";
      this._tooltipTextBlock.fontSize = 100;
      this._tooltipTexture.addControl(this._tooltipTextBlock);
      this._tooltipFade = new FadeInOutBehavior();
      this._tooltipFade.delay = 500;
      this._tooltipMesh.addBehavior(this._tooltipFade);
      this._tooltipHoverObserver = this.onPointerEnterObservable.add(() => {
        if (this._tooltipFade) {
          this._tooltipFade.fadeIn(true);
        }
      });
      this._tooltipOutObserver = this.onPointerOutObservable.add(() => {
        if (this._tooltipFade) {
          this._tooltipFade.fadeIn(false);
        }
      });
    }
    if (this._tooltipTextBlock) {
      this._tooltipTextBlock.text = text;
    }
  }
  get tooltipText() {
    var _a;
    return ((_a = this._tooltipTextBlock) == null ? void 0 : _a.text) || null;
  }
  /**
   * Gets or sets text for the button
   */
  get text() {
    return this._text;
  }
  set text(value) {
    if (this._text === value) {
      return;
    }
    this._text = value;
    this._rebuildContent();
  }
  /**
   * Gets or sets subtext for a button with larger width
   */
  get subtext() {
    return this._subtext;
  }
  set subtext(value) {
    if (this._subtext === value) {
      return;
    }
    this._subtext = value;
    this._rebuildContent();
  }
  /**
   * Gets or sets the image url for the button
   */
  get imageUrl() {
    return this._imageUrl;
  }
  set imageUrl(value) {
    if (this._imageUrl === value) {
      return;
    }
    this._imageUrl = value;
    this._rebuildContent();
  }
  /**
   * Gets the back material used by this button
   */
  get backMaterial() {
    return this._backMaterial;
  }
  /**
   * Gets the front material used by this button
   */
  get frontMaterial() {
    return this._frontMaterial;
  }
  /**
   * Gets the back glow material used by this button
   */
  get backGlowMaterial() {
    return this._backGlowMaterial;
  }
  /**
   * Gets the inner quad material used by this button
   */
  get innerQuadMaterial() {
    return this._innerQuadMaterial;
  }
  /**
   * Gets the plate material used by this button
   */
  get plateMaterial() {
    return this._plateMaterial;
  }
  /**
   * Gets a boolean indicating if this button shares its material with other V3 Buttons
   */
  get shareMaterials() {
    return this._shareMaterials;
  }
  /**
   * Sets whether the backplate is visible or hidden. Hiding the backplate is not recommended without some sort of replacement
   */
  set isBackplateVisible(isVisible) {
    if (this.mesh && this._backMaterial) {
      if (isVisible && !this._isBackplateVisible) {
        this._backPlate.visibility = 1;
      } else if (!isVisible && this._isBackplateVisible) {
        this._backPlate.visibility = 0;
      }
    }
    this._isBackplateVisible = isVisible;
  }
  /**
   * Creates a new button
   * @param name defines the control name
   * @param shareMaterials
   */
  constructor(name22, shareMaterials = true) {
    super(name22);
    this.width = 1;
    this.height = 1;
    this.radius = 0.14;
    this.textSizeInPixels = 18;
    this.imageSizeInPixels = 40;
    this.plateMaterialColor = new Color3(0.4, 0.4, 0.4);
    this.frontPlateDepth = 0.2;
    this.backPlateDepth = 0.04;
    this.backGlowOffset = 0.1;
    this.flatPlaneDepth = 1e-3;
    this.innerQuadRadius = this.radius - 0.04;
    this.innerQuadColor = new Color4(0, 0, 0, 0);
    this.innerQuadToggledColor = new Color4(0.5197843, 0.6485234, 0.9607843, 0.6);
    this.innerQuadHoverColor = new Color4(1, 1, 1, 0.05);
    this.innerQuadToggledHoverColor = new Color4(0.5197843, 0.6485234, 0.9607843, 1);
    this._isBackplateVisible = true;
    this._shareMaterials = true;
    this._shareMaterials = shareMaterials;
    this.pointerEnterAnimation = () => {
      if (this._frontPlate && this._textPlate && !this.isToggleButton) {
        this._performEnterExitAnimation(1);
      }
      if (this.isToggleButton && this._innerQuadMaterial) {
        if (this.isToggled) {
          this._innerQuadMaterial.color = this.innerQuadToggledHoverColor;
        } else {
          this._innerQuadMaterial.color = this.innerQuadHoverColor;
        }
      }
    };
    this.pointerOutAnimation = () => {
      if (this._frontPlate && this._textPlate && !this.isToggleButton) {
        this._performEnterExitAnimation(-0.8);
      }
      if (this.isToggleButton && this._innerQuadMaterial) {
        this._onToggle(this.isToggled);
      }
    };
    this.pointerDownAnimation = () => {
    };
    this.pointerUpAnimation = () => {
    };
    this._pointerClickObserver = this.onPointerClickObservable.add(() => {
      if (this._frontPlate && this._backGlow && !this.isActiveNearInteraction) {
        this._performClickAnimation();
      }
      if (this.isToggleButton && this._innerQuadMaterial) {
        this._onToggle(this.isToggled);
      }
    });
    this._pointerEnterObserver = this.onPointerEnterObservable.add(() => {
      this.pointerEnterAnimation();
    });
    this._pointerOutObserver = this.onPointerOutObservable.add(() => {
      this.pointerOutAnimation();
    });
    this._toggleObserver = this.onToggleObservable.add((isToggled) => {
      if (isToggled) {
        this._innerQuadMaterial.color = this.innerQuadToggledColor;
      } else {
        this._innerQuadMaterial.color = this.innerQuadColor;
      }
    });
  }
  _getTypeName() {
    return "TouchHolographicButton";
  }
  _rebuildContent() {
    let content;
    if (this._getAspectRatio() <= 1) {
      content = this._alignContentVertically();
    } else {
      content = this._alignContentHorizontally();
    }
    this.content = content;
  }
  _getAspectRatio() {
    return this.width / this.height;
  }
  _alignContentVertically() {
    const panel = new StackPanel();
    panel.isVertical = true;
    if (IsDocumentAvailable() && !!document.createElement) {
      if (this._imageUrl) {
        const image = new Image();
        image.source = this._imageUrl;
        image.heightInPixels = 180;
        image.widthInPixels = 100;
        image.paddingTopInPixels = 40;
        image.paddingBottomInPixels = 40;
        panel.addControl(image);
      }
    }
    if (this._text) {
      const text = new TextBlock();
      text.text = this._text;
      text.color = "white";
      text.heightInPixels = 30;
      text.fontSize = 24;
      panel.addControl(text);
    }
    return panel;
  }
  _alignContentHorizontally() {
    let totalPanelWidthInPixels = 240;
    const padding = 15;
    const contentContainer = new Rectangle();
    contentContainer.widthInPixels = totalPanelWidthInPixels;
    contentContainer.heightInPixels = totalPanelWidthInPixels;
    contentContainer.color = "transparent";
    contentContainer.setPaddingInPixels(padding, padding, padding, padding);
    totalPanelWidthInPixels -= padding * 2;
    const panel = new StackPanel();
    panel.isVertical = false;
    panel.scaleY = this._getAspectRatio();
    if (IsDocumentAvailable() && !!document.createElement) {
      if (this._imageUrl) {
        const imageContainer = new Rectangle(`${this.name}_image`);
        imageContainer.widthInPixels = this.imageSizeInPixels;
        imageContainer.heightInPixels = this.imageSizeInPixels;
        imageContainer.color = "transparent";
        totalPanelWidthInPixels -= this.imageSizeInPixels;
        const image = new Image();
        image.source = this._imageUrl;
        imageContainer.addControl(image);
        panel.addControl(imageContainer);
      }
    }
    if (this._text) {
      const text = new TextBlock(`${this.name}_text`);
      text.text = this._text;
      text.color = "white";
      text.fontSize = this.textSizeInPixels;
      text.widthInPixels = totalPanelWidthInPixels;
      if (this._imageUrl) {
        text.textHorizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;
        text.paddingLeftInPixels = padding;
      }
      if (this._subtext) {
        const textContainer = new Grid();
        textContainer.addColumnDefinition(1);
        textContainer.addRowDefinition(0.5);
        textContainer.addRowDefinition(0.5);
        textContainer.widthInPixels = totalPanelWidthInPixels;
        textContainer.heightInPixels = 45;
        const subtext = new TextBlock(`${this.name}_subtext`);
        subtext.text = this._subtext;
        subtext.color = "#EEEEEEAB";
        subtext.fontSize = this.textSizeInPixels * 0.75;
        subtext.fontWeight = "600";
        if (this._imageUrl) {
          subtext.textHorizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;
          subtext.paddingLeftInPixels = padding;
        }
        textContainer.addControl(text, 0);
        textContainer.addControl(subtext, 1);
        panel.addControl(textContainer);
      } else {
        panel.addControl(text);
      }
    }
    contentContainer.addControl(panel);
    return contentContainer;
  }
  // Mesh association
  _createNode(scene) {
    this.name = this.name ?? "TouchHolographicButton";
    const backPlateMesh = this._createBackPlate(scene);
    const collisionMesh = this._createFrontPlate(scene);
    const innerQuadMesh = this._createInnerQuad(scene);
    const backGlowMesh = this._createBackGlow(scene);
    this._frontPlateCollisionMesh = collisionMesh;
    this._textPlate = super._createNode(scene);
    this._textPlate.name = `${this.name}_textPlate`;
    this._textPlate.isPickable = false;
    this._textPlate.scaling.x = this.width;
    this._textPlate.parent = collisionMesh;
    this._backPlate = backPlateMesh;
    this._backPlate.position = Vector3.Forward(scene.useRightHandedSystem).scale(this.backPlateDepth / 2);
    this._backPlate.isPickable = false;
    this._backPlate.addChild(collisionMesh);
    this._backPlate.addChild(innerQuadMesh);
    if (backGlowMesh) {
      this._backPlate.addChild(backGlowMesh);
    }
    const tn = new TransformNode(`${this.name}_root`, scene);
    this._backPlate.setParent(tn);
    this.collisionMesh = collisionMesh;
    this.collidableFrontDirection = this._backPlate.forward.negate();
    return tn;
  }
  _createBackPlate(scene) {
    const backPlateMesh = CreateBox(`${this.name}_backPlate`, {}, scene);
    backPlateMesh.isPickable = false;
    backPlateMesh.visibility = 0;
    backPlateMesh.scaling.z = 0.2;
    SceneLoader.ImportMeshAsync(void 0, _TouchHolographicButton.MRTK_ASSET_BASE_URL, _TouchHolographicButton.BACKPLATE_MODEL_FILENAME, scene).then((result) => {
      const backPlateModel = result.meshes[1];
      backPlateModel.visibility = 0;
      if (this._isBackplateVisible) {
        backPlateModel.visibility = 1;
        backPlateModel.name = `${this.name}_backPlate`;
        backPlateModel.isPickable = false;
        backPlateModel.scaling.x = this.width;
        backPlateModel.scaling.y = this.height;
        backPlateModel.parent = backPlateMesh;
      }
      if (this._backMaterial) {
        backPlateModel.material = this._backMaterial;
      }
      this._backPlate = backPlateModel;
    });
    return backPlateMesh;
  }
  _createFrontPlate(scene) {
    const collisionMesh = CreateBox(`${this.name}_frontPlate`, {
      width: this.width,
      height: this.height,
      depth: this.frontPlateDepth
    }, scene);
    collisionMesh.isPickable = true;
    collisionMesh.isNearPickable = true;
    collisionMesh.visibility = 0;
    collisionMesh.position = Vector3.Forward(scene.useRightHandedSystem).scale((this.backPlateDepth - this.frontPlateDepth) / 2);
    SceneLoader.ImportMeshAsync(void 0, _TouchHolographicButton.MRTK_ASSET_BASE_URL, _TouchHolographicButton.FRONTPLATE_MODEL_FILENAME, scene).then((result) => {
      const collisionPlate = CreateBox(`${this.name}_collisionPlate`, {
        width: this.width,
        height: this.height
      }, scene);
      collisionPlate.isPickable = false;
      collisionPlate.scaling.z = this.frontPlateDepth;
      collisionPlate.visibility = 0;
      collisionPlate.parent = collisionMesh;
      this._collisionPlate = collisionPlate;
      const frontPlateModel = result.meshes[1];
      frontPlateModel.name = `${this.name}_frontPlate`;
      frontPlateModel.isPickable = false;
      frontPlateModel.scaling.x = this.width - this.backGlowOffset;
      frontPlateModel.scaling.y = this.height - this.backGlowOffset;
      frontPlateModel.position = Vector3.Forward(scene.useRightHandedSystem).scale(-0.5);
      frontPlateModel.parent = collisionPlate;
      if (this.isToggleButton) {
        frontPlateModel.visibility = 0;
      }
      if (this._frontMaterial) {
        frontPlateModel.material = this._frontMaterial;
      }
      this._textPlate.scaling.x = 1;
      this._textPlate.parent = frontPlateModel;
      this._frontPlate = frontPlateModel;
    });
    return collisionMesh;
  }
  _createInnerQuad(scene) {
    const innerQuadMesh = CreateBox(`${this.name}_innerQuad`, {}, scene);
    innerQuadMesh.isPickable = false;
    innerQuadMesh.visibility = 0;
    innerQuadMesh.scaling.z = this.flatPlaneDepth;
    innerQuadMesh.position.z += this.backPlateDepth / 2 - this.flatPlaneDepth;
    SceneLoader.ImportMeshAsync(void 0, _TouchHolographicButton.MRTK_ASSET_BASE_URL, _TouchHolographicButton.INNERQUAD_MODEL_FILENAME, scene).then((result) => {
      const innerQuadModel = result.meshes[1];
      innerQuadModel.name = `${this.name}_innerQuad`;
      innerQuadModel.isPickable = false;
      innerQuadModel.scaling.x = this.width - this.backGlowOffset;
      innerQuadModel.scaling.y = this.height - this.backGlowOffset;
      innerQuadModel.parent = innerQuadMesh;
      if (this._innerQuadMaterial) {
        innerQuadModel.material = this._innerQuadMaterial;
      }
      this._innerQuad = innerQuadModel;
    });
    return innerQuadMesh;
  }
  _createBackGlow(scene) {
    if (this.isToggleButton) {
      return;
    }
    const backGlowMesh = CreateBox(`${this.name}_backGlow`, {}, scene);
    backGlowMesh.isPickable = false;
    backGlowMesh.visibility = 0;
    backGlowMesh.scaling.z = this.flatPlaneDepth;
    backGlowMesh.position.z += this.backPlateDepth / 2 - this.flatPlaneDepth * 2;
    SceneLoader.ImportMeshAsync(void 0, _TouchHolographicButton.MRTK_ASSET_BASE_URL, _TouchHolographicButton.BACKGLOW_MODEL_FILENAME, scene).then((result) => {
      const backGlowModel = result.meshes[1];
      backGlowModel.name = `${this.name}_backGlow`;
      backGlowModel.isPickable = false;
      backGlowModel.scaling.x = this.width - this.backGlowOffset;
      backGlowModel.scaling.y = this.height - this.backGlowOffset;
      backGlowModel.parent = backGlowMesh;
      if (this._backGlowMaterial) {
        backGlowModel.material = this._backGlowMaterial;
      }
      this._backGlow = backGlowModel;
    });
    return backGlowMesh;
  }
  _applyFacade(facadeTexture) {
    this._plateMaterial.emissiveTexture = facadeTexture;
    this._plateMaterial.opacityTexture = facadeTexture;
    this._plateMaterial.diffuseColor = this.plateMaterialColor;
  }
  _performClickAnimation() {
    const frameRate = 60;
    const animationGroup = new AnimationGroup("Click Animation Group");
    const animations = [
      {
        name: "backGlowMotion",
        mesh: this._backGlow,
        property: "material.motion",
        keys: [
          {
            frame: 0,
            values: [0, 0, 0]
          },
          {
            frame: 20,
            values: [1, 0.0144, 0.0144]
          },
          {
            frame: 40,
            values: [0.0027713229489760476, 0, 0]
          },
          {
            frame: 45,
            values: [0.0027713229489760476]
          }
        ]
      },
      {
        name: "_collisionPlateZSlide",
        mesh: this._collisionPlate,
        property: "position.z",
        keys: [
          {
            frame: 0,
            values: [0, 0, 0]
          },
          {
            frame: 20,
            values: [Vector3.Forward(this._collisionPlate._scene.useRightHandedSystem).scale(this.frontPlateDepth / 2).z, 0, 0]
          },
          {
            frame: 40,
            values: [0, 0.005403332496794331]
          },
          {
            frame: 45,
            values: [0]
          }
        ]
      },
      {
        name: "_collisionPlateZScale",
        mesh: this._collisionPlate,
        property: "scaling.z",
        keys: [
          {
            frame: 0,
            values: [this.frontPlateDepth, 0, 0]
          },
          {
            frame: 20,
            values: [this.backPlateDepth, 0, 0]
          },
          {
            frame: 40,
            values: [this.frontPlateDepth, 54e-4]
          },
          {
            frame: 45,
            values: [this.frontPlateDepth]
          }
        ]
      }
    ];
    for (const animation of animations) {
      const anim = new Animation(animation.name, animation.property, frameRate, Animation.ANIMATIONTYPE_FLOAT, Animation.ANIMATIONLOOPMODE_CYCLE);
      const animkeyFrames = [];
      for (const key of animation.keys) {
        animkeyFrames.push({
          frame: key.frame,
          value: key.values[0],
          inTangent: key.values[1],
          outTangent: key.values[2],
          interpolation: key.values[3]
        });
      }
      anim.setKeys(animkeyFrames);
      if (!animation.mesh) {
        continue;
      }
      animationGroup.addTargetedAnimation(anim, animation.mesh);
    }
    animationGroup.normalize(0, 45);
    animationGroup.speedRatio = 1;
    animationGroup.play();
  }
  _performEnterExitAnimation(speedRatio) {
    const frameRate = 60;
    const animationGroup = new AnimationGroup("Enter Exit Animation Group");
    const animations = [
      {
        name: "frontPlateFadeOut",
        mesh: this._frontPlate,
        property: "material.fadeOut",
        keys: [
          {
            frame: 0,
            values: [0, 0, 0.025045314830017686, 0]
          },
          {
            frame: 40,
            values: [1.00205599570012, 0.025045314830017686, 0, 0]
          }
        ]
      },
      {
        name: "textPlateZSlide",
        mesh: this._textPlate,
        property: "position.z",
        keys: [
          {
            frame: 0,
            values: [0, 0, 0]
          },
          {
            frame: 40,
            values: [Vector3.Forward(this._textPlate._scene.useRightHandedSystem).scale(-0.15).z, 0, 0]
          }
        ]
      }
    ];
    for (const animation of animations) {
      const anim = new Animation(animation.name, animation.property, frameRate, Animation.ANIMATIONTYPE_FLOAT, Animation.ANIMATIONLOOPMODE_CYCLE);
      const animkeyFrames = [];
      for (const key of animation.keys) {
        animkeyFrames.push({
          frame: key.frame,
          value: key.values[0],
          inTangent: key.values[1],
          outTangent: key.values[2],
          interpolation: key.values[3]
        });
      }
      anim.setKeys(animkeyFrames);
      if (!animation.mesh) {
        continue;
      }
      animationGroup.addTargetedAnimation(anim, animation.mesh);
    }
    animationGroup.normalize(0, 45);
    animationGroup.speedRatio = speedRatio;
    animationGroup.play();
  }
  _createBackMaterial(mesh) {
    this._backMaterial = this._backMaterial ?? new MRDLBackplateMaterial(this.name + "backPlateMaterial", mesh.getScene());
    this._backMaterial.absoluteSizes = true;
    this._backMaterial.radius = this.radius;
    this._backMaterial.lineWidth = 0.02;
  }
  _createFrontMaterial(mesh) {
    this._frontMaterial = this._frontMaterial ?? new MRDLFrontplateMaterial(this.name + "Front Material", mesh.getScene());
    this.frontMaterial.radius = this.innerQuadRadius;
    this.frontMaterial.fadeOut = 0;
  }
  _createBackGlowMaterial(mesh) {
    const glowRadius = this.radius + 0.04;
    this._backGlowMaterial = this._backGlowMaterial ?? new MRDLBackglowMaterial(this.name + "Back Glow Material", mesh.getScene());
    this._backGlowMaterial.bevelRadius = glowRadius;
    this._backGlowMaterial.lineWidth = glowRadius;
    this._backGlowMaterial.motion = 0;
  }
  _createInnerQuadMaterial(mesh) {
    this._innerQuadMaterial = this._innerQuadMaterial ?? new MRDLInnerquadMaterial("inner_quad", mesh.getScene());
    this._innerQuadMaterial.radius = this.innerQuadRadius;
    if (this.isToggleButton) {
      this._innerQuadMaterial.color = this.innerQuadColor;
    }
  }
  _createPlateMaterial(mesh) {
    this._plateMaterial = this._plateMaterial ?? new StandardMaterial(this.name + "Plate Material", mesh.getScene());
    this._plateMaterial.specularColor = Color3.Black();
  }
  _onToggle(newState) {
    super._onToggle(newState);
  }
  _affectMaterial(mesh) {
    if (this._shareMaterials) {
      if (!this._host._touchSharedMaterials["mrdlBackplateMaterial"]) {
        this._createBackMaterial(mesh);
        this._host._touchSharedMaterials["mrdlBackplateMaterial"] = this._backMaterial;
      } else {
        this._backMaterial = this._host._touchSharedMaterials["mrdlBackplateMaterial"];
      }
      if (!this._host._touchSharedMaterials["mrdlFrontplateMaterial"]) {
        this._createFrontMaterial(mesh);
        this._host._touchSharedMaterials["mrdlFrontplateMaterial"] = this._frontMaterial;
      } else {
        this._frontMaterial = this._host._touchSharedMaterials["mrdlFrontplateMaterial"];
      }
      if (!this._host._touchSharedMaterials["mrdlBackglowMaterial"]) {
        this._createBackGlowMaterial(mesh);
        this._host._touchSharedMaterials["mrdlBackglowMaterial"] = this._backGlowMaterial;
      } else {
        this._backGlowMaterial = this._host._touchSharedMaterials["mrdlBackglowMaterial"];
      }
      if (!this._host._touchSharedMaterials["mrdlInnerQuadMaterial"]) {
        this._createInnerQuadMaterial(mesh);
        this._host._touchSharedMaterials["mrdlInnerQuadMaterial"] = this._innerQuadMaterial;
      } else {
        this._innerQuadMaterial = this._host._touchSharedMaterials["mrdlInnerQuadMaterial"];
      }
    } else {
      this._createBackMaterial(mesh);
      this._createFrontMaterial(mesh);
      this._createBackGlowMaterial(mesh);
      this._createInnerQuadMaterial(mesh);
    }
    this._createPlateMaterial(mesh);
    this._backPlate.material = this._backMaterial;
    this._textPlate.material = this._plateMaterial;
    if (!this._isBackplateVisible) {
      this._backPlate.visibility = 0;
    }
    if (this._frontPlate) {
      this._frontPlate.material = this._frontMaterial;
    }
    if (this._backGlow) {
      this._backGlow.material = this._backGlowMaterial;
    }
    if (this._innerQuad) {
      this._innerQuad.material = this._innerQuadMaterial;
    }
    this._rebuildContent();
  }
  /**
   * Releases all associated resources
   */
  dispose() {
    super.dispose();
    this._disposeTooltip();
    this.onPointerClickObservable.remove(this._pointerClickObserver);
    this.onPointerEnterObservable.remove(this._pointerEnterObserver);
    this.onPointerOutObservable.remove(this._pointerOutObserver);
    this.onToggleObservable.remove(this._toggleObserver);
    if (!this.shareMaterials) {
      this._backMaterial.dispose();
      this._frontMaterial.dispose();
      this._plateMaterial.dispose();
      this._backGlowMaterial.dispose();
      this._innerQuadMaterial.dispose();
      if (this._pickedPointObserver) {
        this._host.onPickedPointChangedObservable.remove(this._pickedPointObserver);
        this._pickedPointObserver = null;
      }
    }
  }
};
TouchHolographicButton2.MRTK_ASSET_BASE_URL = "https://assets.babylonjs.com/meshes/MRTK/";
TouchHolographicButton2.FRONTPLATE_MODEL_FILENAME = "mrtk-fluent-frontplate.glb";
TouchHolographicButton2.BACKPLATE_MODEL_FILENAME = "mrtk-fluent-backplate.glb";
TouchHolographicButton2.BACKGLOW_MODEL_FILENAME = "mrtk-fluent-button.glb";
TouchHolographicButton2.INNERQUAD_MODEL_FILENAME = "SlateProximity.glb";

// node_modules/@babylonjs/gui/3D/gui3DManager.js
var GUI3DManager = class _GUI3DManager {
  /** Gets the hosting scene */
  get scene() {
    return this._scene;
  }
  /** Gets associated utility layer */
  get utilityLayer() {
    return this._utilityLayer;
  }
  /** Gets the scaling for all UI elements owned by this manager */
  get controlScaling() {
    return this._customControlScaling;
  }
  /** Sets the scaling adjustment for all UI elements owned by this manager */
  set controlScaling(newScale) {
    if (this._customControlScaling !== newScale && newScale > 0) {
      const scaleRatio = newScale / this._customControlScaling;
      this._customControlScaling = newScale;
      this._rootContainer.children.forEach((control) => {
        control.scaling.scaleInPlace(scaleRatio);
        if (newScale !== 1) {
          control._isScaledByManager = true;
        }
      });
    }
  }
  /** Gets if controls attached to this manager are realistically sized, based on the fact that 1 unit length is 1 meter */
  get useRealisticScaling() {
    return this.controlScaling === _GUI3DManager.MRTK_REALISTIC_SCALING;
  }
  /** Sets if controls attached to this manager are realistically sized, based on the fact that 1 unit length is 1 meter */
  set useRealisticScaling(newValue) {
    this.controlScaling = newValue ? _GUI3DManager.MRTK_REALISTIC_SCALING : 1;
  }
  /**
   * Creates a new GUI3DManager
   * @param scene
   */
  constructor(scene) {
    this._customControlScaling = 1;
    this._lastControlOver = {};
    this._lastControlDown = {};
    this.onPickedPointChangedObservable = new Observable();
    this.onPickingObservable = new Observable();
    this._sharedMaterials = {};
    this._touchSharedMaterials = {};
    this._scene = scene || EngineStore.LastCreatedScene;
    this._sceneDisposeObserver = this._scene.onDisposeObservable.add(() => {
      this._sceneDisposeObserver = null;
      this._utilityLayer = null;
      this.dispose();
    });
    this._utilityLayer = UtilityLayerRenderer._CreateDefaultUtilityLayerFromScene(this._scene);
    this._utilityLayer.onlyCheckPointerDownEvents = false;
    this._utilityLayer.pickUtilitySceneFirst = false;
    this._utilityLayer.mainSceneTrackerPredicate = (mesh) => {
      var _a, _b, _c;
      return mesh && ((_c = (_b = (_a = mesh.reservedDataStore) == null ? void 0 : _a.GUI3D) == null ? void 0 : _b.control) == null ? void 0 : _c._node);
    };
    this._rootContainer = new Container3D("RootContainer");
    this._rootContainer._host = this;
    const utilityLayerScene = this._utilityLayer.utilityLayerScene;
    this._pointerOutObserver = this._utilityLayer.onPointerOutObservable.add((pointerId) => {
      this._handlePointerOut(pointerId, true);
    });
    this._pointerObserver = utilityLayerScene.onPointerObservable.add((pi) => {
      this._doPicking(pi);
    });
    this._utilityLayer.utilityLayerScene.autoClear = false;
    this._utilityLayer.utilityLayerScene.autoClearDepthAndStencil = false;
    new HemisphericLight("hemi", Vector3.Up(), this._utilityLayer.utilityLayerScene);
  }
  _handlePointerOut(pointerId, isPointerUp) {
    const previousControlOver = this._lastControlOver[pointerId];
    if (previousControlOver) {
      previousControlOver._onPointerOut(previousControlOver);
      delete this._lastControlOver[pointerId];
    }
    if (isPointerUp) {
      if (this._lastControlDown[pointerId]) {
        this._lastControlDown[pointerId].forcePointerUp();
        delete this._lastControlDown[pointerId];
      }
    }
    this.onPickedPointChangedObservable.notifyObservers(null);
  }
  _doPicking(pi) {
    var _a, _b, _c;
    if (!this._utilityLayer || !this._utilityLayer.shouldRender || !this._utilityLayer.utilityLayerScene.activeCamera) {
      return false;
    }
    const pointerEvent = pi.event;
    const pointerId = pointerEvent.pointerId || 0;
    const buttonIndex = pointerEvent.button;
    const pickingInfo = pi.pickInfo;
    if (pickingInfo) {
      this.onPickingObservable.notifyObservers(pickingInfo.pickedMesh);
    }
    if (!pickingInfo || !pickingInfo.hit) {
      this._handlePointerOut(pointerId, pi.type === PointerEventTypes.POINTERUP);
      return false;
    }
    if (pickingInfo.pickedPoint) {
      this.onPickedPointChangedObservable.notifyObservers(pickingInfo.pickedPoint);
    }
    const control = (_b = (_a = pickingInfo.pickedMesh.reservedDataStore) == null ? void 0 : _a.GUI3D) == null ? void 0 : _b.control;
    if (!!control && !control._processObservables(pi.type, pickingInfo.pickedPoint, ((_c = pickingInfo.originMesh) == null ? void 0 : _c.position) || null, pointerId, buttonIndex)) {
      if (pi.type === PointerEventTypes.POINTERMOVE) {
        if (this._lastControlOver[pointerId]) {
          this._lastControlOver[pointerId]._onPointerOut(this._lastControlOver[pointerId]);
        }
        delete this._lastControlOver[pointerId];
      }
    }
    if (pi.type === PointerEventTypes.POINTERUP) {
      if (this._lastControlDown[pointerEvent.pointerId]) {
        this._lastControlDown[pointerEvent.pointerId].forcePointerUp();
        delete this._lastControlDown[pointerEvent.pointerId];
      }
      if (pointerEvent.pointerType === "touch" || pointerEvent.pointerType === "xr" && this._scene.getEngine().hostInformation.isMobile) {
        this._handlePointerOut(pointerId, false);
      }
    }
    return true;
  }
  /**
   * Gets the root container
   */
  get rootContainer() {
    return this._rootContainer;
  }
  /**
   * Gets a boolean indicating if the given control is in the root child list
   * @param control defines the control to check
   * @returns true if the control is in the root child list
   */
  containsControl(control) {
    return this._rootContainer.containsControl(control);
  }
  /**
   * Adds a control to the root child list
   * @param control defines the control to add
   * @returns the current manager
   */
  addControl(control) {
    this._rootContainer.addControl(control);
    if (this._customControlScaling !== 1) {
      control.scaling.scaleInPlace(this._customControlScaling);
      control._isScaledByManager = true;
    }
    return this;
  }
  /**
   * Removes a control from the root child list
   * @param control defines the control to remove
   * @returns the current container
   */
  removeControl(control) {
    this._rootContainer.removeControl(control);
    if (control._isScaledByManager) {
      control.scaling.scaleInPlace(1 / this._customControlScaling);
      control._isScaledByManager = false;
    }
    return this;
  }
  /**
   * Releases all associated resources
   */
  dispose() {
    this._rootContainer.dispose();
    for (const materialName in this._sharedMaterials) {
      if (!Object.prototype.hasOwnProperty.call(this._sharedMaterials, materialName)) {
        continue;
      }
      this._sharedMaterials[materialName].dispose();
    }
    this._sharedMaterials = {};
    for (const materialName in this._touchSharedMaterials) {
      if (!Object.prototype.hasOwnProperty.call(this._touchSharedMaterials, materialName)) {
        continue;
      }
      this._touchSharedMaterials[materialName].dispose();
    }
    this._touchSharedMaterials = {};
    if (this._pointerOutObserver && this._utilityLayer) {
      this._utilityLayer.onPointerOutObservable.remove(this._pointerOutObserver);
      this._pointerOutObserver = null;
    }
    this.onPickedPointChangedObservable.clear();
    this.onPickingObservable.clear();
    const utilityLayerScene = this._utilityLayer ? this._utilityLayer.utilityLayerScene : null;
    if (utilityLayerScene) {
      if (this._pointerObserver) {
        utilityLayerScene.onPointerObservable.remove(this._pointerObserver);
        this._pointerObserver = null;
      }
    }
    if (this._scene) {
      if (this._sceneDisposeObserver) {
        this._scene.onDisposeObservable.remove(this._sceneDisposeObserver);
        this._sceneDisposeObserver = null;
      }
    }
    if (this._utilityLayer) {
      this._utilityLayer.dispose();
    }
  }
};
GUI3DManager.MRTK_REALISTIC_SCALING = 0.032;
export {
  AbstractButton3D,
  AdvancedDynamicTexture,
  AdvancedDynamicTextureInstrumentation,
  BaseGradient,
  BaseSlider,
  Button,
  Button3D,
  Checkbox,
  CheckboxGroup,
  ColorPicker,
  Container,
  Container3D,
  Control,
  Control3D,
  CornerHandle,
  CylinderPanel,
  DisplayGrid,
  Ellipse,
  FluentBackplateMaterial,
  FluentButtonMaterial,
  FluentMaterial,
  FluentMaterialDefines,
  FocusableButton,
  GUI3DManager,
  GizmoHandle,
  Grid,
  HandMenu,
  HandleMaterial,
  HandleState,
  HolographicBackplate,
  HolographicButton,
  HolographicSlate,
  Image,
  ImageBasedSlider,
  ImageScrollBar,
  InputPassword,
  InputText,
  InputTextArea,
  KeyPropertySet,
  Line,
  LinearGradient,
  MRDLBackplateMaterial,
  MRDLSliderBarMaterial,
  MRDLSliderThumbMaterial,
  MathTools,
  Matrix2D,
  Measure,
  MeshButton3D,
  MultiLine,
  MultiLinePoint,
  NearMenu,
  PlanePanel,
  RadialGradient,
  RadioButton,
  RadioGroup,
  Rectangle,
  ScatterPanel,
  ScrollBar,
  ScrollViewer,
  SelectionPanel,
  SelectorGroup,
  SideHandle,
  SlateGizmo,
  Slider,
  Slider3D,
  SliderGroup,
  SpherePanel,
  StackPanel,
  StackPanel3D,
  Style,
  TextBlock,
  TextWrapper,
  TextWrapping,
  ToggleButton,
  TouchButton3D,
  TouchHolographicButton,
  TouchHolographicButton2 as TouchHolographicButtonV3,
  TouchHolographicMenu,
  TouchMeshButton3D,
  ValueAndUnit,
  Vector2WithInfo,
  Vector3WithInfo,
  VirtualKeyboard,
  VolumeBasedPanel,
  XmlLoader,
  name
};
//# sourceMappingURL=@babylonjs_gui.js.map
